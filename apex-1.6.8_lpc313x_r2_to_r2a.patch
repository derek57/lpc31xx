diff -Naur apex-1.6.8-orig/src/mach-lpc313x/drv-lpcnand.c apex-1.6.8/src/mach-lpc313x/drv-lpcnand.c
--- apex-1.6.8-orig/src/mach-lpc313x/drv-lpcnand.c	2009-07-31 09:58:47.000000000 -0700
+++ apex-1.6.8/src/mach-lpc313x/drv-lpcnand.c	2009-08-07 11:30:51.000000000 -0700
@@ -96,10 +96,6 @@
 /* extern functions */
 extern u32 crc32_compute(u8 *data, int length);
 
-/* forward declarations */
-static void nand_reset (void);
-
-
 static const NAND_BOOT_CFG_PARAMS_T chips[] = 
 {
 	/* Micron MT*/
@@ -107,17 +103,41 @@
 	{
 		.tag = "NANDflsh", //{'N', 'A', 'N', 'D', 'f', 'l', 's', 'h',},
 		.interface_width = 8,
-		.page_size_in_bytes = 0x0800,
-		.page_size_in_32bit_words = 0x0200,
-		.pages_per_block = 0x0040,
-		.nbr_of_blocks = 0x0800,
+		.page_size_in_bytes = 2048,
+		.page_size_in_32bit_words = 512,
+		.pages_per_block = 64,
+		.nbr_of_blocks = 2048,
 		.amount_of_address_bytes = 5,
 		.amount_of_erase_address_bytes = 3,
 		.support_read_terminate = 1,
 		.page_increment_byte_nr = 2,
 		.device_name = { 0x2C, 0xAA, 0xFF, 0x15, 0x20, 'M', 'T', '2', '9', 'F', '2', 'G', '0', '8',}, /* first 4bytes to fill with readid response */
 		/* assuming 90MHz clock (1clock = 11ns)to NAND block */
-		/* Note, timing macros take clk +1 values. */
+		/* Note, timing macros tcopy naake clk +1 values. */
+		/* tsrd=3, tals=3, talh=1, tcls=3, tclh=1, */
+		.timing1 = NAND_TIM1_TSRD(3) | NAND_TIM1_TALS(3) | NAND_TIM1_TALH(1) | NAND_TIM1_TCLS(3) | NAND_TIM1_TCLH(1),
+		/* tdrd=3, tebi=1, tch=1, tcs=4, treh=2, trp=4, twh=2, twp = 3*/
+		.timing2 = NAND_TIM2_TDRD(3) | NAND_TIM2_TEBI(1) | NAND_TIM2_TCH(1) | NAND_TIM2_TCS(4) | NAND_TIM2_TRH(2) |
+			NAND_TIM2_TRP(4) | NAND_TIM2_TWH(2) | NAND_TIM2_TWP(3),
+		.ecc_mode = 5,
+		.id_mask = 0x6, /*except 2nd & 3rd byte check remains id bytes */
+	},
+#endif
+#if defined (CONFIG_MICRON_MT29F4G08)
+	{
+		.tag = "NANDflsh", //{'N', 'A', 'N', 'D', 'f', 'l', 's', 'h',},
+		.interface_width = 8,
+		.page_size_in_bytes = 2048,
+		.page_size_in_32bit_words = 512,
+		.pages_per_block = 64,
+		.nbr_of_blocks = 4096,
+		.amount_of_address_bytes = 5,
+		.amount_of_erase_address_bytes = 3,
+		.support_read_terminate = 1,
+		.page_increment_byte_nr = 2,
+		.device_name = { 0x2C, 0xAC, 0x90, 0x15, 0x54, 'M', 'T', '2', '9', 'F', '4', 'G', '0', '8',}, /* first 4bytes to fill with readid response */
+		/* assuming 90MHz clock (1clock = 11ns)to NAND block */
+		/* Note, timing macros tcopy naake clk +1 values. */
 		/* tsrd=3, tals=3, talh=1, tcls=3, tclh=1, */
 		.timing1 = NAND_TIM1_TSRD(3) | NAND_TIM1_TALS(3) | NAND_TIM1_TALH(1) | NAND_TIM1_TCLS(3) | NAND_TIM1_TCLH(1),
 		/* tdrd=3, tebi=1, tch=1, tcs=4, treh=2, trp=4, twh=2, twp = 3*/
@@ -151,11 +171,75 @@
 		.id_mask = 0x6, /*except 2nd & 3rd byte check remains id bytes */
 	},
 #endif
+#if defined (CONFIG_TOSHIBA_TC58DVM82A)
+#define USE8BITCOLADDR
+	{
+		.tag = "NANDflsh", //{'N', 'A', 'N', 'D', 'f', 'l', 's', 'h',},
+		.interface_width = 8,
+		.page_size_in_bytes = 512,
+		.page_size_in_32bit_words = 128,
+		.pages_per_block = 32,
+		.nbr_of_blocks = 2048,
+		.amount_of_address_bytes = 3,
+		.amount_of_erase_address_bytes = 2,
+		.support_read_terminate = 0,
+		.page_increment_byte_nr = 2,
+		.device_name = { 0x98, 0x73, 0xA5, 0xBA, 0xFF, 'T', 'C', '5', '8', 'D', 'V', 'M', '8', '2', 'A' }, /* first 4 bytes to fill with readid response */
+		/* assuming 90MHz clock (1clock = 11ns)to NAND block */
+		/* Note, timing macros take clk +1 values. */
+		/* tsrd=2, tals=3, talh=1, tcls=3, tclh=2, */
+		.timing1 = NAND_TIM1_TSRD(2+1) | NAND_TIM1_TALS(3+1) | NAND_TIM1_TALH(1+1) | NAND_TIM1_TCLS(3+1) | NAND_TIM1_TCLH(2+1),
+		/* tdrd=2, tebi=1, tch=1, tcs=4, treh=2, trp=4, twh=2, twp = 3*/
+		.timing2 = NAND_TIM2_TDRD(2+1) | NAND_TIM2_TEBI(1+1) | NAND_TIM2_TCH(1+1) | NAND_TIM2_TCS(4+1) | NAND_TIM2_TRH(2+1) |
+			NAND_TIM2_TRP(4+1) | NAND_TIM2_TWH(2+1) | NAND_TIM2_TWP(3+1),
+		.ecc_mode = 5,
+		.id_mask = 0x6, /*except 2nd & 3rd byte check remains id bytes */
+	},
+#endif
 };
+
+/* forward declarations */
+static void nand_reset (void);
+static ssize_t lpcnand_write (struct descriptor_d* d, const void* pv, size_t cb);
+
 /*global variables */
 static NAND_BOOT_CFG_PARAMS_T* chip;
 static int g_curr_buf = 0;
+static int nand_modify;
+static int blk0enab;
+static u32 nand_bbl_array [(NANDFLASH_BADBLOCK_LIST_LENGTH + 4 / 32)];
+
+/* Mark a block as bad in the memory based bad block table (from block 0) */
+static void nand_setbb_array_bit(u32 pagenum) {
+	u32 blocknum = pagenum / chip->pages_per_block;
+	u32 idx = blocknum / 32;
+	u32 offs = 1 << (blocknum - (idx * 32));
+
+	nand_bbl_array[idx] &= ~offs;
+}
 
+/* Check if a block in the page is good (!0) or bad (0) in the memory
+   based bad block table */
+static int nand_checkbb_array_bit(u32 pagenum) {
+	u32 blocknum = pagenum / chip->pages_per_block;
+	u32 idx = blocknum / 32;
+	u32 offs = 1 << (blocknum - (idx * 32));
+
+	/* Returns '!0' if the block is good */
+	return (int) (nand_bbl_array[idx] & offs);
+}
+
+/* Modify access check */
+static int nand_modfiy_ok(void) {
+	if (!nand_modify) {
+		printf("NAND block 0 has not been formatted yet!. Modify\n");
+		printf("functions have been disabled. Use the lpcnand f\n");
+		printf("command to prepare NAND FLASH prior to use\n");
+		return 0;
+	}
+
+	return 1;
+}
 
 /* wait_on_busy
 
@@ -182,6 +266,7 @@
 		}
 	}
 }
+
 /* wait_on_int
 Waits for one of the requested interrupts to get set.  
 */
@@ -191,7 +276,8 @@
 	/* Wait for MLC NAND ready */
 	while (!(NANDC_IRQ_STS_RAW & int_mask)) {
 		if (timer_delta (time_start, timer_read ()) >= tmo) {
-			printf ("\nbailing at timeout status 0x%08lx bits 0x%08x\n", NANDC_IRQ_STS_RAW, int_mask);
+			printf ("\nbailing at timeout status 0x%08lx bits 0x%08x\n",
+				NANDC_IRQ_STS_RAW, int_mask);
 			break;
 		}
 	}
@@ -199,6 +285,26 @@
 
 inline void lpcnand_address (unsigned long page, int index)
 {
+#ifdef USE8BITCOLADDR
+	/* Modify address for index value */
+	if (index >= 256)
+		index -= 256;
+	if (index >= 256)
+		index -= 256;
+
+	NANDC_SET_ADDR = (index & 0xff);
+	NANDC_SET_ADDR = ( page        & 0xff);
+	NANDC_SET_ADDR = ((page >>  8) & 0xff);
+printf("ADDR 0x%02x 0x%02x 0x%02x", (index & 0xff),
+	( page        & 0xff), ((page >>  8) & 0xff));
+
+	if (chip->amount_of_address_bytes > 3) {
+		NANDC_SET_ADDR = ((page >> 16) & 0xff);
+printf(" 0x%02x", ((page >>  16) & 0xff));
+}
+printf("\n");
+
+#else
 	NANDC_SET_ADDR = (index & 0xff);
 	NANDC_SET_ADDR = ((index >> 8) & 0xff);
 	NANDC_SET_ADDR = ( page        & 0xff);
@@ -206,20 +312,263 @@
 
 	if (chip->amount_of_address_bytes > 4)
 		NANDC_SET_ADDR = ((page >> 16) & 0xff);
+#endif
 }
 
 inline void lpcnand_read_setup (unsigned long page, int index)
 {
 	/* clear edge status */
 	NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
+
+#ifdef USE8BITCOLADDR
+	if (index < 256) {
+		NANDC_SET_CMD = NAND_ReadSetup;
+printf("0x00-read index %d", index);
+	}
+	else if (index < 512) {
+		NANDC_SET_CMD = 0x01;
+printf("0x01-read index %d", index);
+	}
+	else {
+		NANDC_SET_CMD = 0x50;
+printf("0x50-read index %d", index);
+	}
+
+#else
 	NANDC_SET_CMD = NAND_ReadSetup;
+#endif
+
 	lpcnand_address (page, index);
-	if (chip->support_read_terminate)
+	if (chip->support_read_terminate) {
 		NANDC_SET_CMD = NAND_Read;
+}
 	wait_on_int (NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_READ);
 }
 
 
+/* Check block 0 for boot ROM header and build saved bad block list */
+static int lpcnand_block0_good(void)
+{
+	char tag [9];
+	int i, val;
+	unsigned long idx = 0xFFFFFFFF, page = 1;
+	int offs = 0, entries;
+
+	/* Read block 0, page 0, offset 0 */
+	lpcnand_read_setup(0, 0);
+
+	for (i = 0; i < 9; i++)
+		tag[i] = (char) NANDC_READ_DATA;
+	tag[8] = '\0';
+
+	if (strcmp(tag, "NANDflsh") != 0)
+		return 0;
+
+	memset((void*)nand_bbl_array, 0xFF, sizeof(nand_bbl_array));
+
+	/* Read bad block data */
+	lpcnand_read_setup(page, offs);
+
+	/* Get the number of bad blocks */
+	if (idx == 0xFFFFFFFF) {
+		idx = (NANDC_READ_DATA & 0xFF) << 0;
+		idx |= (NANDC_READ_DATA & 0xFF) << 8;
+		idx |= (NANDC_READ_DATA & 0xFF) << 16;
+		idx |= (NANDC_READ_DATA & 0xFF) << 24;
+	}
+	if (idx == 0xFFFFFFFF) {
+		/* Something is wrong */
+		nand_modify = 0;
+
+		return 0;
+	}
+
+	/* Generate list from entries */
+	entries = (int) idx;
+	while (entries > 0) {
+		val = ((NANDC_READ_DATA & 0xFF) << 0) | ((NANDC_READ_DATA & 0xFF) << 8) |
+			((NANDC_READ_DATA & 0xFF) << 16) | ((NANDC_READ_DATA & 0xFF) << 24);
+		if ((val & 0x00FFFFFF) == ((((u32) 'B') << 0) | (((u32) 'A') << 8) |
+			(((u32) 'D') << 16))) {
+			/* Go to the next page and continue */
+			offs += 512;
+			if (offs >= chip->page_size_in_bytes) {
+				page++;
+				offs = 0;
+			}
+
+			/* Read bad block data */
+			lpcnand_read_setup(page, offs);
+		}
+		else {
+			nand_setbb_array_bit(val * chip->pages_per_block);
+			entries--;
+		}
+	}
+
+	return 1;
+}
+
+static void write_badblock_list(void)
+{
+	u32* bad_list_buf = (u32*)EXT_SDRAM_PHYS;
+	char* buff_ptr;
+	u32 temp_buff[2];
+	int curr_pos = 0;
+	int magic_word_pos;
+	int page_nr;
+	int cBad = 0;
+	struct descriptor_d desc;
+
+	DBG (1, "before memset buf:0x%08x len:%d\n", (u32)bad_list_buf, NANDFLASH_BADBLOCK_LIST_LENGTH * 4);
+
+	/* fill buffer with 0xFF */
+	memset((void*)bad_list_buf, 0xFF, NANDFLASH_BADBLOCK_LIST_LENGTH * 4);
+	memset((void*)nand_bbl_array, 0xFF, sizeof(nand_bbl_array));
+	
+	DBG (1, "memset done page:%d / %d\n", chip->pages_per_block, chip->nbr_of_blocks);
+	cBad = 0;
+	/* build bad block list page */
+	for (page_nr = chip->pages_per_block; 
+		page_nr < (chip->nbr_of_blocks * chip->pages_per_block); 
+		page_nr += chip->pages_per_block) {
+
+		DBG (1, "page_nr:%d \r", page_nr);
+		/* reset nand device */
+		nand_reset ();
+		/* index to spare area */
+		lpcnand_read_setup(page_nr, chip->page_size_in_bytes); 
+		if (NANDC_READ_DATA != 0xFF) {
+			printf ("Block %d bad\n", page_nr/chip->pages_per_block);
+			++cBad;
+			nand_setbb_array_bit(page_nr);
+			*((u32*)(bad_list_buf + cBad)) = page_nr/chip->pages_per_block;
+			if (cBad > NANDFLASH_BADBLOCK_LIST_LENGTH)
+				break;
+		}
+	}
+	/* update bad block count */
+	*bad_list_buf = cBad;
+
+	curr_pos = 0;
+	page_nr = 1;
+	while (curr_pos < (cBad + 1)) {
+
+		if ( (cBad + 1 - curr_pos) < (chip->page_size_in_32bit_words - 2)) {
+			magic_word_pos = cBad + 1;
+		}
+		else {
+			magic_word_pos = curr_pos + chip->page_size_in_32bit_words - 2;
+		}
+		DBG (1, "curr_pos:%d, cBad:%d, magic_pos:%d\n", curr_pos, cBad, magic_word_pos);
+
+		/* save last 2 words in current page to write with magic id & CRC.
+		Not needed if CBad < (chip->page_size_in_32bit_words - 2)*/
+		temp_buff[0] = bad_list_buf[magic_word_pos];
+		temp_buff[1] = bad_list_buf[magic_word_pos + 1];
+
+		/* insert magic word */
+		buff_ptr = (char*)&bad_list_buf[magic_word_pos];
+		buff_ptr[0] = 'B';
+		buff_ptr[1] = 'A';
+		buff_ptr[2] = 'D';
+		buff_ptr[3] = (char)(page_nr & 0xFF);
+
+		/* compute CRC32 */
+		bad_list_buf[magic_word_pos + 1] = crc32_compute((u8*)&bad_list_buf[curr_pos], 
+			((u32)&buff_ptr[4] - (u32)&bad_list_buf[curr_pos]));
+
+		/* create the nand descriptor for write routine */
+		desc.index = 0;
+		desc.start = page_nr * chip->page_size_in_bytes;
+		desc.length = chip->page_size_in_bytes;
+
+		DBG (1, "buff_ptr:0x%08x, start:0x%08x, page_nr:%d\n", (u32)buff_ptr, desc.start, page_nr);
+
+		/* write the bad page */
+		if (lpcnand_write (&desc, (void*)(bad_list_buf + curr_pos), 
+			chip->page_size_in_bytes) < chip->page_size_in_bytes) {
+			printf ("Write bad block page %d failed\n", page_nr);
+			return;
+		}
+		
+		/*put back last 2 words*/
+		bad_list_buf[magic_word_pos] = temp_buff[0];
+		bad_list_buf[magic_word_pos + 1] = temp_buff[1];
+		/* move to next page */
+		page_nr++;
+		/* update current position in bad block list */
+		curr_pos = magic_word_pos;
+	}
+}
+
+static void format_device(void) {
+	void* ptr;
+	int count;
+	int tmp;
+
+	tmp = blk0enab;
+	blk0enab = 1;
+	nand_modify = 1;
+
+	/* erase block 0 */
+	NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
+	NANDC_SET_CMD = NAND_Erase;
+	for (count=0; count< chip->amount_of_erase_address_bytes; count++ )
+		NANDC_SET_ADDR = 0x00;
+
+	NANDC_SET_CMD = NAND_EraseConfirm;
+	wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_ERASE);
+	/* Send page program command  */
+	NANDC_SET_CMD = NAND_PageProgram;
+	lpcnand_address (0, 0);
+	/* set HW flow control to write the page and do ECC */
+	NANDC_IRQ_STS_RAW = 0xFFFFFFFF;
+	/* build param page */
+	ptr = (g_curr_buf)?(void*)NANDC_RAM1_PHYS:(void*)NANDC_RAM0_PHYS;
+	memcpy(ptr, (void*)chip, sizeof(NAND_BOOT_CFG_PARAMS_T));
+	memset(ptr + sizeof(NAND_BOOT_CFG_PARAMS_T), 
+		0, (LPC313x_NAND_BPARAM_PAGE_SZ - sizeof(NAND_BOOT_CFG_PARAMS_T) - 4));
+	/* compute CRC32. */
+	*((u32*)(ptr + (LPC313x_NAND_BPARAM_PAGE_SZ - 4))) = 
+		crc32_compute((g_curr_buf)?(u8*)NANDC_RAM1_PHYS:(u8*)NANDC_RAM0_PHYS, 
+		LPC313x_NAND_BPARAM_PAGE_SZ - 4);
+
+	DBG (1, "crc 0x%08x / 0x%08x\n",  
+		*((u32*)(ptr + (NANDC_BUF_SZ - 4))), (u32)(ptr + (NANDC_BUF_SZ - 4)));
+	/* fill rest of the sub-page.*/ 
+	memset(ptr + LPC313x_NAND_BPARAM_PAGE_SZ, 
+		0xFF, (NANDC_BUF_SZ - LPC313x_NAND_BPARAM_PAGE_SZ));
+	/*When 512-516 bytes are written it will trigger ECC computation.*/
+	*((u32*)(ptr + NANDC_BUF_SZ)) = 0xFFFFFFFF;
+
+	/* see if ECC check is enabled */
+	if (NANDC_CFG & NAND_CFG_EC)
+		wait_on_int((g_curr_buf)?NAND_IRQ_ECC_ENC_RAM1:NAND_IRQ_ECC_ENC_RAM0, TIMEOUT_WAIT_PROGRAM);
+	/* write param page */
+	NANDC_CTRL_FLOW = (g_curr_buf)?NAND_CTRLFLW_WRITE_RAM1:NAND_CTRLFLW_WRITE_RAM0;
+	wait_on_int((g_curr_buf)?NAND_IRQ_WR_RAM1:NAND_IRQ_WR_RAM0, TIMEOUT_WAIT_PROGRAM);
+	/*toggle buff */
+	g_curr_buf ^= 1;
+	NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
+	NANDC_SET_CMD = NAND_PageProgramConfirm;
+	wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_PROGRAM);
+	/* check status */
+	NANDC_SET_CMD = NAND_Status;
+	udelay(5);// Wait for tWHR
+	if (NANDC_READ_DATA & NAND_Fail) {
+		printf ("Write param page failed\n");
+		nand_modify = 0;
+		blk0enab = tmp;
+		return;
+	}
+
+	/* now write bad block list page */
+	write_badblock_list();
+
+	blk0enab = tmp;
+}
+
 /* nand_init
 
 probes the NAND flash device.
@@ -227,9 +576,7 @@
 Note that the status check redundantly sends the Status command
 when we are not using the CONFIG_NAND_LPD mode.  It's left in for
 now.
-
 */
-
 static void lpcnand_init (void)
 {
 	unsigned short id[4];
@@ -322,6 +669,26 @@
 		printf (" unknown 0x%02x/0x%02x/0x%02x/0x%02x\n",
 		id[0], id[1], id[2], id[3]);
 
+ 	/* Does block 0 have a valid structure yet? */
+	blk0enab = 0;
+	nand_modify = 0;
+
+	if (lpcnand_block0_good() != 0) {
+		/* Populate bad block list array from block 0 */
+		nand_modify = 1;
+	}
+	else {
+#if defined (CONFIG_AUTOFORMAT_BLOCK0)
+		printf("NAND Block 0 is being formatted.\n");
+		format_device();
+
+#else
+		printf("NAND Block 0 has not yet been formatted for operation. NAND modify\n"
+			"operations have been temporarily suspended. Use the 'lpcnand format\n"
+			"command to setup block 0.\n");
+#endif
+	}
+
 exit:
 	NAND_CS_DISABLE;
 }
@@ -336,18 +703,38 @@
 	return 0;
 }
 
+static int read_buffer(u8 *buffer, int bytes) {
+	/* set HW flow control to read the page and do ECC */
+	NANDC_IRQ_STS_RAW = 0xFFFFFFFF;
+
+	NANDC_CTRL_FLOW = (g_curr_buf)?NAND_CTRLFLW_READ_RAM1:NAND_CTRLFLW_READ_RAM0;
+	wait_on_int((g_curr_buf)?NAND_IRQ_RD_RAM1:NAND_IRQ_RD_RAM0, TIMEOUT_WAIT_RBY);
+
+	/* see if ECC check is enabled */
+	if (NANDC_CFG & NAND_CFG_EC)
+		wait_on_int((g_curr_buf)?NAND_IRQ_ECC_DEC_RAM1:NAND_IRQ_ECC_DEC_RAM0, TIMEOUT_WAIT_RBY);
+
+	memcpy(buffer, (g_curr_buf)?(void*)NANDC_RAM1_PHYS:(void*)NANDC_RAM0_PHYS, bytes);
+	/* toggle buffer */
+	g_curr_buf ^= 1;
+
+	return 1;
+}
+
 static ssize_t lpcnand_read (struct descriptor_d* d, void* pv, size_t cb)
 {
 	ssize_t cbRead = 0;
+	unsigned long blk;
 
 	if (!chip)
 		return cbRead;
 
+	if (nand_modfiy_ok() == 0)
+		return 0;
+
 	if (d->index + cb > d->length)
 		cb = d->length - d->index;
 
-	SPINNER_STEP;
-
 	while (cb) {
 		unsigned long page  = (d->start + d->index)/chip->page_size_in_bytes;
 		int index = (d->start + d->index) & (chip->page_size_in_bytes - 1);
@@ -362,124 +749,143 @@
 		/* if index is not 0 then add 16 byte for every 512 block. */
 		index += (((index >> 9) & 0x3)) * 16;
 
+		/* If the current block is bad, move to the next block */
+		if (nand_checkbb_array_bit(page) == 0) {
+			blk = page / chip->pages_per_block;
+			printf("Read:Skipping bad block %d\n", (int) blk);
+
+			/* Continue at next block */
+			d->start = (blk + 1) * chip->pages_per_block * chip->page_size_in_bytes;
+			d->index = 0;
+		}
+		else {
+			if (available > cb)
+				available = cb;
 
-		if (available > cb)
-			available = cb;
-
-		d->index += available;
-		cb -= available;
-		cbRead += available;
+			d->index += available;
+			cb -= available;
+			cbRead += available;
 
-		/* reset nand device */
-		nand_reset ();
-		/* do read setup */
-		lpcnand_read_setup (page, index);
+			/* reset nand device */
+			nand_reset ();
+			/* do read setup */
+			lpcnand_read_setup (page, index);
 
-		
-		while (available > 0) {
-			/* set HW flow control to read the page and do ECC */
-			NANDC_IRQ_STS_RAW = 0xFFFFFFFF;
-			NANDC_CTRL_FLOW = (g_curr_buf)?NAND_CTRLFLW_READ_RAM1:NAND_CTRLFLW_READ_RAM0;
-			wait_on_int((g_curr_buf)?NAND_IRQ_RD_RAM1:NAND_IRQ_RD_RAM0, TIMEOUT_WAIT_RBY);
-
-			/* see if ECC check is enabled */
-			if (NANDC_CFG & NAND_CFG_EC)
-				wait_on_int((g_curr_buf)?NAND_IRQ_ECC_DEC_RAM1:NAND_IRQ_ECC_DEC_RAM0, TIMEOUT_WAIT_RBY);
-			
-			/* do memcopy */
-			toread = (available < NANDC_BUF_SZ)?available:NANDC_BUF_SZ;
-			memcpy(pv, (g_curr_buf)?(void*)NANDC_RAM1_PHYS:(void*)NANDC_RAM0_PHYS, toread);
-			/* toggle buffer */
-			g_curr_buf ^= 1;
+			while (available > 0) {
+				toread = (available < NANDC_BUF_SZ)?available:NANDC_BUF_SZ;
+				read_buffer((u8 *) pv, toread);
 
-			pv += toread;
-			available -= toread;
+				pv += toread;
+				available -= toread;
+			}
 		}
-		SPINNER_STEP;
 	}
 
 	return cbRead;
 }
 
+static int write_buffer(u8 *buffer, int bytes) {
+	void* buf;
+
+	/* set HW flow control to read the page and do ECC */
+	NANDC_IRQ_STS_RAW = 0xFFFFFFFF;
+
+	/* Write output buffer to memory */
+	buf = (g_curr_buf)?(void*)NANDC_RAM1_PHYS:(void*)NANDC_RAM0_PHYS;
+	memcpy(buf, buffer, bytes);
+	if (bytes < NANDC_BUF_SZ) {
+		memset(buf + bytes, 0xFF, NANDC_BUF_SZ - bytes);
+	}
+	if (bytes <= NANDC_BUF_SZ) {
+		/*When 512-516 bytes are written it will trigger ECC computation.*/
+		*((u32*)(buf + NANDC_BUF_SZ)) = 0xFFFFFFFF;
+	}
+
+	/* see if ECC check is enabled */
+	if (NANDC_CFG & NAND_CFG_EC)
+		wait_on_int((g_curr_buf)?NAND_IRQ_ECC_ENC_RAM1:NAND_IRQ_ECC_ENC_RAM0, TIMEOUT_WAIT_RBY);
+	NANDC_CTRL_FLOW = (g_curr_buf)?NAND_CTRLFLW_WRITE_RAM1:NAND_CTRLFLW_WRITE_RAM0;
+	wait_on_int((g_curr_buf)?NAND_IRQ_WR_RAM1:NAND_IRQ_WR_RAM0, TIMEOUT_WAIT_RBY);
+
+	/* toggle buffer */
+	g_curr_buf ^= 1;
+
+	return 1;
+}
+
 static ssize_t lpcnand_write (struct descriptor_d* d, const void* pv, size_t cb)
 {
 	int cbWrote = 0;
-	void* buf;
+	unsigned long blk;
 
 	if (!chip)
 		return cbWrote;
 
+	if (nand_modfiy_ok() == 0)
+		return 0;
+
 	if (d->index + cb > d->length)
 		cb = d->length - d->index;
 
-	SPINNER_STEP;
-
 	while (cb) {
 		unsigned long page  = (d->start + d->index)/chip->page_size_in_bytes;
 		int index = (d->start + d->index) & (chip->page_size_in_bytes - 1);
 		int available = chip->page_size_in_bytes - index;
 		int towrite;
 
+		if ((blk0enab == 0) && (page == 0)) {
+			printf("\nCan't write block 0 (protected), use lpcnand protblk0 to disable\n");
+			return 0;
+		}
+
 		/* this driver always writes on sub-page (512) boundaries only */
 		if (index & (NANDC_BUF_SZ -1)) {
-			printf("unaligned read 0x%08x\n", d->start + d->index);
+			printf("unaligned write 0x%08x\n", d->start + d->index);
 			return 0;
 		}
 		/* if index is not 0 then add 16 byte for every 512 block. */
 		index += (((index >> 9) & 0x3)) * 16;
 
-		if (available > cb)
-			available = cb;
+		/* If the current block is bad, move to the next block */
+		if (nand_checkbb_array_bit(page) == 0) {
+			blk = page / chip->pages_per_block;
+			printf("Skipping write of bad block %d\n", (int) blk);
+
+			/* Continue at next block */
+			d->start = (blk + 1) * chip->pages_per_block * chip->page_size_in_bytes;
+			d->index = 0;
+		}
+		else {
+			if (available > cb)
+				available = cb;
 
-		/* Reset and read to perform I/O on the data region  */
-		nand_reset ();
+			/* Reset and read to perform I/O on the data region  */
+			nand_reset ();
+
+			/* Send page program command  */
+			NANDC_SET_CMD = NAND_PageProgram;
+			lpcnand_address (page, index);
+
+			DBG(1, "lpcnand write page:0x%08lx index:0x%08x pv:0x%08x\n", page, index, (u32)pv);
+			d->index += available;
+			cb -= available;
+			cbWrote += available;
 
-		/* Send page program command  */
-		NANDC_SET_CMD = NAND_PageProgram;
-		lpcnand_address (page, index);
-
-		DBG(1, "lpcnand write page:0x%08lx index:0x%08x pv:0x%08x\n", page, index, (u32)pv);
-		d->index += available;
-		cb -= available;
-		cbWrote += available;
-
-		while (available > 0) {
-			/* set HW flow control to read the page and do ECC */
-			NANDC_IRQ_STS_RAW = 0xFFFFFFFF;
-			/* do memcopy */
-			towrite = (available < NANDC_BUF_SZ)? available : NANDC_BUF_SZ;
-			buf = (g_curr_buf)?(void*)NANDC_RAM1_PHYS:(void*)NANDC_RAM0_PHYS;
-
-			memcpy(buf, pv, towrite);
-			if (towrite < NANDC_BUF_SZ)
-				memset(buf + towrite, 0xFF, NANDC_BUF_SZ - towrite);
-
-			/*When 512-516 bytes are written it will trigger ECC computation.*/
-			*((u32*)(buf + NANDC_BUF_SZ)) = 0xFFFFFFFF;
-
-			DBG(2, "sub-page pv:0x%08x towrite:0x%08x\n", (u32)pv, towrite);
-			pv += towrite;
-			available -= towrite;
-			/* see if ECC check is enabled */
-			if (NANDC_CFG & NAND_CFG_EC)
-				wait_on_int((g_curr_buf)?NAND_IRQ_ECC_ENC_RAM1:NAND_IRQ_ECC_ENC_RAM0, TIMEOUT_WAIT_RBY);
-			NANDC_CTRL_FLOW = (g_curr_buf)?NAND_CTRLFLW_WRITE_RAM1:NAND_CTRLFLW_WRITE_RAM0;
-			wait_on_int((g_curr_buf)?NAND_IRQ_WR_RAM1:NAND_IRQ_WR_RAM0, TIMEOUT_WAIT_RBY);
-			/* toggle buffer */
-			g_curr_buf ^= 1;
-
-		}
-		NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
-		NANDC_SET_CMD = NAND_PageProgramConfirm;
-		wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_PROGRAM);
-
-		SPINNER_STEP;
-
-		NANDC_SET_CMD = NAND_Status;
-		udelay(5);// Wait for tWHR
-		if (NANDC_READ_DATA & NAND_Fail) {
-			printf ("Write failed at page %ld\n", page);
-			goto exit;
+			while (available > 0) {
+				towrite = (available < NANDC_BUF_SZ)? available : NANDC_BUF_SZ;
+				write_buffer((u8 *) pv, towrite);
+				available -= towrite;
+			}
+			NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
+			NANDC_SET_CMD = NAND_PageProgramConfirm;
+			wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_PROGRAM);
+
+			NANDC_SET_CMD = NAND_Status;
+			udelay(5);// Wait for tWHR
+			if (NANDC_READ_DATA & NAND_Fail) {
+				printf ("Write failed at page %ld\n", page);
+				goto exit;
+			}
 		}
 	}
 
@@ -487,39 +893,54 @@
 	return cbWrote;
 }
 
+static int erase_block(unsigned long page) {
+	int count;
+
+	NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
+	NANDC_SET_CMD = NAND_Erase;
+
+	for (count=0; count< chip->amount_of_erase_address_bytes; count++, page >>= 8 )
+		NANDC_SET_ADDR = (u8)( page & 0xff );
+	NANDC_SET_CMD = NAND_EraseConfirm;
+
+	wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_ERASE);
+
+	NANDC_SET_CMD = NAND_Status;
+	udelay(5);
+	if (NANDC_READ_DATA & NAND_Fail) {
+		return 0;
+	}
+
+	return 1;
+}
+
 static void lpcnand_erase (struct descriptor_d* d, size_t cb)
 {
-	int count;
 	u32 erase_size = (chip->page_size_in_bytes * chip->pages_per_block);
 	if (!chip)
 		return;
 
+	if (nand_modfiy_ok() == 0)
+		return;
+
 	if (d->index + cb > d->length)
 		cb = d->length - d->index;
 
-	SPINNER_STEP;
-
 	do {
 		unsigned long page = (d->start + d->index)/chip->page_size_in_bytes;
 		unsigned long available
 			= erase_size - ((d->start + d->index) & (erase_size - 1));
 
-		NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
-		NANDC_SET_CMD = NAND_Erase;
-		for (count=0; count< chip->amount_of_erase_address_bytes; count++, page >>= 8 )
-			NANDC_SET_ADDR = (u8)( page & 0xff );
-
-		NANDC_SET_CMD = NAND_EraseConfirm;
-
-		wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_ERASE);
-
-		SPINNER_STEP;
-
-		NANDC_SET_CMD = NAND_Status;
-		udelay(5);
-		if (NANDC_READ_DATA & NAND_Fail) {
-			printf ("Erase failed at page %ld\n", page);
-			goto exit;
+		if ((blk0enab == 0) && (page == 0)) {
+			printf("Can't erase block 0, use lpcnand protblk0 to disable\n");
+		}
+		else if (nand_checkbb_array_bit(page) == 0) {
+			printf("Bad block %d, skipping...\n", (int) page/chip->pages_per_block);
+		}
+		else {
+			if (erase_block(page) == 0) {
+				printf ("Erase failed at block %ld\n", page/chip->pages_per_block);
+			}
 		}
 
 		if (available < cb) {
@@ -531,14 +952,9 @@
 			d->index = d->length;
 		}
 	} while (cb > 0);
-
-exit:
-	return;
-
 }
 
 #if !defined (CONFIG_SMALL)
-
 static void lpcnand_report (void)
 {
 	unsigned char status;
@@ -559,7 +975,6 @@
 		(status & NAND_Writable) ? " R/W" : " R/O"
 		);
 }
-
 #endif
 
 static __driver_3 struct driver_d lpcnand_driver = {
@@ -581,174 +996,82 @@
 #endif
 };
 
-static void write_badblock_list(void)
-{
-	u32* bad_list_buf = (u32*)EXT_SDRAM_PHYS;
-	char* buff_ptr;
-	u32 temp_buff[2];
-	int curr_pos = 0;
-	int magic_word_pos;
-	int page_nr;
-	int cBad = 0;
-	struct descriptor_d desc;
-
-	DBG (1, "before memset buf:0x%08x len:%d\n", (u32)bad_list_buf, NANDFLASH_BADBLOCK_LIST_LENGTH * 4);
+#define SMALLPAGESIZE (512)
+void mark_page_bad(unsigned long page) {
+	u8* tmp_buf = (u8 *) EXT_SDRAM_PHYS;
+
+	/* Setup buffer for bad block markers */
+	memset((void*)tmp_buf, 0xff, SMALLPAGESIZE);
+	tmp_buf[512] = 0;
 
-	/* fill buffer with 0xFF */
-	memset((void*)bad_list_buf, 0xFF, NANDFLASH_BADBLOCK_LIST_LENGTH * 4);
-	
-	DBG (1, "memset done page:%d / %d\n", chip->pages_per_block, chip->nbr_of_blocks);
-	cBad = 0;
-	/* build bad block list page */
-	for (page_nr = chip->pages_per_block; 
-		page_nr < (chip->nbr_of_blocks * chip->pages_per_block); 
-		page_nr += chip->pages_per_block) {
+	nand_reset ();
 
-		DBG (1, "page_nr:%d \r", page_nr);
-		/* reset nand device */
-		nand_reset ();
-		/* index to spare area */
-		lpcnand_read_setup(page_nr, chip->page_size_in_bytes); 
-		if (NANDC_READ_DATA != 0xFF) {
-			printf ("Block %d bad\n", page_nr/chip->pages_per_block);
-			++cBad;
-			*((u32*)(bad_list_buf + cBad)) = page_nr/chip->pages_per_block;
-			if (cBad > NANDFLASH_BADBLOCK_LIST_LENGTH)
-				break;
-		}
+	NANDC_SET_CMD = NAND_PageProgram;
+	if (chip->page_size_in_bytes == 512) {
+		/* Small block FLASH, no extra indicing */
+		lpcnand_address (page, 0);
+	}
+	else if (chip->page_size_in_bytes == 2048) {
+		/* Large block FLASH, no extra indicing */
+		lpcnand_address (page, (3 * SMALLPAGESIZE));
+	}
+	else {
+		/* Huge block FLASH, no extra indicing */
+		lpcnand_address (page, (7 * SMALLPAGESIZE));
 	}
-	/* update bad block count */
-	*bad_list_buf = cBad;
-
-	curr_pos = 0;
-	page_nr = 1;
-	while (curr_pos < (cBad + 1)) {
-
-		if ( (cBad + 1 - curr_pos) < (chip->page_size_in_32bit_words - 2)) {
-			magic_word_pos = cBad + 1;
-		}
-		else {
-			magic_word_pos = curr_pos + chip->page_size_in_32bit_words - 2;
-		}
-		DBG (1, "curr_pos:%d, cBad:%d, magic_pos:%d\n", curr_pos, cBad, magic_word_pos);
-
-		/* save last 2 words in current page to write with magic id & CRC.
-		Not needed if CBad < (chip->page_size_in_32bit_words - 2)*/
-		temp_buff[0] = bad_list_buf[magic_word_pos];
-		temp_buff[1] = bad_list_buf[magic_word_pos + 1];
-
-		/* insert magic word */
-		buff_ptr = (char*)&bad_list_buf[magic_word_pos];
-		buff_ptr[0] = 'B';
-		buff_ptr[1] = 'A';
-		buff_ptr[2] = 'D';
-		buff_ptr[3] = (char)(page_nr & 0xFF);
-
-		/* compute CRC32 */
-		bad_list_buf[magic_word_pos + 1] = crc32_compute((u8*)&bad_list_buf[curr_pos], 
-			((u32)&buff_ptr[4] - (u32)&bad_list_buf[curr_pos]));
 
-		/* create the nand descriptor for write routine */
-		desc.index = 0;
-		desc.start = page_nr * chip->page_size_in_bytes;
-		desc.length = chip->page_size_in_bytes;
+	write_buffer(tmp_buf, 516);
 
-		DBG (1, "buff_ptr:0x%08x, start:0x%08x, page_nr:%d\n", (u32)buff_ptr, desc.start, page_nr);
+	NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
+	NANDC_SET_CMD = NAND_PageProgramConfirm;
+	wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_PROGRAM);
 
-		/* write the bad page */
-		if (lpcnand_write (&desc, (void*)(bad_list_buf + curr_pos), 
-			chip->page_size_in_bytes) < chip->page_size_in_bytes) {
-			printf ("Write bad block page %d failed\n", page_nr);
-			return;
-		}
-		
-		/*put back last 2 words*/
-		bad_list_buf[magic_word_pos] = temp_buff[0];
-		bad_list_buf[magic_word_pos + 1] = temp_buff[1];
-		/* move to next page */
-		page_nr++;
-		/* update current position in bad block list */
-		curr_pos = magic_word_pos;
+	NANDC_SET_CMD = NAND_Status;
+	udelay(5);// Wait for tWHR
+	if (NANDC_READ_DATA & NAND_Fail) {
+		printf ("Failed marking %d block bad\n", (int) (page/chip->pages_per_block));
+	}
+	else {
+		printf("Block %d marked bad\n", (int) (page/chip->pages_per_block));
 	}
 }
 
 int cmd_lpcnand (int argc, const char** argv)
 {
-	void* ptr;
-	int count;
-	int page;
-	int cBad = 0;
+	int page, cBad = 0;
 
 	if (!chip)
 		return 0;
 
 	if (PARTIAL_MATCH (argv[1], "f", "ormat") == 0) {
-
-		/* erase block 0 */
-		NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
-		NANDC_SET_CMD = NAND_Erase;
-		for (count=0; count< chip->amount_of_erase_address_bytes; count++ )
-			NANDC_SET_ADDR = 0x00;
-
-		NANDC_SET_CMD = NAND_EraseConfirm;
-		wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_ERASE);
-		/* Send page program command  */
-		NANDC_SET_CMD = NAND_PageProgram;
-		lpcnand_address (0, 0);
-		/* set HW flow control to write the page and do ECC */
-		NANDC_IRQ_STS_RAW = 0xFFFFFFFF;
-		/* build param page */
-		ptr = (g_curr_buf)?(void*)NANDC_RAM1_PHYS:(void*)NANDC_RAM0_PHYS;
-		memcpy(ptr, (void*)chip, sizeof(NAND_BOOT_CFG_PARAMS_T));
-		memset(ptr + sizeof(NAND_BOOT_CFG_PARAMS_T), 
-			0, (LPC313x_NAND_BPARAM_PAGE_SZ - sizeof(NAND_BOOT_CFG_PARAMS_T) - 4));
-		/* compute CRC32. */
-		*((u32*)(ptr + (LPC313x_NAND_BPARAM_PAGE_SZ - 4))) = 
-			crc32_compute((g_curr_buf)?(u8*)NANDC_RAM1_PHYS:(u8*)NANDC_RAM0_PHYS, 
-			LPC313x_NAND_BPARAM_PAGE_SZ - 4);
-
-		DBG (1, "crc 0x%08x / 0x%08x\n",  
-			*((u32*)(ptr + (NANDC_BUF_SZ - 4))), (u32)(ptr + (NANDC_BUF_SZ - 4)));
-		/* fill rest of the sub-page.*/ 
-		memset(ptr + LPC313x_NAND_BPARAM_PAGE_SZ, 
-			0xFF, (NANDC_BUF_SZ - LPC313x_NAND_BPARAM_PAGE_SZ));
-		/*When 512-516 bytes are written it will trigger ECC computation.*/
-		*((u32*)(ptr + NANDC_BUF_SZ)) = 0xFFFFFFFF;
-
-		/* see if ECC check is enabled */
-		if (NANDC_CFG & NAND_CFG_EC)
-			wait_on_int((g_curr_buf)?NAND_IRQ_ECC_ENC_RAM1:NAND_IRQ_ECC_ENC_RAM0, TIMEOUT_WAIT_PROGRAM);
-		/* write param page */
-		NANDC_CTRL_FLOW = (g_curr_buf)?NAND_CTRLFLW_WRITE_RAM1:NAND_CTRLFLW_WRITE_RAM0;
-		wait_on_int((g_curr_buf)?NAND_IRQ_WR_RAM1:NAND_IRQ_WR_RAM0, TIMEOUT_WAIT_PROGRAM);
-		/*toggle buff */
-		g_curr_buf ^= 1;
-		NANDC_IRQ_STS_RAW = NAND_IRQ_RB_POS_EDGE(CURR_CS);
-		NANDC_SET_CMD = NAND_PageProgramConfirm;
-		wait_on_int(NAND_IRQ_RB_POS_EDGE(CURR_CS), TIMEOUT_WAIT_PROGRAM);
-		/* check status */
-		NANDC_SET_CMD = NAND_Status;
-		udelay(5);// Wait for tWHR
-		if (NANDC_READ_DATA & NAND_Fail) {
-			printf ("Write param page failed\n");
-			return 0;
+	 	/* Does block 0 already have a valid structure yet? */
+		if (nand_modify) {
+			printf("Block 0 already has a valid structure!\n");
+
+			if ((argc >= 2) || (argv[2][0] != '1')) {
+				printf("CAUTION: The bad block list in block 0 contains the entire bad\n"
+					"block list for the device from factory marked bad blocks. If\n"
+					"you erase this block now, you may lose these markers forever!\n"
+					"You can override this warning message with 'lpcnand format 1'.\n");
+				return -1;
+			}
 		}
 
-		/* now write bad block list page */
-		write_badblock_list();
+		format_device();
 	}
 
 	if (PARTIAL_MATCH (argv[1], "s", "can") == 0) {
 		
 		cBad = 0;
 
-		for (page = 0; page < (chip->nbr_of_blocks * chip->pages_per_block); page += chip->pages_per_block) {
+		for (page = chip->pages_per_block; page < (chip->nbr_of_blocks * chip->pages_per_block);
+			page += chip->pages_per_block) {
 			/* reset nand device */
 			nand_reset ();
 			lpcnand_read_setup(page, chip->page_size_in_bytes); /* index to spare area */
 			{
 				if (NANDC_READ_DATA != 0xFF) {
-					printf ("Block %d bad\n", page/64);
+					printf ("Block %d bad\n", page/chip->pages_per_block);
 					++cBad;
 				}
 			}
@@ -758,17 +1081,83 @@
 			cBad, chip->nbr_of_blocks);
 	}
 
+	if (PARTIAL_MATCH (argv[1], "b", "blist") == 0) {
+		if (nand_modfiy_ok() == 0)
+			return 0;
+
+		cBad = 0;
+
+		for (page = chip->pages_per_block; page < (chip->nbr_of_blocks * chip->pages_per_block);
+			page += chip->pages_per_block) {
+			/* reset nand device */
+			if (nand_checkbb_array_bit(page) == 0) {
+				printf ("Block %d bad\n", page/chip->pages_per_block);
+				++cBad;
+			}
+			DBG(2, "Checking page:0x%08x\n", page);
+		}
+		printf ("%d of %d blocks are bad\n",
+			cBad, chip->nbr_of_blocks);
+	}
+
+	if (PARTIAL_MATCH (argv[1], "r", "estore") == 0) {
+		if (nand_modfiy_ok() == 0)
+			return 0;
+
+		printf("Restoring factory bad block markers\n");
+
+		/* Erase all blocks and mark blocks bad as specified by block 0 table */
+		for (page = chip->pages_per_block; page < (chip->nbr_of_blocks * chip->pages_per_block);
+			page += chip->pages_per_block) {
+			if (nand_checkbb_array_bit(page) == 0) {
+				/* Mark this block/page as bad */
+				mark_page_bad(page);
+			}
+			else {
+				erase_block(page);
+			}
+		}
+	}
+
+	if (PARTIAL_MATCH (argv[1], "p", "rotblk0") == 0) {
+		printf ("Block 0 modify protection is ");
+		if (argv[2][0] == '0') {
+			blk0enab = 1;
+			printf ("off\n");
+		}
+		else {
+			blk0enab = 0;
+			printf ("on\n");
+		}
+	}
+
+	/* This command is not for end-users. Don't use it! */
+	if (strcmp (argv[1], "diagmode") == 0) {
+		nand_modify = 1;
+
+		if ((argc >= 2) || (argv[2][0] != '1')) {
+			/* option 1 - clear bad blocks */
+			memset((void*)nand_bbl_array, 0xFF, sizeof(nand_bbl_array));
+		}
+	}
+
 	return 0;
 }
 
+/* Empty function needed for Apex NAND driver */
+void nandsys_init(void) {}
+
 static __command struct command_d c_nand = {
 	.command = "lpcnand",
 	.func = cmd_lpcnand,
 	COMMAND_DESCRIPTION ("lpcnand test function")
 	COMMAND_HELP (
 	"lpcnand [SUBCOMMAND [PARAMETER]]\n"
-	" format     - Write boot params and bad blocklist to block 0 for boot ROM to read\n"
-	" scan       - Scan for bad blocks\n"
+	" format     - Write boot params and bad blocklist to block 0\n"
+	" scan       - Scan for factory marked bad blocks\n"
+	" bblist     - Dump bad block list (from block 0)\n"
+	" restore    - Restore device to factory default state\n"
+	" protblk0   - Enable or disable block 0 modify protection\n"
 	"\n")
 };
 
diff -Naur apex-1.6.8-orig/src/mach-lpc313x/drv-nandc.c apex-1.6.8/src/mach-lpc313x/drv-nandc.c
--- apex-1.6.8-orig/src/mach-lpc313x/drv-nandc.c	2009-07-31 09:58:47.000000000 -0700
+++ apex-1.6.8/src/mach-lpc313x/drv-nandc.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,53 +0,0 @@
-/* drv-nandc.c
-
-   Used when standard Apex NAND driver model is used. lpcnand driver 
-   doesn't use these routines.
-
-*/
-
-#include <config.h>
-#include "hardware.h"
-#include "lpc313x_cgu.h"
-#include "lpc313x.h"
-
-/* Default NAND timing is slow */
-#define NAND_NANDTIMING1_DEFAULT 0x0000FFFF
-#define NAND_NANDTIMING2_DEFAULT 0xFFFFFFFF
-
-#define NAND_CMD_RESET 0xFF
-
-void nandsys_init(void)
-{
-#if 0
-	/* enable NAND clocks */
-	cgu_clk_en_dis(CGU_SB_NANDFLASH_S0_CLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_NANDFLASH_ECC_CLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_NANDFLASH_NAND_CLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_NANDFLASH_PCLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_NANDFLASH_AES_CLK_ID, 1);
-
-	/* reset NAND module through CGU */
-	cgu_soft_reset_module(NANDFLASH_NAND_RESET_N_SOFT);
-	cgu_soft_reset_module(NANDFLASH_ECC_RESET_N_SOFT);
-	cgu_soft_reset_module(NANDFLASH_AES_RESET_N_SOFT);
-
-	/* NAND muxing */
-	SYS_MUX_NAND_MCI = 0;
-
-	/* select bank 0 */
-	NANDC_SET_CE = NAND_SETCE_CV(0);
-	NANDC_CFG = NAND_CFG_DC | NAND_CFG_ECGC;
-
-	/* reset NAND */
-//	NANDC_IRQ_SET_CMD = NAND_CMD_RESET;
-//	while (!(NANDC_CHECK_STS & NAND_CHK_STS_RB1_EDGE));
-
-	/* NAND timing */
-//	NANDC_IRQ_TIMING1 = NAND_NANDTIMING1_DEFAULT;
-//	NANDC_IRQ_TIMING2 = NAND_NANDTIMING2_DEFAULT;
-
-	/* enable the controller and de-assert nFCE */
-	NANDC_CFG = NAND_CFG_DC;
-#endif
-}
-
diff -Naur apex-1.6.8-orig/src/mach-lpc313x/ea313x_v2_config apex-1.6.8/src/mach-lpc313x/ea313x_v2_config
--- apex-1.6.8-orig/src/mach-lpc313x/ea313x_v2_config	2009-07-31 09:58:47.000000000 -0700
+++ apex-1.6.8/src/mach-lpc313x/ea313x_v2_config	2009-08-07 11:41:57.000000000 -0700
@@ -1,7 +1,6 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: KERNELVERSION
-# Mon Jul  6 14:51:28 2009
 #
 CONFIG_ARM=y
 CONFIG_CPU_ARMV5=y
@@ -55,8 +54,11 @@
 # CONFIG_PLL_270 is not set
 CONFIG_DYNAMIC_CLOCKS=y
 # CONFIG_USB_BOOT is not set
-CONFIG_MICRON_MT29F2G08=y
+CONFIG_AUTOFORMAT_BLOCK0=y
+# CONFIG_MICRON_MT29F2G08 is not set
+CONFIG_MICRON_MT29F4G08=y
 # CONFIG_SAMSUNG_K9K8G is not set
+# CONFIG_TOSHIBA_TC58DVM82A is not set
 
 #
 # Commands
diff -Naur apex-1.6.8-orig/src/mach-lpc313x/Kconfig apex-1.6.8/src/mach-lpc313x/Kconfig
--- apex-1.6.8-orig/src/mach-lpc313x/Kconfig	2009-07-31 09:58:47.000000000 -0700
+++ apex-1.6.8/src/mach-lpc313x/Kconfig	2009-08-07 11:30:51.000000000 -0700
@@ -117,16 +117,40 @@
 	  (a.k.a. initrd).  This is the size of the compressed initrd
 	  image.
 
+config AUTOFORMAT_BLOCK0
+	bool "Autoformat NAND block 0"
+	default y
+	depends on DRIVER_NAND
+	help
+	  The LPC31xx devices use block 0 of FLASH to store device bad
+	  block and NAND boot information. If this option is enabled,
+	  this information will be built automatically if it doesn't
+	  exist. (A image of all the factory bad blocks are stored in
+	  here.) It is highly recommended that this option always be
+	  enabled. If it is not enabled, the device should be formatted
+	  manually with the lpcnand format command. If this is not
+	  done, the device will lose it's factory bad block information
+	  as soon as writes start occuring to the device. See the
+	  additional information about NAND FLASH included with the BSP
+	  for more information.
+
 choice
 	prompt "LPC NAND device"
+	depends on DRIVER_NAND
 	default MICRON_MT29F2G08
 
 config MICRON_MT29F2G08
 	bool "MICRON NAND MT29F2G08 device."
 
+config MICRON_MT29F4G08
+	bool "MICRON NAND MT29F4G08 device."
+
 config SAMSUNG_K9K8G
 	bool "SAMSUNG NAND K9K8G device."
 
+config TOSHIBA_TC58DVM82A
+	bool "TOSHIBA C58DVM82A device (small block)."
+
 endchoice
 
 endmenu
diff -Naur apex-1.6.8-orig/src/mach-lpc313x/lpc313x_cgu_default.c apex-1.6.8/src/mach-lpc313x/lpc313x_cgu_default.c
--- apex-1.6.8-orig/src/mach-lpc313x/lpc313x_cgu_default.c	2009-07-31 09:58:47.000000000 -0700
+++ apex-1.6.8/src/mach-lpc313x/lpc313x_cgu_default.c	2009-08-07 11:30:51.000000000 -0700
@@ -271,7 +271,7 @@
     {
       {{1, 1, 256}, CGU_DEF_DOMAIN7_DIV17},/*FracDiv17 */
       {{1, 1, 4}, CGU_DEF_DOMAIN7_DIV18},  /*FracDiv18 */
-      {{0, 0, 0}, CGU_DEF_DOMAIN7_DIV19},  /*FracDiv19 */
+      {{1, 1, 2}, CGU_DEF_DOMAIN7_DIV19},  /*FracDiv19 */
       {{1, 1, 4}, CGU_DEF_DOMAIN7_DIV20},  /*FracDiv20 */
       {{1, 1, 32}, CGU_DEF_DOMAIN7_DIV21}, /*FracDiv21 */
       {{1, 1, 2}, CGU_DEF_DOMAIN7_DIV22}   /*FracDiv22 */
diff -Naur apex-1.6.8-orig/src/mach-lpc313x/lpc313x_cgu.h apex-1.6.8/src/mach-lpc313x/lpc313x_cgu.h
--- apex-1.6.8-orig/src/mach-lpc313x/lpc313x_cgu.h	2009-07-31 09:58:47.000000000 -0700
+++ apex-1.6.8/src/mach-lpc313x/lpc313x_cgu.h	2009-08-07 11:30:51.000000000 -0700
@@ -469,15 +469,14 @@
 #define CGU_DEF_CLKS_32_63 ( _BIT(CGU_SB_IOCONF_PCLK_ID - 32) | _BIT(CGU_SB_CGU_PCLK_ID - 32) | \
                              _BIT(CGU_SB_SYSCREG_PCLK_ID - 32) | _BIT(CGU_SB_OTP_PCLK_ID - 32) | \
                              _BIT(CGU_SB_AHB2APB1_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_AHB2APB2_ASYNC_PCLK_ID - 32) | \
-                             _BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_EDGE_DET_PCLK_ID - 32) | \
-                             _BIT(CGU_SB_TIMER1_PCLK_ID - 32) | _BIT(CGU_SB_I2C1_PCLK_ID - 32))
+                             _BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_TIMER1_PCLK_ID - 32) | \
+                             _BIT(CGU_SB_I2C1_PCLK_ID - 32))
 #define CGU_DEF_CLKS_64_92 (_BIT(CGU_SB_SYSCLK_O_ID - 64))
 #else
 #define CGU_DEF_CLKS_32_63 ( _BIT(CGU_SB_IOCONF_PCLK_ID - 32) | _BIT(CGU_SB_CGU_PCLK_ID - 32) | \
                              _BIT(CGU_SB_SYSCREG_PCLK_ID - 32) | _BIT(CGU_SB_OTP_PCLK_ID - 32) | \
                              _BIT(CGU_SB_AHB2APB1_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_AHB2APB2_ASYNC_PCLK_ID - 32) | \
-                             _BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_EDGE_DET_PCLK_ID - 32) | \
-                             _BIT(CGU_SB_TIMER1_PCLK_ID - 32))
+                             _BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_TIMER1_PCLK_ID - 32))
 #define CGU_DEF_CLKS_64_92 (0)
 #endif
 
diff -Naur apex-1.6.8-orig/src/mach-lpc313x/lpc315x_ad.c apex-1.6.8/src/mach-lpc313x/lpc315x_ad.c
--- apex-1.6.8-orig/src/mach-lpc313x/lpc315x_ad.c	2009-07-31 09:58:47.000000000 -0700
+++ apex-1.6.8/src/mach-lpc313x/lpc315x_ad.c	2009-08-07 11:30:51.000000000 -0700
@@ -57,10 +57,10 @@
 	I2C_REG_TX(I2C1_PHYS) = ((reg_addr >> 8) & 0xFF);   // Send the high byte of the register address
 	I2C_REG_TX(I2C1_PHYS) = (reg_addr & 0xFF);          // Send the low byte of the register address
 	I2C_REG_TX(I2C1_PHYS) = AD_I2C_READ_ADR;                   // Send read address of the AD I2C slave with the (re)start condition
-	I2C_REG_TX(I2C1_PHYS) = 0;                                 // Dummy 1
-	I2C_REG_TX(I2C1_PHYS) = 0;                                 // Dummy 2
-	I2C_REG_TX(I2C1_PHYS) = 0;                                 // Dummy 3
-	I2C_REG_TX(I2C1_PHYS) = I2C_TXFF_STOP_CND;      // Dummy 4 with the stop condition
+	I2C_REG_TX(I2C1_PHYS) = 0xff;                                 // Dummy 1
+	I2C_REG_TX(I2C1_PHYS) = 0xff;                                 // Dummy 2
+	I2C_REG_TX(I2C1_PHYS) = 0xff;                                 // Dummy 3
+	I2C_REG_TX(I2C1_PHYS) = 0xff | I2C_TXFF_STOP_CND;      // Dummy 4 with the stop condition
 
 	while ((status & (I2C_STS_NAI | I2C_STS_TDI)) == 0)
 	{
diff -Naur apex-1.6.8-orig/src/mach-lpc313x/Makefile apex-1.6.8/src/mach-lpc313x/Makefile
--- apex-1.6.8-orig/src/mach-lpc313x/Makefile	2009-07-31 09:58:47.000000000 -0700
+++ apex-1.6.8/src/mach-lpc313x/Makefile	2009-08-07 11:30:51.000000000 -0700
@@ -9,10 +9,11 @@
 #   Please refer to the file debian/copyright for further details.
 #
 
-obj-y := initialize.o serial.o timer.o env.o lpc313x_cgu_default.o lpc313x_cgu_driver.o drv-crc32.o drv-lpcnand.o
+obj-y := initialize.o serial.o timer.o env.o lpc313x_cgu_default.o lpc313x_cgu_driver.o drv-crc32.o
 obj-y += cmd-reset.o
-obj-y += drv-mmc.o drv-nandc.o
-obj-$(CONFIG_HAS_ANALOG_DIE)		+= lpc315x_ad.o
+obj-y += drv-mmc.o
+obj-$(CONFIG_DRIVER_NAND)	+= drv-lpcnand.o
+obj-$(CONFIG_HAS_ANALOG_DIE)	+= lpc315x_ad.o
 obj-$(CONFIG_USB_BOOT)		+= usb/usbmsc.d
 
 obj-y += $(obj-xyy)
