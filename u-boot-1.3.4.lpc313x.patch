diff -crBN u-boot-1.3.4.clean/board/lpc3131ea/config.mk u-boot-1.3.4/board/lpc3131ea/config.mk
*** u-boot-1.3.4.clean/board/lpc3131ea/config.mk	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/board/lpc3131ea/config.mk	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1 ----
+ TEXT_BASE = 0x11029000
diff -crBN u-boot-1.3.4.clean/board/lpc3131ea/lpc3131.c u-boot-1.3.4/board/lpc3131ea/lpc3131.c
*** u-boot-1.3.4.clean/board/lpc3131ea/lpc3131.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/board/lpc3131ea/lpc3131.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,159 ----
+ /*
+  * (C) Copyright 2007-2008
+  * Stelian Pop <stelian.pop@leadtechdesign.com>
+  * Lead Tech Design <www.leadtechdesign.com>
+  *
+  * See file CREDITS for list of people who contributed to this
+  * project.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  */
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ 
+ DECLARE_GLOBAL_DATA_PTR;
+ 
+ extern ulong _start;
+ extern ulong _fiq;
+ 
+ /* ------------------------------------------------------------------------- */
+ /*
+  * Miscelaneous platform dependent initialisations
+  */
+ 
+ ulong   Int_Table[30];
+ #define ARM922T_MMU_CONTROL_V       0x00002000
+ 
+ 
+ 
+ 
+ void cp15_force_cache_coherence(ulong *start_adr,
+                                 ulong *end_adr)
+ {
+   register ulong * addr;
+ 
+   /*******************************************************************
+    * Cache lines are 32-bytes (8 words); clean and invalidate each
+    * line of D-cache and invalidate each line of I-cache within the
+    * address range. Make sure addresses are 32-bit aligned.
+    ******************************************************************/
+   for (addr = (ulong *)((ulong)start_adr & 0xFFFFFFE0);
+        addr < end_adr;
+        addr += 8)
+   {
+     /* p15 is MMU coprocessor, Cache OPS is c7, TLB OPS is c8 */
+ asm("MOV r0, %0" : : "r"(addr));
+     /* Clean and Invalidate D-Cache single entry using MVA format */
+     asm("MCR p15, 0, r0, c7, c14, 1");
+     /* Invalidate I-Cache single entry using MVA format */
+     asm("MCR p15, 0, r0, c7, c5, 1");
+   }
+   /*******************************************************************
+    * Invalidate the I-TLB within the the address range. The I-TLB has
+    * 256 word granularity. Make sure addresses are '256 word' aligned.
+    ******************************************************************/
+   for (addr = (ulong *)((ulong)start_adr & 0xFFFFFC00);
+        addr < end_adr;
+        addr += 256)
+   {
+ asm("MOV r0, %0" : : "r"(addr));
+     /* Invalidate I-TLB using MVA format */
+     asm("MCR p15, 0, r0, c8, c5, 1");
+     asm("NOP");
+     asm("NOP");
+   }
+ }
+ 
+ 
+ ulong cp15_get_mmu_control_reg(void)
+ {
+   register ulong mmu_reg;
+ 
+ asm("MRC p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
+ 
+   return (mmu_reg);
+ }
+ 
+ void int_initialize(void)
+ {
+ 
+ 	ulong * pDest, * pDestCopy, * pSrc;
+ 	long VecSize, Idx;
+ 
+ 	/* Set the vector base (we don't use direct vectoring, so this is 0) */
+ 	PUT32(INT_VECTOR_0,0);	/* IRQ Target */
+ 	PUT32(INT_VECTOR_1,0);	/* FIQ Target */
+ 
+ 	PUT32(INT_PRIORITYMASK_0,0); /* priority (unmasked) */
+ 	PUT32(INT_PRIORITYMASK_0,0); /* priority (unmasked) */
+ 
+ 	pDest = (ulong *)0x60000400; 
+ 
+ 	Int_Table[0] = 0;
+ 	for (Idx = 1; Idx < 30; Idx++)
+ 	{
+ 		pDest[Idx] = (1<<28)|(1<<27)|(1<<26)|(1<<25);
+ 		Int_Table[Idx] = 0;
+ 	}
+ 
+ 	pDest = (ulong *) 0x00000000;
+ 
+ 	/* If high bit is set, use high vector addresses instead */
+ 	if ((cp15_get_mmu_control_reg() & ARM922T_MMU_CONTROL_V) != 0)
+ 	{
+ 		pDest = (ulong *) 0xFFFF0000;
+ 	}
+ 	pDestCopy = pDest;
+ 
+ 	for (pSrc = (ulong *) & _start;
+ 		 pSrc <= (ulong *) &_fiq; 
+ 		 pSrc++)
+ 	{
+ 	  *pDest = *pSrc;
+ 	  pDest++;
+ 	}
+ 	 /* Write out cached vector table to memory */
+ 	 VecSize = ((long) & _fiq -
+ 				(long) & _start) / 4;
+ 	 cp15_force_cache_coherence(pDestCopy, (pDestCopy + VecSize));
+ 
+ }
+ 
+ 
+ int board_init(void)
+ {
+ 
+ 	/* Setup interrupt controller here */
+ 	int_initialize();
+ 
+ 	/* arch number of AT91SAM9260EK-Board */
+ 	gd->bd->bi_arch_number = MACH_TYPE_LPC313X;
+ 	/* adress of boot parameters */
+ 	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+ 
+ 	return 0;
+ }
+ 
+ /***********************************************************************/
+ int dram_init(void)
+ {
+   gd->bd->bi_dram[0].start = PHYS_SDRAM;
+   gd->bd->bi_dram[0].size  = PHYS_SDRAM_SIZE;
+   return 0;
+ }
+ 
diff -crBN u-boot-1.3.4.clean/board/lpc3131ea/Makefile u-boot-1.3.4/board/lpc3131ea/Makefile
*** u-boot-1.3.4.clean/board/lpc3131ea/Makefile	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/board/lpc3131ea/Makefile	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,54 ----
+ #
+ # (C) Copyright 2003-2008
+ # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ #
+ # (C) Copyright 2008
+ # Stelian Pop <stelian.pop@leadtechdesign.com>
+ # Lead Tech Design <www.leadtechdesign.com>
+ #
+ # See file CREDITS for list of people who contributed to this
+ # project.
+ #
+ # This program is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU General Public License as
+ # published by the Free Software Foundation; either version 2 of
+ # the License, or (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ # GNU General Public License for more details.
+ #
+ # You should have received a copy of the GNU General Public License
+ # along with this program; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ # MA 02111-1307 USA
+ #
+ 
+ include $(TOPDIR)/config.mk
+ 
+ LIB	= $(obj)lib$(BOARD).a
+ 
+ COBJS-y	+= lpc3131.o
+ 
+ SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+ OBJS	:= $(addprefix $(obj),$(COBJS-y))
+ SOBJS	:= $(addprefix $(obj),$(SOBJS))
+ 
+ $(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+ 	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+ 
+ clean:
+ 	rm -f $(SOBJS) $(OBJS)
+ 
+ distclean:	clean
+ 	rm -f $(LIB) core *.bak $(obj).depend
+ 
+ #########################################################################
+ 
+ # defines $(obj).depend target
+ include $(SRCTREE)/rules.mk
+ 
+ sinclude $(obj).depend
+ 
+ #########################################################################
diff -crBN u-boot-1.3.4.clean/common/cmd_nvedit.c u-boot-1.3.4/common/cmd_nvedit.c
*** u-boot-1.3.4.clean/common/cmd_nvedit.c	2008-08-12 16:08:38.000000000 +0200
--- u-boot-1.3.4/common/cmd_nvedit.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 59,66 ****
      !defined(CFG_ENV_IS_IN_NAND)	&& \
      !defined(CFG_ENV_IS_IN_ONENAND)	&& \
      !defined(CFG_ENV_IS_IN_SPI_FLASH)	&& \
!     !defined(CFG_ENV_IS_NOWHERE)
! # error Define one of CFG_ENV_IS_IN_{NVRAM|EEPROM|FLASH|DATAFLASH|ONENAND|SPI_FLASH|NOWHERE}
  #endif
  
  #define XMK_STR(x)	#x
--- 59,67 ----
      !defined(CFG_ENV_IS_IN_NAND)	&& \
      !defined(CFG_ENV_IS_IN_ONENAND)	&& \
      !defined(CFG_ENV_IS_IN_SPI_FLASH)	&& \
!     !defined(CFG_ENV_IS_NOWHERE)    && \
!     !defined(CFG_ENV_IS_IN_SPINORFLASH)
! # error Define one of CFG_ENV_IS_IN_{NVRAM|EEPROM|FLASH|DATAFLASH|ONENAND|SPI_FLASH|NOWHERE|SPINORFLASH}
  #endif
  
  #define XMK_STR(x)	#x
***************
*** 543,549 ****
  #if ((defined(CFG_ENV_IS_IN_NVRAM) || defined(CFG_ENV_IS_IN_EEPROM) \
      || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_FLASH)) \
      || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_NAND)) \
!     || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_ONENAND))) \
      && !defined(CFG_ENV_IS_NOWHERE))
  int do_saveenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
  {
--- 544,551 ----
  #if ((defined(CFG_ENV_IS_IN_NVRAM) || defined(CFG_ENV_IS_IN_EEPROM) \
      || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_FLASH)) \
      || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_NAND)) \
!     || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_ONENAND)) \
!     || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_SPINOR))) \
      && !defined(CFG_ENV_IS_NOWHERE))
  int do_saveenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
  {
***************
*** 599,605 ****
  #if ((defined(CFG_ENV_IS_IN_NVRAM) || defined(CFG_ENV_IS_IN_EEPROM) \
      || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_FLASH)) \
      || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_NAND)) \
!     || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_ONENAND))) \
      && !defined(CFG_ENV_IS_NOWHERE))
  U_BOOT_CMD(
  	saveenv, 1, 0,	do_saveenv,
--- 601,608 ----
  #if ((defined(CFG_ENV_IS_IN_NVRAM) || defined(CFG_ENV_IS_IN_EEPROM) \
      || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_FLASH)) \
      || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_NAND)) \
!     || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_ONENAND)) \
!     || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_SPINOR))) \
      && !defined(CFG_ENV_IS_NOWHERE))
  U_BOOT_CMD(
  	saveenv, 1, 0,	do_saveenv,
diff -crBN u-boot-1.3.4.clean/common/cmd_spinor.c u-boot-1.3.4/common/cmd_spinor.c
*** u-boot-1.3.4.clean/common/cmd_spinor.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/common/cmd_spinor.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,69 ----
+ #include <common.h>
+ 
+ #ifdef CONFIG_CMD_SPINOR 
+ 
+ #include <command.h>
+ #include "../cpu/arm926ejs/lpc313x/lpc313x_spi_driver.h"
+ 
+ 
+ int do_spinorwrite (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+ {
+ 	ulong i,start,length,wr,offset;
+ 	unsigned char * pSource;
+ 	char *ep;
+ 
+ 	if (argc < 3) {
+ 		printf ("Usage:\n%s\n", cmdtp->usage);
+ 		return(1);
+ 	}
+ 	offset	 = simple_strtoul (argv[1], &ep, 16);
+ 	start    = simple_strtoul (argv[2], &ep, 16);
+ 	length   = simple_strtoul (argv[3], &ep, 16);
+ 
+ 	printf("Write %X Bytes From %X to %X\n",length,start,offset);
+ 
+ 	if(spinor_write((unsigned char *)start, offset, length) == _ERROR)
+ 	{
+ 		printf("Failed\n");
+ 		return 1;
+ 	}
+ 	printf("Done\n");
+ 	return 0;
+ }
+ 
+ int do_spinorread (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+ {
+ 	ulong i,start,length,offset;
+ 	unsigned char * pDest;
+ 	char *ep;
+ 
+ 	if (argc < 3) {
+ 		printf ("Usage:\n%s\n", cmdtp->usage);
+ 		return(1);
+ 	}
+ 	offset	 = simple_strtoul (argv[1], &ep, 16);
+ 	start    = simple_strtoul (argv[2], &ep, 16);
+ 	length   = simple_strtoul (argv[3], &ep, 16);
+ 
+ 	printf("Read %X Bytes From %X to %X\n",length,offset,start);
+ 
+ 	pDest = (unsigned char *)start;
+ 
+ 	spinor_read(pDest, offset, length);
+ 
+ 	return 0;
+ }
+ 
+ U_BOOT_CMD(
+ 	spinorwrite,	4,	0,	do_spinorwrite,
+ 	"spinorwrite - Copy RAM to SPI NOR\n",
+ 	"spinorwrite x y z Where x is the SPINOR address, y is the source address, z is the number of bytes"
+ );
+ 
+ U_BOOT_CMD(
+ 	spinorread,	4,	0,	do_spinorread,
+ 	"spinorread - Copy SPI NOR to RAM\n",
+ 	"spinorread x y z Where x is the SPINOR address, y is the dest address, z is the number of bytes"
+ );
+ 
+ #endif
diff -crBN u-boot-1.3.4.clean/common/cmd_ttest.c u-boot-1.3.4/common/cmd_ttest.c
*** u-boot-1.3.4.clean/common/cmd_ttest.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/common/cmd_ttest.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,42 ----
+ #include <common.h>
+ #include <part.h>
+ #include <config.h>
+ #include <command.h>
+ #include <image.h>
+ #include <linux/ctype.h>
+ #include <asm/byteorder.h>
+ #include "../cpu/arm926ejs/lpc313x/lpc313x_ioconf_driver.h"
+ 
+ #if CONFIG_CMD_TTEST
+ 
+ int do_ttest (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+ {
+ 	ulong period;
+ 	char *ep;
+ 	if (argc < 1) {
+ 		printf ("Usage:\n%s\n", cmdtp->usage);
+ 		return(1);
+ 	}
+ 	period   = simple_strtoul (argv[1], &ep, 10);
+ 
+ 	printf("Timer Test: period %d uS\n",period);
+ 
+ 	while(1)
+ 	{
+ 		gpio_set_outpin_high(IOCONF_GPIO, 2);
+ 		udelay(period/2);
+ 		gpio_set_outpin_low(IOCONF_GPIO, 2);
+ 		udelay(period/2);
+ 	}
+ 
+ 	
+ 	return(0);
+ }
+ 
+ U_BOOT_CMD(
+ 	ttest,	2,	0,	do_ttest,
+ 	"ttest  - timer test, blinks LED at specified rate\n",
+ 	"ttest yyy where yyy is the period in uS"
+ );
+ #endif
+ 
diff -crBN u-boot-1.3.4.clean/common/env_common.c u-boot-1.3.4/common/env_common.c
*** u-boot-1.3.4.clean/common/env_common.c	2008-08-12 16:08:38.000000000 +0200
--- u-boot-1.3.4/common/env_common.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 134,140 ****
  };
  
  #if defined(CFG_ENV_IS_IN_NAND)		/* Environment is in Nand Flash */ \
! 	|| defined(CFG_ENV_IS_IN_SPI_FLASH)
  int default_environment_size = sizeof(default_environment);
  #endif
  
--- 134,141 ----
  };
  
  #if defined(CFG_ENV_IS_IN_NAND)		/* Environment is in Nand Flash */ \
! 	|| defined(CFG_ENV_IS_IN_SPI_FLASH)\
! 	|| defined(CFG_ENV_IS_IN_SPINORFLASH)
  int default_environment_size = sizeof(default_environment);
  #endif
  
diff -crBN u-boot-1.3.4.clean/common/env_spinorflash.c u-boot-1.3.4/common/env_spinorflash.c
*** u-boot-1.3.4.clean/common/env_spinorflash.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/common/env_spinorflash.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,115 ----
+ /* LowLevel function for spinorflash environment support
+  * Author : Gilles Gastaldi (Atmel)
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  *
+  */
+ #include <common.h>
+ 
+ #if defined(CFG_ENV_IS_IN_SPINORFLASH) /* Environment is in SPI NOR Flash */
+ 
+ #include <command.h>
+ #include <environment.h>
+ #include <linux/stddef.h>
+ #include "../cpu/arm926ejs/lpc313x/lpc313x_spi_driver.h"
+ 
+ 
+ STATUS spinor_write(unsigned char *src, ulong offset, ulong bytecount);
+ STATUS spinor_read(unsigned char *dst, ulong offset, ulong bytecount);
+ 
+ DECLARE_GLOBAL_DATA_PTR;
+ 
+ env_t *env_ptr = NULL;
+ 
+ char * env_name_spec = "spinorflash";
+ 
+ extern uchar default_environment[];
+ extern int default_environment_size;
+ 
+ extern int read_spinorflash (unsigned long addr, unsigned long size, char *result);
+ extern int write_spinorflash (unsigned long addr_dest, unsigned long addr_src, unsigned long size);
+ 
+ /************************************************************************
+  */
+ uchar env_get_char_spec (int index)
+ {
+ 	return *((uchar *)(gd->env_addr + index));
+ }
+ 
+ /************************************************************************
+  */
+ void env_relocate_spec (void)
+ {
+ 	ulong new;
+ 	long spi_id = spi_open((void *)SPI_BASE, 0);
+ 	if(spi_id != 0)
+ 	{
+ 		if (spinor_init(spi_id) == _ERROR)
+ 		{
+ 			printf("Converted SPI NOR flash from 528byte page size mode\n");  
+ 			printf("to 512 byte page mode.\n");
+ 			printf("So please power cycle the board and try again.\n");
+ 			return;
+ 		}	
+ 	}
+ 	else
+ 	{
+ 		memset(env_ptr, 0, sizeof(env_t));
+ 		memcpy(env_ptr->data, default_environment, default_environment_size);
+ 		env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
+ 		gd->env_valid = 1;
+ 		puts ("*** Warning - bad SPI NOR, using default environment\n\n");
+ 		return;
+ 	}
+ 
+ 		/* prepare for spinorflash read/write */
+ 
+ 	spinor_read((uchar *)env_ptr, CFG_ENV_ADDR, CFG_ENV_SIZE);
+ 	new = crc32 (0, (const unsigned char *)env_ptr->data, ENV_SIZE);
+ 
+ 	if (env_ptr->crc != new) {
+ 		memset(env_ptr, 0, sizeof(env_t));
+ 		memcpy(env_ptr->data, default_environment, default_environment_size);
+ 		env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
+ 		puts ("*** Warning - bad CRC, using default environment\n\n");
+ 	}
+ }
+ 
+ /************************************************************************
+  */
+ int saveenv(void)
+ {
+ 	ulong new;
+ 	new = crc32 (0, (const unsigned char *)env_ptr->data, ENV_SIZE);
+ 	if (env_ptr->crc != new) {
+ 		puts ("*** Warning - bad CRC, fixing...\n");
+ 		env_ptr->crc = new;
+ 		}
+ 
+ 	return spinor_write((unsigned char *)env_ptr, CFG_ENV_ADDR, CFG_ENV_SIZE);
+ }
+ 
+ /************************************************************************
+  */
+ int env_init(void)
+ {
+ 	gd->env_addr  = (ulong)&default_environment[0];
+ 	gd->env_valid = 1;
+ 
+ 	return (0);
+ }
+ 
+ #endif /* CFG_ENV_IS_IN_DATAFLASH */
diff -crBN u-boot-1.3.4.clean/common/Makefile u-boot-1.3.4/common/Makefile
*** u-boot-1.3.4.clean/common/Makefile	2008-08-12 16:08:38.000000000 +0200
--- u-boot-1.3.4/common/Makefile	2009-05-15 19:12:59.000000000 +0200
***************
*** 116,121 ****
--- 116,122 ----
  COBJS-y += env_sf.o
  COBJS-y += env_nvram.o
  COBJS-y += env_nowhere.o
+ COBJS-y += env_spinorflash.o
  COBJS-y += exports.o
  COBJS-y += flash.o
  COBJS-y += fpga.o
***************
*** 141,146 ****
--- 142,149 ----
  COBJS-y += crc16.o
  COBJS-y += xyzModem.o
  COBJS-y += cmd_mac.o
+ COBJS-$(CONFIG_CMD_TTEST) += cmd_ttest.o
+ COBJS-$(CONFIG_CMD_SPINOR) += cmd_spinor.o
  COBJS-$(CONFIG_CMD_MFSL) += cmd_mfsl.o
  COBJS-$(CONFIG_MP) += cmd_mp.o
  COBJS-$(CONFIG_CMD_SF) += cmd_sf.o
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/config.mk u-boot-1.3.4/cpu/arm926ejs/config.mk
*** u-boot-1.3.4.clean/cpu/arm926ejs/config.mk	2008-08-12 16:08:38.000000000 +0200
--- u-boot-1.3.4/cpu/arm926ejs/config.mk	2009-05-15 19:15:24.000000000 +0200
***************
*** 30,34 ****
  # Supply options according to compiler version
  #
  # =========================================================================
! PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32,-mabi=apcs-gnu)
  PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
--- 30,34 ----
  # Supply options according to compiler version
  #
  # =========================================================================
! PLATFORM_CPPFLAGS +=$(call cc-option)
  PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/config.mk u-boot-1.3.4/cpu/arm926ejs/lpc313x/config.mk
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/config.mk	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/config.mk	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,3 ----
+ PLATFORM_CPPFLAGS += -march=armv5te
+ PLATFORM_CPPFLAGS += $(call cc-option,-mtune=arm926ejs,)
+ LDSCRIPT := $(SRCTREE)/cpu/arm926ejs/lpc313x/u-boot.lds
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/ea3131_spinor.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/ea3131_spinor.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/ea3131_spinor.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/ea3131_spinor.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,520 ----
+ /***********************************************************************
+  * $Id:: ea3131_spinor.c 1633 2009-02-06 02:21:00Z pdurgesh            $
+  *
+  * Project: VAL3150 board functions
+  *
+  * Description:
+  *     This file contains driver support for various VAL3150 board
+  *     functions.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  **********************************************************************/
+ 
+ #include "lpc313x_spi_driver.h"
+ #include "lpc313x_timer_driver.h"
+ #include "lpc313x_ioconf_driver.h"
+ 
+ #define MANFID_ATMEL    0x1F
+ 
+ 
+ #define CMD_RDID        0x9F        /* read device ID */
+ #define CMD_RDSR        0xD7        /* read status register */
+ #define CMD_FAST_READ   0x0B        /* read data (extra command setup time allows higher SPI clock) */
+ 
+ #define CMD_SE          0x7C        /* sector erase */
+ #define CMD_BE          0x50        /* block erase */
+ #define CMD_PE          0x81        /* page erase */
+ 
+ #define CMD_DP          0xB9        /* deep power down */
+ #define CMD_RES         0xAB        /* release from deep power down */
+ 
+ #define DUMMY_BYTE		  0xFF
+ 
+ /* status register defines */
+ #define STATUS_RDY      (1 << 7)
+ #define STATUS_COMP     (1 << 6)
+ #define STATUS_PROTECT  (1 << 1)
+ #define STATUS_P512     (1 << 0)
+ 
+ 
+ #define PAGE_528       (528)
+ #define PAGE_512       (512)
+ #define BLOCK_SIZE(pg_sz)      (16 * (pg_sz))
+ #define SECTOR_SIZE(pg_sz)     (32 * (pg_sz))
+ 
+ #define SPI_NOR_SLAVE_ID	0
+ 
+ 
+ /****************************************************************************
+ ****************************************************************************/
+ 
+ typedef struct
+ {
+   long spi_id;
+   ulong spi_slave_id;
+   ulong page_size;
+   unsigned char  manufacturer_id;
+   unsigned char  device_type;
+   unsigned char  device_capacity;
+   unsigned char _pad;
+ 
+ } SPINOR_INFO_T;
+ 
+ static SPINOR_INFO_T g_spinor;
+ 
+ 
+ /***********************************************************************
+  * Private functions
+  **********************************************************************/
+ void spinor_cs_low(void)
+ {
+   gpio_set_outpin_low(IOCONF_SPI, 4);
+ }
+ 
+ void spinor_cs_high(void)
+ {
+   gpio_set_outpin_high(IOCONF_SPI, 4);
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: spinor_xfer
+  *
+  * Purpose: Transfer data to/from the serial EEPROM
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     out   : Output data
+  *     in    : Input data
+  *     bytes : Number of bytes to send/receive
+  *
+  * Outputs: None
+  *
+  * Returns: TRUE if the byte was transferred
+  *
+  * Notes: Do not use this function to transfer more than 8 bytes!
+  *
+  **********************************************************************/
+ static void spinor_xfer(unsigned char *out,
+                         unsigned char *in,
+                         int bytes)
+ {
+   long rbytes = 0;
+   volatile ulong status;
+ 
+   /* flush the FFOS */
+   spi_ioctl(g_spinor.spi_id, SPI_FLUSH_RX_FIFO, 0);
+   /* write the commands */
+   spi_write(g_spinor.spi_id, out, bytes);
+   /* wait till SPI is not busy */
+   do
+   {
+     status = spi_ioctl(g_spinor.spi_id, SPI_GET_STATUS, SPI_FIFO_ST);
+   }
+   while ((status & SPI_ST_TX_EMPTY) != SPI_ST_TX_EMPTY);
+ 
+   while (rbytes < bytes)
+   {
+     rbytes += spi_read(g_spinor.spi_id, &in [rbytes], 1);
+   }
+ }
+ 
+ 
+ static void spinor_read_device_id(unsigned char *device_id)
+ {
+   unsigned char datao [4];
+ 
+   datao[0] = CMD_RDID;
+   datao[1] = DUMMY_BYTE;
+   datao[2] = DUMMY_BYTE;
+   datao[3] = DUMMY_BYTE;
+ 
+   /* 3 bytes: manufacturer id, device type, device capacity */
+   spinor_cs_low();
+   spinor_xfer(datao, device_id, 4);
+   spinor_cs_high();
+ }
+ 
+ static void spinor_write_cfg_reg(void)
+ {
+   unsigned char datai [4], datao [4];
+ 
+   /* 4 bytes magic sequence to program the device to 512 page device */
+   datao[0] = 0x3D;
+   datao[1] = 0x2A;
+   datao[2] = 0x80;
+   datao[3] = 0xA6;
+ 
+   spinor_cs_low();
+   spinor_xfer(datao, datai, 4);
+   spinor_cs_high();
+ }
+ static void spinor_simple_command(unsigned char command_byte)
+ {
+   unsigned char dummy;
+   /* should we wait for command to txfer */
+   spinor_cs_low();
+   spinor_xfer(&command_byte, &dummy, 1);
+   spinor_cs_high();
+ }
+ 
+ static void spinor_enter_deep_power_down(void)
+ {
+   spinor_simple_command(CMD_DP);
+ }
+ 
+ static void spinor_exit_deep_power_down(void)
+ {
+   spinor_simple_command(CMD_RES);
+   /* max tEDPD in Atmel AT45DB161D-SU datasheet is given as 35 usec */
+   timer_wait_us(NULL, 50);
+ }
+ 
+ static void spinor_read_status_register(ulong *status)
+ {
+   unsigned char datai [2], datao [2];
+ 
+   datao[0] = CMD_RDSR;
+   datao[1] = DUMMY_BYTE;
+   spinor_cs_low();
+   spinor_xfer(datao, datai, 2);
+   spinor_cs_high();
+   *status = datai[1];
+ }
+ 
+ static void spinor_poll_is_busy(void)
+ {
+   ulong status;
+ 
+   do
+   {
+     timer_wait_us(NULL, 10);
+     spinor_read_status_register(&status);
+   }
+   while ((status & STATUS_RDY) == 0);
+ }
+ 
+ static void spinor_sector_erase(ulong offset)
+ {
+   unsigned char datai [4], datao [4];
+ 
+   /* Hopefully sectors are not protected */
+ 
+   datao[0] = CMD_SE;
+   datao[1] = (offset >> 16) & 0xFF; /* 24bit address upper byte */
+   datao[2] = (offset >>  8) & 0xFF; /* 24bit address middle byte */
+   datao[3] = (offset >>  0) & 0xFF; /* 24bit address least significant byte */
+ 
+   spinor_cs_low();
+   spinor_xfer(datao, datai, 4);
+   spinor_cs_high();
+ 
+   spinor_poll_is_busy();
+ }
+ 
+ static void spinor_page_program(ulong offset, unsigned char *src, ulong bytecount)
+ {
+   unsigned char datai [64], datao [4];
+   ulong count, status;
+ 
+   /* assuming sectors are not protected. */
+ 
+   datao[0] = 0x82;
+   datao[1] = (offset >> 16) & 0xFF; /* 24bit address upper byte */
+   datao[2] = (offset >>  8) & 0xFF; /* 24bit address middle byte */
+   datao[3] = (offset >>  0) & 0xFF; /* 24bit address least significant byte */
+   spinor_cs_low();
+ 
+   spinor_xfer(datao, datai, 4);
+ 
+   while (bytecount > 0)
+   {
+     count = spi_write(g_spinor.spi_id, src, bytecount);
+     bytecount -= count;
+     src += count;
+   }
+   /* wait for Tx FIFO to empty */
+   do
+   {
+     status = spi_ioctl(g_spinor.spi_id, SPI_GET_STATUS, SPI_FIFO_ST);
+   }
+   while ((status & SPI_ST_TX_EMPTY) != SPI_ST_TX_EMPTY);
+ 
+ 
+   /* flush RX FIFO */
+   spi_ioctl(g_spinor.spi_id, SPI_FLUSH_RX_FIFO, 0);
+   spinor_cs_high();
+ 
+   spinor_poll_is_busy();
+ }
+ 
+ 
+ 
+ /***********************************************************************
+  * Public functions
+  **********************************************************************/
+ 
+ ulong spinor_get_id(void)
+ {
+   return (g_spinor.manufacturer_id << 8|g_spinor.device_capacity) ;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: val3150_board_init
+  *
+  * Purpose: Initializes basic board functions
+  *
+  * Processing:
+  *     Does nothing
+  *
+  * Parameters: None
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ STATUS spinor_init(long spi_id)
+ {
+   unsigned char device_id[4];
+   SPI_SLAVE_CONFIG_T cfg;
+   ulong temp;
+ 
+   /* de-select the device by pulling the CS high. */
+   gpio_set_outpin_high(IOCONF_SPI, 4);
+ 
+   g_spinor.spi_id = spi_id;
+   /* on VAL3150 SPI NOR is connected to chip select 0 */
+   g_spinor.spi_slave_id = SPI_NOR_SLAVE_ID;
+ 
+   /* configure the slave setting with NOR flash timings */
+   cfg.sid = (SPI_SLAVE_ID_T)SPI_NOR_SLAVE_ID;
+   cfg.databits = 8;
+   cfg.words = SPI_FIFO_DEPTH;
+   cfg.mode = SPI_MODE0;
+   cfg.cs_high = 0;
+   cfg.pp_delay = 0;
+   cfg.inter_delay = 0;
+   cfg.clk = 1000000;
+   spi_ioctl(g_spinor.spi_id, SPI_SLAVE_CONFIG, (long)&cfg);
+ 
+   spi_ioctl(g_spinor.spi_id, SPI_SET_ACTIVE_SLAVE, SPI_NOR_SLAVE_ID);
+   /* make sure SPI module is enabled */
+   spi_ioctl(g_spinor.spi_id, SPI_ENABLE, 1);
+ 
+   spinor_exit_deep_power_down();
+   spinor_read_device_id(device_id);
+ 
+   g_spinor.manufacturer_id = device_id[1];
+   g_spinor.device_capacity = device_id[2];
+   g_spinor.device_type = device_id[3];
+ 
+   /* return if it is not ATMEL device */
+   if (g_spinor.manufacturer_id !=  MANFID_ATMEL)
+     return _ERROR;
+ 
+ 
+   do
+   {
+     spinor_read_status_register(&temp);
+   }
+   while ((temp & STATUS_RDY) == 0);
+ 
+ 
+   /* Check if the device is configured as 512 page device.
+      If not program it to be 512 page device.
+   */
+   if ((temp & STATUS_P512) == 0)
+   {
+     g_spinor.page_size = PAGE_528;
+     /* program device to 512 mode. needs a power cycle after this.*/
+     spinor_write_cfg_reg();
+     return _ERROR;
+   }
+   else
+   {
+     g_spinor.page_size = PAGE_512;
+   }
+ 
+   spinor_enter_deep_power_down();
+ 
+   return g_spinor.page_size;
+ }
+ 
+ 
+ STATUS spinor_read(unsigned char *dst, ulong offset, ulong bytecount)
+ {
+   unsigned char datai [5], datao [5];
+   long count, rbytes;
+   volatile ulong status = 0;
+ 
+   if (g_spinor.spi_id == 0)
+     return _ERROR;
+ 
+   spi_ioctl(g_spinor.spi_id, SPI_SET_ACTIVE_SLAVE, SPI_NOR_SLAVE_ID);
+   spinor_exit_deep_power_down();
+ 
+   datao[0] = (CMD_FAST_READ);          /* FAST_READ is safe at all supported SPI speeds... */
+   datao[1] = ((offset >> 16) & 0xFF);  /* 24bit address upper byte */
+   datao[2] = ((offset >>  8) & 0xFF);  /* 24bit address middle byte */
+   datao[3] = ((offset >>  0) & 0xFF);  /* 24bit address least significant byte */
+   datao[4] = (0);                      /* dummy byte */
+ 
+   spinor_cs_low();
+   gpio_set_outpin_low(IOCONF_SPI, 4);
+   spinor_xfer(datao, datai, 5);
+ 
+   /* wait until both FIFOs are empty */
+   status = 0;
+   while ((status & (SPI_ST_RX_EMPTY | SPI_ST_TX_EMPTY)) !=
+          (SPI_ST_RX_EMPTY | SPI_ST_TX_EMPTY))
+   {
+     status = spi_ioctl(g_spinor.spi_id, SPI_GET_STATUS, SPI_FIFO_ST);
+   }
+ 
+   while (bytecount > 0)
+   {
+     count = spi_write(g_spinor.spi_id, dst, bytecount);
+     status = 0;
+     while ((status & SPI_ST_TX_EMPTY) != SPI_ST_TX_EMPTY)
+     {
+       status = spi_ioctl(g_spinor.spi_id, SPI_GET_STATUS, SPI_FIFO_ST);
+     }
+ 
+     rbytes = 0;
+     while (count > 0)
+     {
+       rbytes = spi_read(g_spinor.spi_id, dst, count);
+       count -= rbytes;
+       dst += rbytes;
+       bytecount -= rbytes;
+     }
+   }
+   spinor_cs_high();
+ 
+   gpio_set_outpin_high(IOCONF_SPI, 4);
+ 
+   spinor_enter_deep_power_down();
+ 
+   return _NO_ERROR;
+ }
+ 
+ 
+ /*
+     Very crude write support...
+     Assumes all sectors are 64k bytes, does not verify address is within
+     bounds of device, etc, etc.
+ 
+     Currently, write support is meant for simple testing only... !!
+ */
+ STATUS spinor_write(unsigned char *src, ulong offset, ulong bytecount)
+ {
+   ulong offset_end;
+ 
+ 
+   if ((g_spinor.spi_id == 0) ||
+       ((offset % g_spinor.page_size) != 0)) /* error if address is not sector aligned */
+   {
+     return _ERROR;
+   }
+ 
+   spi_ioctl(g_spinor.spi_id, SPI_SET_ACTIVE_SLAVE, SPI_NOR_SLAVE_ID);
+   spinor_exit_deep_power_down();
+ 
+   offset_end = (offset + bytecount);              /* end offset of entire write operation */
+ 
+   while (offset < offset_end)
+   {
+     /* No need to erase since we use "Main Memory Page Program Through Buffer" in this driver.
+     */
+     spinor_page_program(offset, src, g_spinor.page_size);
+     src += g_spinor.page_size;
+     offset += g_spinor.page_size;
+   }
+ 
+   spinor_enter_deep_power_down();
+ 
+   return _NO_ERROR;
+ }
+ 
+ STATUS spinor_erase_from_beginning(ulong bytecount)
+ {
+   ulong offset = 0;
+ 
+   if (g_spinor.spi_id == 0)
+     return _ERROR;
+ 
+   spi_ioctl(g_spinor.spi_id, SPI_SET_ACTIVE_SLAVE, SPI_NOR_SLAVE_ID);
+   spinor_exit_deep_power_down();
+ 
+   while (offset < bytecount)
+   {
+     spinor_sector_erase(offset);
+     /* check if it is first sector */
+     if (offset < SECTOR_SIZE(g_spinor.page_size))
+     {
+       offset += SECTOR_SIZE(g_spinor.page_size) / 2;
+     }
+     else
+     {
+       offset += SECTOR_SIZE(g_spinor.page_size);
+     }
+   }
+ 
+   spinor_enter_deep_power_down();
+ 
+   return _NO_ERROR;
+ }
+ 
+ STATUS spinor_erase_sector(ulong sectorIndex)
+ {
+   ulong offset;
+ 
+   if (g_spinor.spi_id == 0)
+     return _ERROR;
+ 
+   spi_ioctl(g_spinor.spi_id, SPI_SET_ACTIVE_SLAVE, SPI_NOR_SLAVE_ID);
+   spinor_exit_deep_power_down();
+ 
+   offset = sectorIndex * SECTOR_SIZE(g_spinor.page_size);
+ 
+   spinor_sector_erase(offset);
+ 
+   spinor_enter_deep_power_down();
+ 
+   return _NO_ERROR;
+ }
+ 
+ long spinor_write_page(unsigned char *src, ulong offset)
+ {
+   if ((g_spinor.spi_id == 0) ||
+       ((offset % g_spinor.page_size) != 0)) /* error if address is not sector aligned */
+   {
+     return 0;
+   }
+ 
+   spi_ioctl(g_spinor.spi_id, SPI_SET_ACTIVE_SLAVE, SPI_NOR_SLAVE_ID);
+   spinor_exit_deep_power_down();
+ 
+   spinor_page_program(offset, src, g_spinor.page_size);
+ 
+   spinor_enter_deep_power_down();
+ 
+   return g_spinor.page_size;
+ }
+ 
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lowlevelinit.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/lowlevelinit.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lowlevelinit.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lowlevelinit.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,233 ----
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ #include "lpc313x_cgu_driver.h"
+ #include "lpc313x_sysreg.h"
+ #include "lpc313x_ioconf_driver.h"
+ #include "lpc313x_mpmc.h"
+ #include "lpc313x_timer_driver.h"
+ 
+ DECLARE_GLOBAL_DATA_PTR;
+ 
+ int timer_init(void);
+ 
+ /*-----------------------------------------------------------*/
+ void MiscSetup(void)
+ {
+   /* Map first 4KB of ARM space to ISRAM area. ie 0x0 - 0x1000 = 0x11028000 - 0x11029000 */
+   SYS_REGS->arm926_shadow_pointer = ISRAM_ESRAM0_BASE;
+ }
+ /*-----------------------------------------------------------*/
+ void ClockSetup( void )
+ {
+ 	ulong clkin_freq[CGU_FIN_SELECT_MAX]; 
+ 	CGU_HPLL_SETUP_T pll = 
+ 	  {
+ 		  CGU_FIN_SELECT_FFAST, //fin_select;
+ 		  770,		  //ndec;
+ 		  8191, 	  //mdec;
+ 		  98,		  //pdec;
+ 		  0,		  //selr;
+ 		  16,		  //seli;
+ 		  8,		  //selp;
+ 		  0,		  //mode;
+ 		  180000000   //freq; 
+ 	  };
+ 	
+ 	CGU_HPLL_SETUP_T pll0 = {
+ 		  CGU_FIN_SELECT_FFAST, //fin_select;
+ 		  131,			  //ndec;
+ 		  29784,	  //mdec;
+ 		  7,		  //pdec;
+ 		  0,		  //selr;
+ 		  8,		  //seli;
+ 		  31,		  //selp;
+ 		  0,		  //mode;
+ 		  22579200   //freq; 
+ 	  };
+ 	
+ 	/* init clock frequencies */
+ 	clkin_freq[0] = XTAL_IN; /* CGU_FIN_SELECT_FFAST */
+ 	clkin_freq[1] = 0; /* CGU_FIN_SELECT_XT_DAI_BCK0 */
+ 	clkin_freq[2] = 0; /* CGU_FIN_SELECT_XT_DAI_WS0 */
+ 	clkin_freq[3] = 0; /* CGU_FIN_SELECT_XT_DAI_BCK1 */
+ 	clkin_freq[4] = 0; /* CGU_FIN_SELECT_XT_DAI_WS1 */
+ 	clkin_freq[5] = 0; /* CGU_FIN_SELECT_HPPLL0 	*/
+ 	clkin_freq[6] = 0; /* CGU_FIN_SELECT_HPPLL1 	*/
+ 	
+ 	/* init CGU driver */
+ 	cgu_init(clkin_freq);
+ 	cgu_reset_all_clks();
+ 	/* set HPLL1 - main PLL to default speed */
+ 	cgu_hpll_config (CGU_HPLL1_ID, &pll);
+ 	/* set HPLL0 - Audio PLL to default speed */
+ 	cgu_hpll_config (CGU_HPLL0_ID, &pll0);
+ 	
+ 	/* re-use the default clock tree distribution structure */
+ 	cgu_init_clks(&g_cgu_default_clks);   
+ }
+ /*-----------------------------------------------------------*/
+ /***********************************************************************
+  * Delay constants in nanosecs for MT48LC32M16LF SDRAM on board
+  **********************************************************************/
+ #define EA3131_SDRAM_TRP            (20)
+ #define EA3131_SDRAM_TRFC           (66)
+ #define EA3131_SDRAM_TRAS           (44)
+ #define EA3131_SDRAM_TREX           (75)
+ #define EA3131_SDRAM_TARP           4
+ #define EA3131_SDRAM_TWR            (75)
+ #define EA3131_SDRAM_TRC            (66)
+ #define EA3131_SDRAM_TRRD           (15)
+ #define EA3131_SDRAM_TMRD           (20)
+ #define EA3131_SDRAM_TXSR           (75)
+ #define EA3131_SDRAM_TDAL           (50)
+ #define EA3131_SDRAM_REFRESH        (100)
+ #define EA3131_SDRAM_OPER_REFRESH   (7812)
+ 	
+ #define EA3131_MPMC_DELAY           0x824
+ 
+ #define TEST_MPMC_CLK    (90000000ull)
+ 
+ 
+ void MemorySetup( void )
+ {
+ 	  long tmp;
+ 	  /* configure the LCD pins in EBI memory mode. */
+ 	  SYS_REGS->mux_lcd_ebi_sel = 1;
+ 	
+ 	  /* enable EBI clock */
+ 	  cgu_clk_en_dis(CGU_SB_EBI_CLK_ID, 1);
+ 	
+ 	  /* enable MPMC controller clocks */
+ 	  cgu_clk_en_dis(CGU_SB_MPMC_CFG_CLK_ID, 1);
+ 	  cgu_clk_en_dis(CGU_SB_MPMC_CFG_CLK2_ID, 1);
+ 	  cgu_clk_en_dis(CGU_SB_MPMC_CFG_CLK3_ID, 1);
+ 	
+ 	  /* enable External Memory controller */
+ 	  MPMC->control = MPMC_CTL_ENABLE;
+ 	  /* Force HCLK to MPMC_CLK to 1:1 ratio */
+ 	  MPMC->config = MPMC_CFG_SDCCLK_1_1;
+ 	  /* set MPMC delay gates appropriately based on trace lengths between
+ 	  SDRAM and the chip. Also based on the delay startergy used for SDRAM. */
+ 	  SYS_REGS->mpmp_delaymodes = EA3131_MPMC_DELAY;
+ 	
+ 	  udelay(100);
+ 	
+ 	
+ 	  /* Set command delay startergy */
+ 	  MPMC->sdram_rdcfg = MPMC_SDRAMC_RDCFG_CMDDELAY_STG;
+ 	
+ 	  /* configure "device config register" nSDCE0 for proper width
+ 		 SDRAM */
+ 	  MPMC->sdram[0].config = SDRAMC_16HP_32Mx16_4B_R13_C10;
+ 	
+ #ifdef TEST_CAS_3
+ 	  MPMC->sdram[0].rascas = MPMC_SDRAMC_RASCAS_RAS3 | MPMC_SDRAMC_RASCAS_CAS3;
+ #else
+ 	  MPMC->sdram[0].rascas = MPMC_SDRAMC_RASCAS_RAS2 | MPMC_SDRAMC_RASCAS_CAS2;
+ #endif
+ 	
+ 	  /* min 20ns program 1 so that atleast 2 HCLKs are used */
+ 	  MPMC->sdram_rp   = MPMC_SDRAMC_TRP(EA3131_SDRAM_TRP, TEST_MPMC_CLK);
+ 	  MPMC->sdram_ras  = MPMC_SDRAMC_TRAS(EA3131_SDRAM_TRAS, TEST_MPMC_CLK);
+ 	  MPMC->sdram_srex = MPMC_SDRAMC_TSREX(EA3131_SDRAM_TREX, TEST_MPMC_CLK);
+ 	  MPMC->sdram_apr  = EA3131_SDRAM_TARP;
+ 	  MPMC->sdram_dal  = MPMC_SDRAMC_TDAL(EA3131_SDRAM_TDAL, TEST_MPMC_CLK);
+ 	  MPMC->sdram_wr   = MPMC_SDRAMC_TWR(EA3131_SDRAM_TWR, TEST_MPMC_CLK);
+ 	  MPMC->sdram_rc   = MPMC_SDRAMC_TRC(EA3131_SDRAM_TRC, TEST_MPMC_CLK);
+ 	  MPMC->sdram_rfc  = MPMC_SDRAMC_TRFC(EA3131_SDRAM_TRFC, TEST_MPMC_CLK);
+ 	  MPMC->sdram_xsr  = MPMC_SDRAMC_TXSR(EA3131_SDRAM_TXSR, TEST_MPMC_CLK);
+ 	  MPMC->sdram_rrd  = MPMC_SDRAMC_TRRD(EA3131_SDRAM_TRRD, TEST_MPMC_CLK);
+ 	  MPMC->sdram_mrd  = MPMC_SDRAMC_TMRD(EA3131_SDRAM_TMRD, TEST_MPMC_CLK);
+ 	
+ 	  udelay(100);
+ 	
+ 	  /* issue continuous NOP commands (INIT & MRS set) */
+ 	  MPMC->sdram_ctrl = MPMC_SDRAMC_CTL_CE | MPMC_SDRAMC_CTL_CS |
+ 						 MPMC_SDRAMC_CTL_NOP_CMD;
+ 	
+ 	  /* load ~200us delay value to timer1 */
+ 	  udelay(200);
+ 	
+ 	  /* issue a "pre-charge all" command */
+ 	  MPMC->sdram_ctrl = MPMC_SDRAMC_CTL_CE | MPMC_SDRAMC_CTL_CS |
+ 						 MPMC_SDRAMC_CTL_PALL_CMD;
+ 	
+ 	  /*******************************************************************
+ 	  * Minimum refresh pulse interval (tRFC) for MT48LC32M16A2=80nsec,
+ 	  * 100nsec provides more than adequate interval.
+ 	  ******************************************************************/
+ 	  MPMC->sdram_ref = MPMC_SDRAMC_REFRESH(EA3131_SDRAM_REFRESH,
+ 											TEST_MPMC_CLK);
+ 	
+ 	  /* load ~250us delay value to timer1 */
+ 	  udelay(250);
+ 	
+ 	  /*******************************************************************
+ 	  *  Recommended refresh interval for normal operation of the Micron
+ 	  * MT48LC16LFFG = 7.8125usec (128KHz rate).
+ 	  * ((HCLK / 128000) - 1) = refresh counter interval rate, (subtract
+ 	  * one for safety margin).
+ 	  ******************************************************************/
+ 	  MPMC->sdram_ref = MPMC_SDRAMC_REFRESH(EA3131_SDRAM_OPER_REFRESH,
+ 											TEST_MPMC_CLK);
+ 	
+ 	  /* select mode register update mode */
+ 	  MPMC->sdram_ctrl = MPMC_SDRAMC_CTL_CE | MPMC_SDRAMC_CTL_CS |
+ 						 MPMC_SDRAMC_CTL_MODE_CMD;
+ 	
+ 	  /*******************************************************************
+ 	  * Program the SDRAM internal mode registers on bank nSDCE0
+ 	  * and reconfigure the SDRAM chips.  Bus speeds up to 90MHz
+ 	  * requires use of a CAS latency = 2.
+ 	  * To get correct value on address bus CAS cycle, requires a shift
+ 	  * by 13 for 16bit mode
+ 	  ******************************************************************/
+ #ifdef TEST_CAS_3
+ 	  tmp = *((volatile ulong *)(EXT_SDRAM_BASE | _SBF(13, 0x33)));
+ #else
+ 	  tmp = *((volatile ulong *)(EXT_SDRAM_BASE | _SBF(13, 0x23)));
+ #endif
+ 	
+ 	  MPMC->sdram[0].config = SDRAMC_16HP_32Mx16_4B_R13_C10;
+ 	
+ #ifdef TEST_CAS_3
+ 	  MPMC->sdram[0].rascas = MPMC_SDRAMC_RASCAS_RAS3 | MPMC_SDRAMC_RASCAS_CAS3;
+ #else
+ 	  MPMC->sdram[0].rascas = MPMC_SDRAMC_RASCAS_RAS2 | MPMC_SDRAMC_RASCAS_CAS2;
+ #endif
+ 	
+ 	  /* select normal operating mode */
+ 	  MPMC->sdram_ctrl = MPMC_SDRAMC_CTL_CE | MPMC_SDRAMC_CTL_CS |
+ 						 MPMC_SDRAMC_CTL_NORMAL_CMD;
+ 	
+ 	  MPMC->sdram[0].config |= MPMC_SDRAMC_CFG_BUF_EN;
+ 	
+ 	  MPMC->sdram_ctrl = MPMC_SDRAMC_CTL_NORMAL_CMD | MPMC_SDRAMC_CTL_CS;
+ 
+ }
+ /*-----------------------------------------------------------*/
+ void GPIOMuxSetup( void )
+ {
+ 	gpio_set_outpin_high(IOCONF_GPIO, 2);
+ }
+ /*-----------------------------------------------------------*/
+ void lowlevel_init(void)
+ {
+ 	/* Clock Setup */
+ 	ClockSetup();
+ 	/* Misc hardware setup */
+ 	MiscSetup();
+ 	/* GPIO & MUX Setup */
+ 	GPIOMuxSetup();
+ 	
+ 	timer_init();
+ 
+ 	/* Memory Setup */
+ 	MemorySetup();
+ 
+ 	/* enable clock to interrupt controller */
+ 	cgu_clk_en_dis(CGU_SB_AHB2INTC_CLK_ID, 1);
+ 	cgu_clk_en_dis(CGU_SB_INTC_CLK_ID, 1);
+ 
+ }
+ 
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_cgu_default.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_cgu_default.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_cgu_default.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_cgu_default.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,357 ----
+ /***********************************************************************
+  * $Id:: lpc313x_cgu_default.c 1537 2009-01-13 00:00:54Z pdurgesh      $
+  *
+  * Project: LPC313x CGU driver
+  *
+  * Description:
+  *     This file define the default recomended clock tree distribution 
+  * structure for LPC313x by defining the CGU switch box structre.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  *********************************************************************/
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #include "lpc313x_cgu_driver.h"
+ 
+ /*------------------------------------------------------------------------------------------
+   Group the clocks 0 - 29 belonging to SYS_BASE domain into 7 different sub-domains using
+   following macro. Clocks not defined in the macros will be sourced with SYS_BASE_CLK.
+  ------------------------------------------------------------------------------------------*/
+ /* define clocks belonging to subdomain DOMAIN0_DIV0 */
+ #define CGU_DEF_DOMAIN0_DIV0	( D0_BIT(CGU_SB_APB0_CLK_ID) | D0_BIT(CGU_SB_APB1_CLK_ID) | \
+                                D0_BIT(CGU_SB_APB2_CLK_ID) | D0_BIT(CGU_SB_APB3_CLK_ID) | \
+                                D0_BIT(CGU_SB_APB4_CLK_ID) | D0_BIT(CGU_SB_AHB2INTC_CLK_ID) | \
+                                D0_BIT(CGU_SB_AHB0_CLK_ID) | D0_BIT(CGU_SB_DMA_PCLK_ID) | \
+                                D0_BIT(CGU_SB_DMA_CLK_GATED_ID) | D0_BIT(CGU_SB_NANDFLASH_S0_CLK_ID) | \
+                                D0_BIT(CGU_SB_NANDFLASH_PCLK_ID) | D0_BIT(CGU_SB_ARM926_BUSIF_CLK_ID) | \
+                                D0_BIT(CGU_SB_SD_MMC_HCLK_ID) | D0_BIT(CGU_SB_USB_OTG_AHB_CLK_ID) | \
+                                D0_BIT(CGU_SB_ISRAM0_CLK_ID) | D0_BIT(CGU_SB_ISRAM1_CLK_ID) | \
+                                D0_BIT(CGU_SB_ISROM_CLK_ID) | D0_BIT(CGU_SB_MPMC_CFG_CLK_ID) | \
+                                D0_BIT(CGU_SB_MPMC_CFG_CLK2_ID) | D0_BIT(CGU_SB_INTC_CLK_ID) )
+ 
+ /* define clocks belonging to subdomain DOMAIN0_DIV1 */
+ #define CGU_DEF_DOMAIN0_DIV1	(D0_BIT(CGU_SB_ARM926_CORE_CLK_ID))
+ 
+ /* define clocks belonging to subdomain DOMAIN0_DIV2 */
+ #define CGU_DEF_DOMAIN0_DIV2	( D0_BIT(CGU_SB_NANDFLASH_AES_CLK_ID) | \
+                                D0_BIT(CGU_SB_NANDFLASH_NAND_CLK_ID))
+ 
+ /* define clocks belonging to subdomain DOMAIN0_DIV3 */
+ #define CGU_DEF_DOMAIN0_DIV3	(D0_BIT(CGU_SB_NANDFLASH_ECC_CLK_ID))
+ 
+ /* define clocks belonging to subdomain DOMAIN0_DIV4 */
+ #define CGU_DEF_DOMAIN0_DIV4	(D0_BIT(CGU_SB_SD_MMC_CCLK_IN_ID))
+ /* define clocks belonging to subdomain DOMAIN0_DIV5 */
+ #define CGU_DEF_DOMAIN0_DIV5	(D0_BIT(CGU_SB_CLOCK_OUT_ID))
+ /* define clocks belonging to subdomain DOMAIN0_DIV6 */
+ #define CGU_DEF_DOMAIN0_DIV6	(D0_BIT(CGU_SB_EBI_CLK_ID))
+ 
+ /*------------------------------------------------------------------------------------------
+   Group the clocks 30 - 39 belonging to AHB_APB0_BASE domain into 2 different sub-domains using
+   following macro. Clocks not defined in the macros will be sourced with AHB_APB0_BASE_CLK.
+  ------------------------------------------------------------------------------------------*/
+ /* define clocks belonging to subdomain DOMAIN1_DIV7 */
+ #define CGU_DEF_DOMAIN1_DIV7	(D1_BIT(CGU_SB_ADC_CLK_ID))
+ /* define clocks belonging to subdomain DOMAIN1_DIV8 */
+ #define CGU_DEF_DOMAIN1_DIV8	( D1_BIT(CGU_SB_AHB2APB0_ASYNC_PCLK_ID) | \
+                                D1_BIT(CGU_SB_EVENT_ROUTER_PCLK_ID) | D1_BIT(CGU_SB_ADC_PCLK_ID) | \
+                                D1_BIT(CGU_SB_WDOG_PCLK_ID) | D1_BIT(CGU_SB_IOCONF_PCLK_ID) | \
+                                D1_BIT(CGU_SB_CGU_PCLK_ID) | D1_BIT(CGU_SB_SYSCREG_PCLK_ID) | \
+                                D1_BIT(CGU_SB_OTP_PCLK_ID) | D1_BIT(CGU_SB_RNG_PCLK_ID) )
+ 
+ /*------------------------------------------------------------------------------------------
+   Group the clocks 40 - 49 belonging to AHB_APB1_BASE domain into 2 different sub-domains using
+   following macro. Clocks not defined in the macros will be sourced with AHB_APB1_BASE_CLK.
+  ------------------------------------------------------------------------------------------*/
+ /* define clocks belonging to subdomain DOMAIN2_DIV9 */
+ #define CGU_DEF_DOMAIN2_DIV9	( D2_BIT(CGU_SB_AHB2APB1_ASYNC_PCLK_ID) | \
+                                D2_BIT(CGU_SB_TIMER0_PCLK_ID) | D2_BIT(CGU_SB_TIMER1_PCLK_ID) | \
+                                D2_BIT(CGU_SB_TIMER2_PCLK_ID) | D2_BIT(CGU_SB_TIMER3_PCLK_ID) | \
+                                D2_BIT(CGU_SB_PWM_PCLK_ID) | D2_BIT(CGU_SB_PWM_PCLK_REGS_ID) | \
+                                D2_BIT(CGU_SB_I2C0_PCLK_ID) | D2_BIT(CGU_SB_I2C1_PCLK_ID) )
+ 
+ /* define clocks belonging to subdomain DOMAIN2_DIV10 */
+ #define CGU_DEF_DOMAIN2_DIV10	(D2_BIT(CGU_SB_PWM_CLK_ID))
+ 
+ /*------------------------------------------------------------------------------------------
+   Group the clocks 50 - 57 belonging to AHB_APB2_BASE domain into 3 different sub-domains using
+   following macro. Clocks not defined in the macros will be sourced with AHB_APB2_BASE_CLK.
+  ------------------------------------------------------------------------------------------*/
+ /* define clocks belonging to subdomain DOMAIN3_DIV11 */
+ #define CGU_DEF_DOMAIN3_DIV11	( D3_BIT(CGU_SB_AHB2APB2_ASYNC_PCLK_ID) | \
+                                 D3_BIT(CGU_SB_PCM_PCLK_ID) | D3_BIT(CGU_SB_PCM_APB_PCLK_ID) | \
+                                 D3_BIT(CGU_SB_UART_APB_CLK_ID) | D3_BIT(CGU_SB_LCD_PCLK_ID) | \
+                                 D3_BIT(CGU_SB_SPI_PCLK_ID) | D3_BIT(CGU_SB_SPI_PCLK_GATED_ID) )
+ 
+ /* define clocks belonging to subdomain DOMAIN3_DIV12 */
+ #define CGU_DEF_DOMAIN3_DIV12	(D3_BIT(CGU_SB_LCD_CLK_ID))
+ /* Currently no clocks are connected to this subdomain */
+ #define CGU_DEF_DOMAIN3_DIV13	(0)
+ 
+ /*------------------------------------------------------------------------------------------
+   Group the clocks 58 - 70 belonging to AHB_APB3_BASE domain into a sub-domains using
+   following macro. Clocks not defined in the macros will be sourced wih AHB_APB3_BASE_CLK.
+  ------------------------------------------------------------------------------------------*/
+ #define CGU_DEF_DOMAIN4_DIV14	( D4_BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID) | \
+                                 D4_BIT(CGU_SB_I2S_CFG_PCLK_ID) | D4_BIT(CGU_SB_EDGE_DET_PCLK_ID) | \
+                                 D4_BIT(CGU_SB_I2STX_FIFO_0_PCLK_ID) | D4_BIT(CGU_SB_I2STX_IF_0_PCLK_ID) | \
+                                 D4_BIT(CGU_SB_I2STX_FIFO_1_PCLK_ID) | D4_BIT(CGU_SB_I2STX_IF_1_PCLK_ID) | \
+                                 D4_BIT(CGU_SB_I2SRX_FIFO_0_PCLK_ID) | D4_BIT(CGU_SB_I2SRX_IF_0_PCLK_ID) | \
+                                 D4_BIT(CGU_SB_I2SRX_FIFO_1_PCLK_ID) | D4_BIT(CGU_SB_I2SRX_IF_1_PCLK_ID) )
+ 
+ /*------------------------------------------------------------------------------------------
+   Define whether CGU_SB_PCM_CLK_IP_ID clock uses the FDC_15 fractional divider or not. If
+   the following macro is set 0 then CGU_SB_PCM_CLK_IP_ID clock is sourced with PCM_BASE_CLK.
+  ------------------------------------------------------------------------------------------*/
+ #define CGU_DEF_DOMAIN5_DIV15	(D5_BIT(CGU_SB_PCM_CLK_IP_ID))
+ 
+ /*------------------------------------------------------------------------------------------
+   Define whether CGU_SB_UART_U_CLK_ID clock uses the FDC_16 fractional divider or not. If
+   the following macro is set 0 then CGU_SB_UART_U_CLK_ID clock is sourced with UART_BASE_CLK.
+  ------------------------------------------------------------------------------------------*/
+ #define CGU_DEF_DOMAIN6_DIV16	(0)
+ 
+ /*------------------------------------------------------------------------------------------
+   Group the clocks 73 - 86 belonging to CLK1024FS_BASE domain into 6 different sub-domains using
+   following macro. Clocks not defined in the macros will be sourced with CLK1024FS_BASE_CLK.
+  ------------------------------------------------------------------------------------------*/
+ /* define clocks belonging to subdomain DOMAIN7_DIV17. This divider has 13 bit resolution
+    for madd & msub values compared to other dividers which have 8 bit only.*/
+ #define CGU_DEF_DOMAIN7_DIV17	( D7_BIT(CGU_SB_I2S_EDGE_DETECT_CLK_ID) | \
+                                 D7_BIT(CGU_SB_I2STX_WS0_ID) | D7_BIT(CGU_SB_I2STX_WS1_ID) | \
+                                 D7_BIT(CGU_SB_I2SRX_WS0_ID) | D7_BIT(CGU_SB_I2SRX_WS1_ID) )
+ 
+ /* define clocks belonging to subdomain DOMAIN7_DIV18 */
+ #define CGU_DEF_DOMAIN7_DIV18	( D7_BIT(CGU_SB_I2STX_BCK0_N_ID) | \
+                                 D7_BIT(CGU_SB_I2STX_BCK1_N_ID) )
+ 
+ /* define clocks belonging to subdomain DOMAIN7_DIV19 */
+ #define CGU_DEF_DOMAIN7_DIV19	( D7_BIT(CGU_SB_I2STX_CLK0_ID) | \
+                                 D7_BIT(CGU_SB_CLK_256FS_ID) )
+ 
+ /* define clocks belonging to subdomain DOMAIN7_DIV20 */
+ #define CGU_DEF_DOMAIN7_DIV20	( D7_BIT(CGU_SB_I2SRX_BCK0_N_ID) | \
+                                 D7_BIT(CGU_SB_I2SRX_BCK1_N_ID) )
+ 
+ /* define clocks belonging to subdomain DOMAIN7_DIV21 */
+ #define CGU_DEF_DOMAIN7_DIV21	(0)
+ /* define clocks belonging to subdomain DOMAIN7_DIV22 */
+ #define CGU_DEF_DOMAIN7_DIV22	(0)
+ 
+ /* I2SRX_BCK0_BASE and I2SRX_BCK1_BASE domains are directly connected. So, no entry exists here */
+ 
+ /*------------------------------------------------------------------------------------------
+   Group the clocks 89 - 90 belonging to SPI_CLK_BASE domain into a sub-domain using
+   following macro. Clocks not defined in the macros will be sourced wih SPI_CLK_BASE_CLK.
+  ------------------------------------------------------------------------------------------*/
+ #define CGU_DEF_DOMAIN10_DIV23	( D10_BIT(CGU_SB_SPI_CLK_ID) | \
+                                  D10_BIT(CGU_SB_SPI_CLK_GATED_ID) )
+ 
+ 
+ 
+ /* SYSCLK_O_BASE is directly connected. So, no entry exists here */
+ 
+ /*------------------------------------------------------------------------------------------
+   Global variables:
+  ------------------------------------------------------------------------------------------*/
+ /*Below are the default configurations
+  * FFAST : 12MHz
+  * MASTER PLL Freq: 180MHz;
+  * AUDIOPLL Freq:   1024Fs, Fs = 44.1kHz
+  *
+  * Domain                            Input             Subdomain          Divider Ratio
+  * 0 - CGU_SB_SYS_BASE_ID            MASTER PLL(HPLL1) DOMAIN0_DIV0         1/2
+  *                                                     DOMAIN0_DIV1         1
+  *                                                     DOMAIN0_DIV2         1/2
+  *                                                     DOMAIN0_DIV3         1/4
+  *                                                     DOMAIN0_DIV4         1/4
+  *                                                     DOMAIN0_DIV5         1/2
+  *                                                     DOMAIN0_DIV6         1/2
+  *
+  * 1 - CGU_SB_AHB0_APB0_BASE_ID      FFAST             DOMAIN1_DIV7         1/38
+  *                                                     DOMAIN1_DIV8         1/2
+  *
+  * 2 - CGU_SB_AHB0_APB1_BASE_ID      FFAST             DOMAIN2_DIV9         1/2
+  *                                                     DOMAIN2_DIV10        1/2
+  *
+  * 3 - CGU_SB_AHB0_APB2_BASE_ID      MASTER PLL(HPLL1) DOMAIN3_DIV11        1/2
+  *                                                     DOMAIN3_DIV12        1/40
+  *                                                     DOMAIN3_DIV13        1 (not used)
+  *
+  * 4 - CGU_SB_AHB0_APB3_BASE_ID      FFAST             DOMAIN4_DIV14        1/2
+  *
+  * 5 - CGU_SB_PCM_BASE_ID            MASTER PLL(HPLL1) DOMAIN5_DIV15        1/2
+  *
+  * 6 - CGU_SB_UART_BASE_ID           FFAST             DOMAIN6_DIV16        1
+  *
+  * 7 - CGU_SB_CLK1024FS_BASE_ID      AUDIO PLL(HPLL0)  DOMAIN7_DIV17        1/256
+  *                                                     DOMAIN7_DIV18        1/4
+  *                                                     DOMAIN7_DIV19        1
+  *                                                     DOMAIN7_DIV20        1/4
+  *                                                     DOMAIN7_DIV21        1/32
+  *                                                     DOMAIN7_DIV22        1/2
+  *
+  * 8 - CGU_SB_I2SRX_BCK0_BASE_ID     I2SRX_BCK0        -                    -
+  *
+  * 9 - CGU_SB_I2SRX_BCK1_BASE_ID     I2SRX_BCK1        -                    -
+  *
+  * 10 - CGU_SB_SPI_CLK_BASE_ID       MASTER PLL(HPLL1) DOMAIN10_DIV23       1/2
+  *
+  * 11 - CGU_SB_SYSCLK_O_BASE_ID      FFAST           -                      -
+  *
+  * End of configuration table
+  */
+ 
+ const CGU_CLKS_INIT_T g_cgu_default_clks =
+ {
+   /* domain0 [7] - SYS_BASE Domain*/
+   {
+     CGU_FIN_SELECT_HPPLL1,
+     {
+       {{1, 1, 2}, CGU_DEF_DOMAIN0_DIV0},  /*FracDiv0 */
+       {{0, 0, 0}, CGU_DEF_DOMAIN0_DIV1},  /*FracDiv1 */
+       {{1, 1, 2}, CGU_DEF_DOMAIN0_DIV2},  /*FracDiv2 */
+       {{1, 1, 4}, CGU_DEF_DOMAIN0_DIV3},  /*FracDiv3 */
+       {{1, 1, 4}, CGU_DEF_DOMAIN0_DIV4},  /*FracDiv4 */
+       {{1, 1, 2}, CGU_DEF_DOMAIN0_DIV5},  /*FracDiv5 */
+       {{1, 1, 2}, CGU_DEF_DOMAIN0_DIV6}   /*FracDiv6 */
+     }
+   },
+   /* domain1 [2] - AHB0_APB0 ClockDomain*/
+   {
+     CGU_FIN_SELECT_FFAST,
+     {
+       {{1, 1, 38}, CGU_DEF_DOMAIN1_DIV7}, /*FracDiv7 */
+       {{1, 1, 2}, CGU_DEF_DOMAIN1_DIV8}   /*FracDiv8 */
+     }
+   },
+   /* domain2 [2] - AHB0_APB1 ClockDomain*/
+   {
+     CGU_FIN_SELECT_FFAST,
+     {
+       {{1, 1, 2}, CGU_DEF_DOMAIN2_DIV9}, /*FracDiv9  */
+       {{1, 1, 2}, CGU_DEF_DOMAIN2_DIV10} /*FracDiv10 */
+     }
+   },
+   /* domain3 [3] - AHB0_APB2 ClockDomain*/
+   {
+     CGU_FIN_SELECT_HPPLL1,
+     {
+       {{1, 1, 2}, CGU_DEF_DOMAIN3_DIV11}, /*FracDiv11 */
+       {{1, 1, 40}, CGU_DEF_DOMAIN3_DIV12},/*FracDiv12 */
+       {{0, 0, 0}, CGU_DEF_DOMAIN3_DIV13}  /*FracDiv13 */
+     }
+   },
+   /* domain4 [1] - AHB0_APB3 ClockDomain*/
+   {
+     CGU_FIN_SELECT_FFAST,
+     {
+       {{1, 1, 2}, CGU_DEF_DOMAIN4_DIV14} /*FracDiv14 */
+     }
+   },
+   /* domain5 [1] - PCM ClockDomain*/
+   {
+     CGU_FIN_SELECT_HPPLL1,
+     {
+       {{1, 1, 2}, CGU_DEF_DOMAIN5_DIV15} /*FracDiv15 */
+     }
+   },
+   /* domain6 [1] - UART ClockDomain*/
+   {
+     CGU_FIN_SELECT_FFAST,
+     {
+       {{0, 0, 0}, CGU_DEF_DOMAIN6_DIV16} /*FracDiv16 */
+     }
+   },
+   /* domain7 [6] - CLK1024FS ClockDomain*/
+   {
+     CGU_FIN_SELECT_HPPLL0,
+     {
+       {{1, 1, 256}, CGU_DEF_DOMAIN7_DIV17},/*FracDiv17 */
+       {{1, 1, 4}, CGU_DEF_DOMAIN7_DIV18},  /*FracDiv18 */
+       {{0, 0, 0}, CGU_DEF_DOMAIN7_DIV19},  /*FracDiv19 */
+       {{1, 1, 4}, CGU_DEF_DOMAIN7_DIV20},  /*FracDiv20 */
+       {{1, 1, 32}, CGU_DEF_DOMAIN7_DIV21}, /*FracDiv21 */
+       {{1, 1, 2}, CGU_DEF_DOMAIN7_DIV22}   /*FracDiv22 */
+     }
+   },
+   /* domain8  - I2SRX_BCK0 ClockDomain*/
+   {
+     CGU_FIN_SELECT_XT_I2SRX_BCK0
+   },
+ 
+   /* domain9  - I2SRX_BCK1 ClockDomain*/
+   {
+     CGU_FIN_SELECT_XT_I2SRX_BCK1
+   },
+   /* domain10 [1] - SPI ClockDomain*/
+   {
+     CGU_FIN_SELECT_HPPLL1,
+     {
+       {{1, 1, 2}, CGU_DEF_DOMAIN10_DIV23} /*FracDiv23 */
+     }
+   },
+   /* domain11  - SYSCLK_O ClockDomain*/
+   {
+     CGU_FIN_SELECT_FFAST
+   },
+ 
+   /* dyn_fdiv_cfg[7]  */
+   {
+     /*For DYN_SEL, the bits below are all configured as 1.*/
+     /*
+        bit 	  Name							    Description:
+ 
+     	0	simple_dma_trans  			 dma transfers can enable high-speed
+     	1	simple_dma_ready				 dma last transfers can enable high-speed
+     	2	arm926_i_trans  	       arm926ejs_i transfers can enable high-speed
+     	3	arm926_i_ready		       arm926ejs_i_ready last transfers can enable high-speed
+     	4	arm926_d_trans  	       arm926ejs_d transfers can enable high-speed
+     	5	arm926_d_ready		       arm926ejs_d transfers can enable high-speed
+     	6	usb_otg_mst_trans   		 USB OTG transfers can enable high spee
+     	7	usb_otg_mst_ready				 USB OTG last transfers can enable high-speed
+     	8	mpmc_refresh_hispeed_req External SDRAM refresh generator transfers can enable high speed
+     */
+     {
+       0x1FF,
+       {1, 1, 64} /*DynFD0*/
+     },
+     {
+       0x1FF,
+       {0, 0, 0}	/*DynFD1*/
+     },
+     {
+       0x1FF,
+       {1, 1, 3}	/*DynFD2*/
+     },
+     {
+       0x1FF,
+       {1, 1, 6}	/*DynFD3*/
+     },
+     {
+       0x1FF,
+       {1, 1, 6}	/*DynFD4*/
+     },
+     {
+       0x1FF,
+       {1, 1, 6}	/*DynFD5*/
+     },
+     {
+       0x1FF,
+       {1, 1, 3}	/*DynFD6*/
+     }
+   }
+ };
+ 
+ 
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_cgu_driver.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_cgu_driver.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_cgu_driver.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_cgu_driver.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,1161 ----
+ /***********************************************************************
+ * $Id:: lpc313x_cgu_driver.c 1529 2009-01-06 02:08:40Z pdurgesh       $
+ *
+ * Project: LPC313x CGU driver
+ *
+ * Description:
+ *     This file contains driver support for the lpc313x CGU.
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ *********************************************************************/
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ #include "lpc313x_cgu_driver.h"
+ 
+ /***********************************************************************
+ * CGU driver package data
+ ***********************************************************************/
+ struct _CGU_DRIVER_DAT
+ {
+   ulong  clkin_freq[CGU_FIN_SELECT_MAX];
+   ulong init;
+ } g_cgu_driver;
+ 
+ /***********************************************************************
+ * CGU driver private functions
+ **********************************************************************/
+ 
+ static ulong  cgu_clkid2esrid(CGU_CLOCK_ID_T clkid);
+ static ulong  cgu_DomainId2bcrid(CGU_DOMAIN_ID_T domainid);
+ static void cgu_ClkId2DomainId(CGU_CLOCK_ID_T clkid, CGU_DOMAIN_ID_T* pDomainId,
+                         ulong * pSubdomainId);
+ static ulong  cgu_fdiv_config(ulong  fdId, CGU_FDIV_SETUP_T fdivCfg, ulong enable);
+ static void cgu_init_domain_clks(CGU_DOMAIN_CFG_T* pDomain);
+ /***********************************************************************
+ *
+ * Function: cgu_fdiv_num_bits
+ *
+ * Purpose: calculate int(log2(i))+1
+ *
+ * Processing:
+ *     This algorithm is used to calculate the above said formula.
+ *     This is used to calculate the madd and msub width in frac div
+ *     registers.Reasonably fast.
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns: int(log2(i))+1
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ static ulong  cgu_fdiv_num_bits(unsigned int i)
+ {
+   ulong  x = 0, y = 16;
+ 
+   for (; y > 0; y = y >> 1)
+   {
+     if (i >> y)
+     {
+       x += y;
+       i = i >> y;
+     }
+   }
+ 
+   if (i)
+     x++;
+ 
+   return x;
+ }
+ 
+ /***********************************************************************
+ *
+ * Function: cgu_clkid2esrid
+ *
+ * Purpose: Finds ESR Id corresponding to the requested clock Id
+ *
+ * Processing:
+ *     Finds ESR index corresponding to the requested clock Id.
+ *
+ * Parameters:
+ *     clkid : clock Id.
+ *
+ * Outputs: None
+ *
+ * Returns: ESR Id corresponding to clock Id
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ ulong  cgu_clkid2esrid(CGU_CLOCK_ID_T clkid)
+ {
+   ulong  esrIndex = (ulong )clkid;
+ 
+   switch (clkid)
+   {
+     case CGU_SB_I2SRX_BCK0_ID:
+     case CGU_SB_I2SRX_BCK1_ID:
+     case CGU_SB_SYSCLK_O_ID:
+       /* invalid esr index. No ESR register for these clocks */
+       esrIndex = CGU_INVALID_ID;
+       break;
+ 
+     case CGU_SB_SPI_CLK_ID:
+     case CGU_SB_SPI_CLK_GATED_ID:
+       esrIndex = esrIndex - 2;
+       break;
+     default:
+       /* do nothing */
+       break;
+   }
+ 
+   return esrIndex;
+ }
+ /***********************************************************************
+ *
+ * Function: cgu_DomainId2bcrid
+ *
+ * Purpose: Finds BCR Id corresponding to the requested domain Id
+ *
+ * Processing:
+ *     Finds BCR index corresponding to the requested domain Id.
+ *
+ * Parameters:
+ *     domainid : Domain ID
+ *
+ * Outputs: None
+ *
+ * Returns: BCR Id corresponding to domain Id
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ ulong  cgu_DomainId2bcrid(CGU_DOMAIN_ID_T domainid)
+ {
+   ulong  bcridx = CGU_INVALID_ID;
+   switch (domainid)
+   {
+     case CGU_SB_SYS_BASE_ID:
+     case CGU_SB_AHB0_APB0_BASE_ID:
+     case CGU_SB_AHB0_APB1_BASE_ID:
+     case CGU_SB_AHB0_APB2_BASE_ID:
+       bcridx = domainid;
+       break;
+     case CGU_SB_CLK1024FS_BASE_ID:
+       bcridx = CGU_SB_NR_BCR - 1;
+       break;
+     default:
+       bcridx = CGU_INVALID_ID;
+       break;
+   }
+   return bcridx;
+ }
+ /***********************************************************************
+ *
+ * Function: cgu_ClkId2DomainId
+ *
+ * Purpose: Finds domain & sub-domain Ids for requested clock
+ *
+ * Processing:
+ *     Finds domain index and fractional divider index for the requested
+ *	   clock.
+ *
+ * Parameters:
+ *     clkid : clock Id.
+ *     pDomainId : pointer to domain index.
+ *     pSubdomainId : pointer to fractional divider index.
+ *
+ * Outputs:
+ *     pDomainId : pointer to domain index.
+ *     pSubdomainId : pointer to fractional divider index.
+ *
+ * Returns: None
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ void cgu_ClkId2DomainId(CGU_CLOCK_ID_T clkid, CGU_DOMAIN_ID_T* pDomainId,
+                         ulong * pSubdomainId)
+ {
+   ulong  esrIndex, esrReg;
+   ulong  fracdiv_base = CGU_INVALID_ID;
+ 
+   /*    1. Get the domain ID */
+ 
+   if (clkid <= CGU_SYS_LAST)
+   {
+     *pDomainId = CGU_SB_SYS_BASE_ID;
+     fracdiv_base = CGU_SB_BASE0_FDIV_LOW_ID;
+ 
+   }
+   else 	if (clkid <= CGU_AHB0APB0_LAST)
+   {
+     *pDomainId = CGU_SB_AHB0_APB0_BASE_ID;
+     fracdiv_base = CGU_SB_BASE1_FDIV_LOW_ID;
+ 
+   }
+   else 	if (clkid <= CGU_AHB0APB1_LAST)
+   {
+     *pDomainId = CGU_SB_AHB0_APB1_BASE_ID;
+     fracdiv_base = CGU_SB_BASE2_FDIV_LOW_ID;
+ 
+   }
+   else 	if (clkid <= CGU_AHB0APB2_LAST)
+   {
+     *pDomainId = CGU_SB_AHB0_APB2_BASE_ID;
+     fracdiv_base = CGU_SB_BASE3_FDIV_LOW_ID;
+ 
+   }
+   else 	if (clkid <= CGU_AHB0APB3_LAST)
+   {
+     *pDomainId = CGU_SB_AHB0_APB3_BASE_ID;
+     fracdiv_base = CGU_SB_BASE4_FDIV_LOW_ID;
+ 
+   }
+   else 	if (clkid == CGU_PCM_LAST)
+   {
+     *pDomainId = CGU_SB_PCM_BASE_ID;
+     fracdiv_base = CGU_SB_BASE5_FDIV_LOW_ID;
+ 
+   }
+   else 	if (clkid == CGU_UART_LAST)
+   {
+     *pDomainId = CGU_SB_UART_BASE_ID;
+     fracdiv_base = CGU_SB_BASE6_FDIV_LOW_ID;
+ 
+   }
+   else 	if (clkid <= CGU_CLK1024FS_LAST)
+   {
+     *pDomainId = CGU_SB_CLK1024FS_BASE_ID;
+     fracdiv_base = CGU_SB_BASE7_FDIV_LOW_ID;
+ 
+   }
+   else 	if (clkid == CGU_I2SRX_BCK0_LAST)
+   {
+     *pDomainId = CGU_SB_I2SRX_BCK0_BASE_ID;
+     fracdiv_base = CGU_INVALID_ID;
+ 
+   }
+   else 	if (clkid == CGU_I2SRX_BCK1_LAST)
+   {
+     *pDomainId = CGU_SB_I2SRX_BCK1_BASE_ID;
+     fracdiv_base = CGU_INVALID_ID;
+ 
+   }
+   else 	if (clkid <= CGU_SPI_LAST)
+   {
+     *pDomainId = CGU_SB_SPI_CLK_BASE_ID;
+     fracdiv_base = CGU_SB_BASE10_FDIV_LOW_ID;
+ 
+   }
+   else
+   {
+     *pDomainId = CGU_SB_SYSCLK_O_BASE_ID;
+     fracdiv_base = CGU_INVALID_ID;
+   }
+ 
+   *pSubdomainId = CGU_INVALID_ID;
+ 
+   /* read the clocks ESR to get the fractional divider */
+   esrIndex = cgu_clkid2esrid(clkid);
+ 
+   if (CGU_INVALID_ID != esrIndex)
+   {
+     /* read the clocks ESR to get the fractional divider */
+     esrReg = CGU_SB->clk_esr[esrIndex];
+ 
+     /* A clock may not be connected to any sub-domain and it might be
+     connected directly to domain. This is also a valid combination. So,
+     errror should not be returned */
+     if (esrReg & CGU_SB_ESR_ENABLE)
+     {
+       *pSubdomainId = CGU_SB_ESR_SEL_GET(esrReg) + fracdiv_base;
+     }
+   }
+ 
+ }
+ 
+ /***********************************************************************
+ *
+ * Function: cgu_fdiv_config
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ /* frac divider config function */
+ ulong  cgu_fdiv_config(ulong  fdId, CGU_FDIV_SETUP_T fdivCfg, ulong enable)
+ {
+   ulong  conf, maddw, msubw, maxw, fdWidth;
+   long madd, msub;
+ 
+   /* calculating program values to see if they fit in fractional divider*/
+   madd = fdivCfg.m - fdivCfg.n;
+   msub = -fdivCfg.n;
+ 
+   /* Find required bit width of madd & msub:*/
+   maddw = cgu_fdiv_num_bits((ulong )madd);
+   msubw = cgu_fdiv_num_bits((ulong )fdivCfg.n);
+   maxw = (maddw > msubw) ? maddw : msubw;
+   fdWidth = CGU_SB_BASE0_FDIV0_W;
+ 
+   if (fdId == CGU_SB_BASE7_FDIV_LOW_ID)
+   {
+     /* for Frac divider 17 the bit width is 13 */
+     fdWidth = CGU_SB_BASE7_FDIV0_W;
+   }
+ 
+   /* Calculate Configure parameter:*/
+   conf = ((((1 << fdWidth) - 1) &
+            (msub << (fdWidth - maxw))) <<
+           (fdWidth + CGU_SB_FDC_MADD_POS)) |
+          (madd << (fdWidth - maxw + CGU_SB_FDC_MADD_POS));
+ 
+   /* check whther 50% duty cycle is needed for this divider*/
+   if (fdivCfg.stretch)
+     conf |= CGU_SB_FDC_STRETCH;
+   /* check whehter to enable the divider immediately */
+   if (enable)
+     conf |= CGU_SB_FDC_RUN;
+ 
+   /* finally configure the divider*/
+   CGU_SB->base_fdc[fdId] = conf;
+ 
+   return conf;
+ }
+ /***********************************************************************
+ *
+ * Function: cgu_init_domain_clks
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ void cgu_init_domain_clks(CGU_DOMAIN_CFG_T* pDomain)
+ {
+   ulong  fd_id, clk_id, esr_id;
+   CGU_SUB_DOMAIN_CFG_T* psub = pDomain->sub;
+   ulong  bcr_id = cgu_DomainId2bcrid(pDomain->id);
+   ulong  fdiv_conf = 0;
+ 
+   if (bcr_id != CGU_INVALID_ID)
+   {
+     /* disable BCR for domain */
+     CGU_SB->base_bcr[bcr_id] = 0;
+   }
+ 
+   /* configure frac divider */
+   for (fd_id = 0; fd_id < pDomain->fdiv_cnt; fd_id++, psub++)
+   {
+     /* set fractional dividers but don't enable them yet*/
+     fdiv_conf = cgu_fdiv_config(fd_id + pDomain->fdiv_min, psub->fdiv_cfg, 0);
+ 
+     /* enable frac divider only if it has valid settings. Or else it may be unused*/
+     if (fdiv_conf != 0)
+     {
+       /* select frac div for each clock in this sub domain*/
+       for (clk_id = 0; clk_id <= pDomain->clk_cnt; clk_id++)
+       {
+         esr_id = cgu_clkid2esrid((CGU_CLOCK_ID_T)(clk_id + pDomain->clk_min));
+         if (esr_id != CGU_INVALID_ID)
+         {
+           /* check whether clock belongs to this sub-domain */
+           if (psub->clks & (1<<clk_id))
+           {
+             /* finally configure the clock*/
+             CGU_SB->clk_esr[esr_id] = CGU_SB_ESR_SELECT(fd_id) | CGU_SB_ESR_ENABLE;
+           }
+         }
+       }
+       /* enable frac divider */
+       CGU_SB->base_fdc[fd_id + pDomain->fdiv_min] |= CGU_SB_FDC_RUN;
+     }
+   }
+   if (bcr_id != CGU_INVALID_ID)
+   {
+     /* enable BCR for domain */
+     CGU_SB->base_bcr[bcr_id] = CGU_SB_BCR_FD_RUN;
+   }
+   /* select input for domain*/
+   cgu_set_base_freq(pDomain->id, pDomain->fin_sel);
+ }
+ 
+ 
+ /***********************************************************************
+ * CGU driver public functions
+ ***********************************************************************/
+ /***********************************************************************
+ *
+ * Function: cgu_init
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ void cgu_init(ulong  clkin_freq[CGU_FIN_SELECT_MAX])
+ {
+   ulong  i = CGU_FIN_SELECT_MAX;
+ 
+   /* initialize the CGU Driver data */
+   while (i--)
+   {
+     g_cgu_driver.clkin_freq[i] = clkin_freq[i];
+   }
+ 
+   /* set init  done */
+   g_cgu_driver.init = 1;
+ 
+ }
+ /***********************************************************************
+ *
+ * Function: cgu_reset_all_clks
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ void cgu_reset_all_clks(void)
+ {
+   CGU_DOMAIN_ID_T domainId;
+   ulong  bcrId, esr_id;
+   ulong  enable, i;
+ 
+   /* switch all clocks to FFAST */
+   for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++)
+   {
+     /* switch reference clock in to FFAST */
+     cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
+     /* check if the domain has a BCR*/
+     bcrId = cgu_DomainId2bcrid(domainId);
+     /* disable all BCRs */
+     if (bcrId != CGU_INVALID_ID)
+     {
+       CGU_SB->base_bcr[bcrId] = 0;
+     }
+   }
+   /* disable all clocks except the needed ones */
+   for (i = 0; i < (CGU_SYSCLK_O_LAST + 1); i++)
+   {
+     /* Clear the clocks ESR to deselect fractional divider */
+     esr_id = cgu_clkid2esrid((CGU_CLOCK_ID_T)i);
+ 
+     if (CGU_INVALID_ID != esr_id)
+     {
+       CGU_SB->clk_esr[esr_id] = 0;
+     }
+ 
+     if (i < 31)
+     {
+       enable = CGU_DEF_CLKS_0_31 & (1<<i);
+     }
+     else
+     {
+       if (i < 63)
+       {
+         enable = CGU_DEF_CLKS_32_63 & (1<<(i - 32));
+       }
+       else
+       {
+         enable = CGU_DEF_CLKS_64_92 & (1<<(i - 64));
+       }
+     }
+     /**********************************************************/
+     /* initiliase external enables and ext_outs  */
+     /**********************************************************/
+     /* set external enable for all possible clocks to conserve
+     power. cgu_clk_set_exten() function sets CGU_SB_PCR_EXTEN_EN
+     for allowed clocks only. */
+     cgu_clk_set_exten((CGU_CLOCK_ID_T)i, 1);
+ 
+     /* set enable-outs for only the following clocks */
+     if ((i == CGU_SB_ARM926_BUSIF_CLK_ID) ||
+         (i == CGU_SB_MPMC_CFG_CLK_ID))
+     {
+       CGU_SB->clk_pcr[i] |= CGU_SB_PCR_ENOUT_EN;
+     }
+     else
+     {
+       CGU_SB->clk_pcr[i] &= ~CGU_SB_PCR_ENOUT_EN;
+     }
+ 
+     /* disable all clocks except the needed ones */
+     if (enable)
+     {
+       CGU_SB->clk_pcr[i] |= CGU_SB_PCR_RUN;
+     }
+     else
+     {
+       CGU_SB->clk_pcr[i] &= ~CGU_SB_PCR_RUN;
+     }
+   }
+   /* disable all fractional dividers */
+   for (i = 0; i < CGU_SB_NR_FRACDIV; i++)
+   {
+     CGU_SB->base_fdc[i] &= ~CGU_SB_FDC_RUN;
+   }
+ }
+ 
+ /***********************************************************************
+ *
+ * Function: cgu_init_clks
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ /* select frac div for each clk */
+ long cgu_init_clks(const CGU_CLKS_INIT_T* pClksCfg)
+ {
+   CGU_DOMAIN_CFG_T domain;
+ 
+   /* check whether driver is initialized */
+   if (g_cgu_driver.init == 0)
+   {
+     return -1;
+   }
+   /* reset all clocks and connect them to FFAST */
+   cgu_reset_all_clks();
+ 
+   /**********************************************************/
+   /* initiliase Domain0 = SYS_BASE clocks                   */
+   /**********************************************************/
+   domain.id = CGU_SB_SYS_BASE_ID;
+   domain.fin_sel = pClksCfg->domain0.fin_sel;
+   domain.clk_min = CGU_SYS_FIRST;
+   domain.clk_cnt = (CGU_SYS_LAST - CGU_SYS_FIRST) + 1;
+   domain.fdiv_min = CGU_SB_BASE0_FDIV_LOW_ID;
+   domain.fdiv_cnt = CGU_SB_BASE0_FDIV_CNT;
+   domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain0.sub[0];
+   /* initialize all clocks and frac dividers for this domain */
+   cgu_init_domain_clks(&domain);
+ 
+   /**********************************************************/
+   /* initiliase Domain1 = AHB0APB0_BASE clocks */
+   /**********************************************************/
+   domain.id = CGU_SB_AHB0_APB0_BASE_ID;
+   domain.fin_sel = pClksCfg->domain1.fin_sel;
+   domain.clk_min = CGU_AHB0APB0_FIRST;
+   domain.clk_cnt = (CGU_AHB0APB0_LAST - CGU_AHB0APB0_FIRST) + 1;
+   domain.fdiv_min = CGU_SB_BASE1_FDIV_LOW_ID;
+   domain.fdiv_cnt = CGU_SB_BASE1_FDIV_CNT;
+   domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain1.sub[0];
+   /* initialize all clocks and frac dividers for this domain */
+   cgu_init_domain_clks(&domain);
+ 
+   /**********************************************************/
+   /* initiliase Domain2 = AHB0APB1_BASE clocks */
+   /**********************************************************/
+   domain.id = CGU_SB_AHB0_APB1_BASE_ID;
+   domain.fin_sel = pClksCfg->domain2.fin_sel;
+   domain.clk_min = CGU_AHB0APB1_FIRST;
+   domain.clk_cnt = (CGU_AHB0APB1_LAST - CGU_AHB0APB1_FIRST) + 1;
+   domain.fdiv_min = CGU_SB_BASE2_FDIV_LOW_ID;
+   domain.fdiv_cnt = CGU_SB_BASE2_FDIV_CNT;
+   domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain2.sub[0];
+   /* initialize all clocks and frac dividers for this domain */
+   cgu_init_domain_clks(&domain);
+ 
+   /**********************************************************/
+   /* initiliase Domain3 = AHB0APB2_BASE clocks */
+   /**********************************************************/
+   domain.id = CGU_SB_AHB0_APB2_BASE_ID;
+   domain.fin_sel = pClksCfg->domain3.fin_sel;
+   domain.clk_min = CGU_AHB0APB2_FIRST;
+   domain.clk_cnt = (CGU_AHB0APB2_LAST - CGU_AHB0APB2_FIRST) + 1;
+   domain.fdiv_min = CGU_SB_BASE3_FDIV_LOW_ID;
+   domain.fdiv_cnt = CGU_SB_BASE3_FDIV_CNT;
+   domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain3.sub[0];
+   /* initialize all clocks and frac dividers for this domain */
+   cgu_init_domain_clks(&domain);
+ 
+   /**********************************************************/
+   /* initiliase Domain4 = AHB0APB3_BASE clocks */
+   /**********************************************************/
+   domain.id = CGU_SB_AHB0_APB3_BASE_ID;
+   domain.fin_sel = pClksCfg->domain4.fin_sel;
+   domain.clk_min = CGU_AHB0APB3_FIRST;
+   domain.clk_cnt = (CGU_AHB0APB3_LAST - CGU_AHB0APB3_FIRST) + 1;
+   domain.fdiv_min = CGU_SB_BASE4_FDIV_LOW_ID;
+   domain.fdiv_cnt = CGU_SB_BASE4_FDIV_CNT;
+   domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain4.sub[0];
+   /* initialize all clocks and frac dividers for this domain */
+   cgu_init_domain_clks(&domain);
+ 
+   /**********************************************************/
+   /* initiliase Domain5 = PCM_BASE clocks */
+   /**********************************************************/
+   domain.id = CGU_SB_PCM_BASE_ID;
+   domain.fin_sel = pClksCfg->domain5.fin_sel;
+   domain.clk_min = CGU_PCM_FIRST;
+   domain.clk_cnt = 1;
+   domain.fdiv_min = CGU_SB_BASE5_FDIV_LOW_ID;
+   domain.fdiv_cnt = CGU_SB_BASE5_FDIV_CNT;
+   domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain5.sub[0];
+   /* initialize all clocks and frac dividers for this domain */
+   cgu_init_domain_clks(&domain);
+ 
+   /**********************************************************/
+   /* initiliase Domain6 = UART_BASE clocks */
+   /**********************************************************/
+   domain.id = CGU_SB_UART_BASE_ID;
+   domain.fin_sel = pClksCfg->domain6.fin_sel;
+   domain.clk_min = CGU_UART_FIRST;
+   domain.clk_cnt = 1;
+   domain.fdiv_min = CGU_SB_BASE6_FDIV_LOW_ID;
+   domain.fdiv_cnt = CGU_SB_BASE6_FDIV_CNT;
+   domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain6.sub[0];
+   /* initialize all clocks and frac dividers for this domain */
+   cgu_init_domain_clks(&domain);
+ 
+   /**********************************************************/
+   /* initiliase Domain7 = CLK1024FS_BASE clocks */
+   /**********************************************************/
+   domain.id = CGU_SB_CLK1024FS_BASE_ID;
+   domain.fin_sel = pClksCfg->domain7.fin_sel;
+   domain.clk_min = CGU_CLK1024FS_FIRST;
+   domain.clk_cnt = (CGU_CLK1024FS_LAST - CGU_CLK1024FS_FIRST) + 1;
+   domain.fdiv_min = CGU_SB_BASE7_FDIV_LOW_ID;
+   domain.fdiv_cnt = CGU_SB_BASE7_FDIV_CNT;
+   domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain7.sub[0];
+   /* initialize all clocks and frac dividers for this domain */
+   cgu_init_domain_clks(&domain);
+ 
+   /**********************************************************/
+   /* initiliase Domain8 = I2SRX_BCK0_BASE clocks */
+   /**********************************************************/
+   /* select input for domain*/
+   cgu_set_base_freq(CGU_SB_I2SRX_BCK0_BASE_ID, pClksCfg->domain8.fin_sel);
+ 
+   /**********************************************************/
+   /* initiliase Domain9 = I2SRX_BCK1_BASE clocks */
+   /**********************************************************/
+   /* select input for domain*/
+   cgu_set_base_freq(CGU_SB_I2SRX_BCK1_BASE_ID, pClksCfg->domain9.fin_sel);
+ 
+   /**********************************************************/
+   /* initiliase Domain10 = SPI_BASE clocks */
+   /**********************************************************/
+   domain.id = CGU_SB_SPI_CLK_BASE_ID;
+   domain.fin_sel = pClksCfg->domain10.fin_sel;
+   domain.clk_min = CGU_SPI_FIRST;
+   domain.clk_cnt = (CGU_SPI_LAST - CGU_SPI_FIRST) + 1;
+   domain.fdiv_min = CGU_SB_BASE10_FDIV_LOW_ID;
+   domain.fdiv_cnt = CGU_SB_BASE10_FDIV_CNT;
+   domain.sub = (CGU_SUB_DOMAIN_CFG_T*) & pClksCfg->domain10.sub[0];
+   /* initialize all clocks and frac dividers for this domain */
+   cgu_init_domain_clks(&domain);
+ 
+   /**********************************************************/
+   /* initiliase Domain11 = SYSCLK_O_BASE clocks */
+   /**********************************************************/
+   /* select input for domain*/
+   cgu_set_base_freq(CGU_SB_SYSCLK_O_BASE_ID, pClksCfg->domain11.fin_sel);
+ 
+   /**********************************************************/
+   /* initiliase Dynamic fractional dividers TBD */
+   /**********************************************************/
+ 
+ 
+   return 0;
+ }
+ 
+ /***********************************************************************
+ *
+ * Function: cgu_get_base_freq
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ long cgu_get_base_freq(CGU_DOMAIN_ID_T baseid)
+ {
+   long freq;
+ 
+   /* check whether driver is initialized */
+   if (g_cgu_driver.init == 0)
+   {
+     return -1;
+   }
+ 
+   /* get base frequency for the domain */
+   freq = g_cgu_driver.clkin_freq[CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[baseid])];
+ 
+   return freq;
+ }
+ 
+ /***********************************************************************
+ *
+ * Function: cgu_set_base_freq
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, ulong  fin_sel)
+ {
+   ulong  baseSCR;
+ 
+   /* Switch configuration register*/
+   baseSCR = CGU_SB->base_scr[baseid] & ~CGU_SB_SCR_FS_MASK;
+   /* If fs1 is currently enabled set refId to fs2 and enable fs2*/
+   if (CGU_SB->base_ssr[baseid] & CGU_SB_SCR_EN1)
+   {
+     /* check if the selcted frequency is same as requested. If not switch.*/
+     if (CGU_SB->base_fs1[baseid] != fin_sel)
+     {
+       CGU_SB->base_fs2[baseid] = fin_sel;
+ 
+       /* Don't touch stop bit in SCR register*/
+       CGU_SB->base_scr[baseid] = baseSCR | CGU_SB_SCR_EN2;
+     }
+   }
+   else
+   {
+     /* check if the selcted frequency is same as requested. If not switch.*/
+     if (CGU_SB->base_fs2[baseid] != fin_sel)
+     {
+       CGU_SB->base_fs1[baseid] = fin_sel;
+ 
+       /* Don't touch stop bit in SCR register*/
+       CGU_SB->base_scr[baseid] = baseSCR | CGU_SB_SCR_EN1;
+     }
+   }
+ }
+ 
+ /***********************************************************************
+ *
+ * Function: cgu_get_clk_freq
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ ulong  cgu_get_clk_freq(CGU_CLOCK_ID_T clkid)
+ {
+   ulong  freq = 0;
+   CGU_DOMAIN_ID_T domainId;
+   ulong  subDomainId;
+   long n, m;
+   ulong  fdcVal;
+ 
+   /* check whether driver is initialized */
+   if (g_cgu_driver.init == 0)
+   {
+     return 0;
+   }
+ 
+   /* get domain and frac div info for the clock */
+   cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
+ 
+   /* get base frequency for the domain */
+   freq = g_cgu_driver.clkin_freq[CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId])];
+ 
+   /* direct connection  has no fraction divider*/
+   if (subDomainId == CGU_INVALID_ID)
+   {
+     return freq;
+   }
+   /* read frac div control register value */
+   fdcVal = CGU_SB->base_fdc[subDomainId];
+ 
+   if (fdcVal & CGU_SB_FDC_RUN) /* Is the fracdiv enabled ?*/
+   {
+     /* Yes, so reverse calculation of madd and msub */
+     {
+       long msub, madd;
+ 
+       if (subDomainId != CGU_SB_BASE7_FDIV_LOW_ID)
+       {
+         msub = CGU_SB_FDC_MSUB_GET(fdcVal);
+         madd = CGU_SB_FDC_MADD_GET(fdcVal);
+       }
+       else
+       {
+         msub = CGU_SB_FDC17_MSUB_GET(fdcVal);
+         madd = CGU_SB_FDC17_MADD_GET(fdcVal);
+       }
+ 
+       /* remove trailing zeros */
+       while (!(msub & 1)  && !(madd & 1))
+       {
+         madd = madd >> 1;
+         msub = msub >> 1;
+       }
+       /* compute m and n values */
+       n = - msub;
+       m = madd + n;
+     }
+     /* check m and n are non-zero values */
+     if ((n == 0) || (m == 0))
+     {
+       return 0;
+     }
+     /* calculate the frequency based on m and n values */
+     freq = (freq * n) / m ;
+   }
+   /* else There is no fractional divider in the clocks path */
+ 
+   return  freq;
+ }
+ 
+ /***********************************************************************
+ *
+ * Function: cgu_set_subdomain_freq
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ void cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg)
+ {
+   CGU_DOMAIN_ID_T domainId;
+   ulong  subDomainId, base_freq, bcrId;
+ 
+   /* get domain and frac div info for the clock */
+   cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
+ 
+   /* direct connection  has no fraction divider*/
+   if (subDomainId != CGU_INVALID_ID)
+   {
+     /* store base freq */
+     base_freq = CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]);
+     /* switch domain to FFAST */
+     cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
+     /* check if the domain has a BCR*/
+     bcrId = cgu_DomainId2bcrid(domainId);
+     /* disable all BCRs */
+     if (bcrId != CGU_INVALID_ID)
+     {
+       CGU_SB->base_bcr[bcrId] = 0;
+     }
+     /* change fractional divider */
+     cgu_fdiv_config(subDomainId, fdiv_cfg, 1);
+     /* enable BCRs */
+     if (bcrId != CGU_INVALID_ID)
+     {
+       CGU_SB->base_bcr[bcrId] = CGU_SB_BCR_FD_RUN;
+     }
+     /* switch domain to original base frequency */
+     cgu_set_base_freq(domainId, base_freq);
+   }
+ }
+ 
+ /***********************************************************************
+ *
+ * Function: cgu_hpll_config
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ void cgu_hpll_config(CGU_HPLL_ID_T pllid, CGU_HPLL_SETUP_T* pllsetup)
+ {
+   CGU_HP_CFG_REGS* hppll;
+   ulong  switched_domains = 0;
+   CGU_DOMAIN_ID_T domainId;
+ 
+   /**********************************************************
+   * switch domains connected to HPLL to FFAST automatically
+   ***********************************************************/
+   for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++)
+   {
+     if (CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]) ==
+         (CGU_FIN_SELECT_HPPLL0 + pllid))
+     {
+       /* switch reference clock in to FFAST */
+       cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
+       /* store the domain id to switch back to HPLL */
+       switched_domains |= (1<<domainId);
+     }
+   }
+ 
+   /* get PLL regs */
+   hppll = &CGU_CFG->hp[pllid];
+ 
+   /* disable clock, disable skew enable, power down pll,
+   * (dis/en)able post divider, (dis/en)able pre-divider,
+   * disable free running mode, disable bandsel,
+   * enable up limmiter, disable bypass
+   */
+   hppll->mode = CGU_HPLL_MODE_PD;
+ 
+   /* Select fin */
+   hppll->fin_select = pllsetup->fin_select;
+ 
+   /* M divider */
+   hppll->mdec = pllsetup->mdec & CGU_HPLL_MDEC_MASK;
+ 
+   /* N divider */
+   hppll->ndec = pllsetup->ndec & CGU_HPLL_NDEC_MSK;
+ 
+   /* P divider */
+   hppll->pdec = pllsetup->pdec & CGU_HPLL_PDEC_MSK;
+ 
+   /* Set bandwidth */
+   hppll->selr = pllsetup->selr;
+   hppll->seli = pllsetup->seli;
+   hppll->selp = pllsetup->selp;
+ 
+   /* Power up pll */
+   hppll->mode = (pllsetup->mode & ~CGU_HPLL_MODE_PD) | CGU_HPLL_MODE_CLKEN;
+ 
+   /* store the estimated freq in driver data for future clk calcs */
+   g_cgu_driver.clkin_freq[CGU_FIN_SELECT_HPPLL0 + pllid] = pllsetup->freq;
+ 
+   /* wait for PLL to lock */
+   while ((hppll->status & CGU_HPLL_STATUS_LOCK) == 0);
+ 
+   /**********************************************************
+   * switch domains back to HPLL
+   ***********************************************************/
+   for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++)
+   {
+     if (switched_domains & (1<<domainId))
+     {
+       /* switch reference clock in to HPLL */
+       cgu_set_base_freq(domainId, CGU_FIN_SELECT_HPPLL0 + pllid);
+     }
+   }
+ 
+ }
+ 
+ /***********************************************************************
+ *
+ * Function: cgu_hpll_status
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ ulong  cgu_hpll_status(CGU_HPLL_ID_T pllid)
+ {
+   /* get PLL regs */
+   return CGU_CFG->hp[pllid].status;
+ }
+ 
+ /***********************************************************************
+ *
+ * Function: cgu_soft_reset_module
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ void cgu_soft_reset_module(CGU_MOD_ID_T modId)
+ {
+   volatile ulong  i;
+   volatile ulong * pmod_rst_reg = &(CGU_CFG->apb1_resetn_soft);
+ 
+   /* All the reset registers are continously mapped with an address difference of 4 */
+   pmod_rst_reg += modId;
+ 
+   /* clear and set the register */
+   *pmod_rst_reg = 0;
+   /* introduce some delay */
+   for (i = 0;i < 1000;i++);
+ 
+   *pmod_rst_reg = CGU_CONFIG_SOFT_RESET;
+ }
+ 
+ /***********************************************************************
+ *
+ * Function: cgu_clk_set_exten
+ *
+ * Purpose:
+ *
+ * Processing:
+ *     .
+ *
+ * Parameters:
+ *     i : Number
+ *
+ * Outputs: None
+ *
+ * Returns:
+ *
+ * Notes: None
+ *
+ **********************************************************************/
+ void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, ulong enable)
+ {
+   switch (clkid)
+   {
+     case CGU_SB_OTP_PCLK_ID:
+     case CGU_SB_PCM_APB_PCLK_ID:
+     case CGU_SB_EVENT_ROUTER_PCLK_ID:
+     case CGU_SB_ADC_PCLK_ID:
+     case CGU_SB_IOCONF_PCLK_ID:
+     case CGU_SB_CGU_PCLK_ID:
+     case CGU_SB_SYSCREG_PCLK_ID:
+     case CGU_SB_DMA_CLK_GATED_ID:
+     case CGU_SB_SPI_PCLK_GATED_ID:
+     case CGU_SB_SPI_CLK_GATED_ID:
+     case CGU_SB_PCM_CLK_IP_ID:
+     case CGU_SB_PWM_PCLK_REGS_ID:
+       if (enable)
+       {
+         CGU_SB->clk_pcr[clkid] |= CGU_SB_PCR_EXTEN_EN;
+       }
+       else
+       {
+         CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_EXTEN_EN;
+       }
+       break;
+       /* force disable for the following clocks */
+     case CGU_SB_I2C0_PCLK_ID:
+     case CGU_SB_I2C1_PCLK_ID:
+     case CGU_SB_WDOG_PCLK_ID:
+     case CGU_SB_UART_APB_CLK_ID:
+     case CGU_SB_LCD_PCLK_ID:
+       CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_EXTEN_EN;
+       break;
+     default:
+       break;
+   }
+ }
+ 
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_cgu_driver.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_cgu_driver.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_cgu_driver.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_cgu_driver.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,363 ----
+ /***********************************************************************
+ * $Id:: lpc313x_cgu_driver.h 1537 2009-01-13 00:00:54Z pdurgesh       $
+ *
+ * Project: LPC313X CGU driver
+ *
+ * Description:
+ *     This file contains driver support for the CGU module on the
+ *     LPC313X.
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+ 
+ #ifndef LPC313X_CGU_DRIVER_H
+ #define LPC313X_CGU_DRIVER_H
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ #include "lpc313x_cgu.h"
+ #include "lpc313x_cgu_switchbox.h"
+ 
+ /***********************************************************************
+ * CGU driver defines - MACROS & constants
+ **********************************************************************/
+ #define CGU_INVALID_ID  0xFFFF
+ 
+ /* Following clocks are enabled after init.
+ CGU_DEF_CLKS_0_31 contains bits for clocks with id between 0 & 31
+ CGU_DEF_CLKS_32_63 contains bits for clocks with id between 32 & 63
+ CGU_DEF_CLKS_64_92 contains bits for clocks with id between 64 & 92
+ */
+ #define CGU_DEF_CLKS_0_31   ( _BIT(CGU_SB_APB0_CLK_ID) | _BIT(CGU_SB_APB1_CLK_ID) | \
+                               _BIT(CGU_SB_APB2_CLK_ID) | _BIT(CGU_SB_APB3_CLK_ID) |_BIT(CGU_SB_APB4_CLK_ID) | \
+                               _BIT(CGU_SB_AHB2INTC_CLK_ID) | _BIT(CGU_SB_AHB0_CLK_ID) | \
+                               _BIT(CGU_SB_ARM926_CORE_CLK_ID) | _BIT(CGU_SB_ARM926_BUSIF_CLK_ID) | \
+                               _BIT(CGU_SB_ARM926_RETIME_CLK_ID) | _BIT(CGU_SB_ISRAM0_CLK_ID) | \
+                               _BIT(CGU_SB_ISRAM1_CLK_ID) | _BIT(CGU_SB_ISROM_CLK_ID) | \
+                               _BIT(CGU_SB_INTC_CLK_ID) | _BIT(CGU_SB_AHB2APB0_ASYNC_PCLK_ID) | \
+                               _BIT(CGU_SB_EVENT_ROUTER_PCLK_ID) | _BIT(CGU_SB_CLOCK_OUT_ID))
+ 
+ #define CGU_DEF_CLKS_32_63 ( _BIT(CGU_SB_IOCONF_PCLK_ID - 32) | _BIT(CGU_SB_CGU_PCLK_ID - 32) | \
+                              _BIT(CGU_SB_SYSCREG_PCLK_ID - 32) | _BIT(CGU_SB_OTP_PCLK_ID - 32) | \
+                              _BIT(CGU_SB_AHB2APB1_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_AHB2APB2_ASYNC_PCLK_ID - 32) | \
+                              _BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_EDGE_DET_PCLK_ID - 32) )
+ 
+ #define CGU_DEF_CLKS_64_92 (0)
+ 
+ /* Following macros are used to define clocks belonging to different 
+    sub-domains with-in each domain. */
+ #define D0_BIT(clkid)   _BIT(clkid)
+ #define D1_BIT(clkid)   _BIT((clkid) - CGU_AHB0APB0_FIRST)
+ #define D2_BIT(clkid)   _BIT((clkid) - CGU_AHB0APB1_FIRST)
+ #define D3_BIT(clkid)   _BIT((clkid) - CGU_AHB0APB2_FIRST)
+ #define D4_BIT(clkid)   _BIT((clkid) - CGU_AHB0APB3_FIRST)
+ #define D5_BIT(clkid)   _BIT((clkid) - CGU_PCM_FIRST)
+ #define D6_BIT(clkid)   _BIT((clkid) - CGU_UART_FIRST)
+ #define D7_BIT(clkid)   _BIT((clkid) - CGU_CLK1024FS_FIRST)
+ /* 8 & 9 have one clk per domain so no macros */
+ #define D10_BIT(clkid)  _BIT((clkid) - CGU_SPI_FIRST)
+ 
+ 
+ /***********************************************************************
+ * CGU driver enumerations
+ **********************************************************************/
+ /* Possible HPLL ids */
+ typedef enum {CGU_HPLL0_ID, CGU_HPLL1_ID} CGU_HPLL_ID_T;
+ 
+ /* CGU soft reset module ID enumerations */
+ typedef enum
+ {
+   APB1_RST_SOFT,
+   AHB2APB1_PNRES_SOFT,
+   APB2_RESETN_SOFT,
+   AHB2APB2_PNRES_SOFT,
+   APB3_RESETN_SOFT,
+   AHB2APB3_PNRES_SOFT,
+   APB4_RESETN_SOFT,
+   AHB2INTC_RESETN_SOFT,
+   AHB0_RESETN_SOFT,
+   EBI_RESETN_SOFT,
+   PCM_PNRES_SOFT,
+   PCM_RESET_N_SOFT,
+   PCM_RESET_ASYNC_N_SOFT,
+   TIMER0_PNRES_SOFT,
+   TIMER1_PNRES_SOFT,
+   TIMER2_PNRES_SOFT,
+   TIMER3_PNRES_SOFT,
+   ADC_PRESETN_SOFT,
+   ADC_RESETN_ADC10BITS_SOFT,
+   PWM_RESET_AN_SOFT,
+   UART_SYS_RST_AN_SOFT,
+   I2C0_PNRES_SOFT,
+   I2C1_PNRES_SOFT,
+   I2S_CFG_RST_N_SOFT,
+   I2S_NSOF_RST_N_SOFT,
+   EDGE_DET_RST_N_SOFT,
+   I2STX_FIFO_0_RST_N_SOFT,
+   I2STX_IF_0_RST_N_SOFT,
+   I2STX_FIFO_1_RST_N_SOFT,
+   I2STX_IF_1_RST_N_SOFT,
+   I2SRX_FIFO_0_RST_N_SOFT,
+   I2SRX_IF_0_RST_N_SOFT,
+   I2SRX_FIFO_1_RST_N_SOFT,
+   I2SRX_IF_1_RST_N_SOFT,
+ 
+   LCD_INTERFACE_PNRES_SOFT = I2SRX_IF_1_RST_N_SOFT + 6,
+   SPI_PNRES_APB_SOFT,
+   SPI_PNRES_IP_SOFT,
+   DMA_PNRES_SOFT,
+   NANDFLASH_ECC_RESET_N_SOFT,
+   NANDFLASH_AES_RESET_N_SOFT,
+   NANDFLASH_NAND_RESET_N_SOFT,
+   RNG_RESETN_SOFT,
+   SD_MMC_PNRES_SOFT,
+   SD_MMC_NRES_CCLK_IN_SOFT,
+   USB_OTG_AHB_RST_N_SOFT,
+   RED_CTL_RESET_N_SOFT,
+   AHB_MPMC_HRESETN_SOFT,
+   AHB_MPMC_REFRESH_RESETN_SOFT,
+   INTC_RESETN_SOFT
+ } CGU_MOD_ID_T;
+ 
+ /***********************************************************************
+ * CGU driver structures
+ **********************************************************************/
+ /* CGU HPLL config settings structure type */
+ typedef struct
+ {
+   ulong fin_select;
+   ulong ndec;
+   ulong mdec;
+   ulong pdec;
+   ulong selr;
+   ulong seli;
+   ulong selp;
+   ulong mode;
+   ulong freq; /* in MHz for driver internal data */
+ } CGU_HPLL_SETUP_T;
+ 
+ /* CGU fractional divider settings structure type */
+ typedef struct
+ {
+   unsigned char stretch; /* Fractional divider stretch enable. */
+   unsigned char n;       /* Fractional divider nominal nominator */
+   unsigned short m;      /* Fractional divider nominal denominator */
+ } CGU_FDIV_SETUP_T;
+ 
+ /* CGU clocks state */
+ typedef struct
+ {
+   ulong clks_0_31;
+   ulong clks_32_63;
+   ulong clks_64_92;
+ } CGU_CLKS_STATE_T;
+ 
+ /* CGU sub-domain settings structure type */
+ typedef struct
+ {
+   CGU_FDIV_SETUP_T fdiv_cfg;  /* Fractional divider settings */
+   ulong clks; /* all clocks belonging to the sub-domain */
+ } CGU_SUB_DOMAIN_CFG_T;
+ 
+ /* CGU domain settings structure type */
+ typedef struct
+ {
+   CGU_DOMAIN_ID_T id;
+   ulong fin_sel;
+   ulong clk_min;
+   ulong clk_cnt;
+   ulong fdiv_min;
+   ulong fdiv_cnt;
+   CGU_SUB_DOMAIN_CFG_T* sub;  /* pointer to array */
+ } CGU_DOMAIN_CFG_T;
+ 
+ /* CGU clks initilisation structure */
+ typedef struct
+ {
+   struct _DOMAIN0_T
+   {
+     ulong fin_sel;
+     CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE0_FDIV_CNT];
+   } domain0;
+ 
+   struct _DOMAIN1_T
+   {
+     ulong fin_sel;
+     CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE1_FDIV_CNT];
+   } domain1;
+ 
+   struct _DOMAIN2_T
+   {
+     ulong fin_sel;
+     CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE2_FDIV_CNT];
+   } domain2;
+ 
+   struct _DOMAIN3_T
+   {
+     ulong fin_sel;
+     CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE3_FDIV_CNT];
+   } domain3;
+ 
+   struct _DOMAIN4_T
+   {
+     ulong fin_sel;
+     CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE4_FDIV_CNT];
+   } domain4;
+ 
+   struct _DOMAIN5_T
+   {
+     ulong fin_sel;
+     CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE5_FDIV_CNT];
+   } domain5;
+ 
+   struct _DOMAIN6_T
+   {
+     ulong fin_sel;
+     CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE6_FDIV_CNT];
+   } domain6;
+ 
+   struct _DOMAIN7_T
+   {
+     ulong fin_sel;
+     CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE7_FDIV_CNT];
+   } domain7;
+ 
+   struct _DOMAIN8_T
+   {
+     ulong fin_sel;
+   } domain8;
+ 
+   struct _DOMAIN9_T
+   {
+     ulong fin_sel;
+   } domain9;
+ 
+   struct _DOMAIN10_T
+   {
+     ulong fin_sel;
+     CGU_SUB_DOMAIN_CFG_T sub[CGU_SB_BASE10_FDIV_CNT];
+   } domain10;
+ 
+   struct _DOMAIN11_T
+   {
+     ulong fin_sel;
+   } domain11;
+ 
+   struct _DYN_FDIV_CFG_T
+   {
+     ulong  sel;
+     CGU_FDIV_SETUP_T cfg;
+   } dyn_fdiv_cfg[CGU_SB_NR_DYN_FDIV];
+ } CGU_CLKS_INIT_T;
+ 
+ /***********************************************************************
+ * CGU driver functions
+ **********************************************************************/
+ /* Initialize CGU driver */
+ void cgu_init(ulong clkin_freq[CGU_FIN_SELECT_MAX]);
+ 
+ /* Reset all clocks to be sourced from FFAST.  */
+ void cgu_reset_all_clks(void);
+ 
+ /* Initialize all clocks at startup using the defaults structure */
+ long cgu_init_clks(const CGU_CLKS_INIT_T* pClksCfg);
+ 
+ /* Return the current base frequecy of the requested domain*/
+ long cgu_get_base_freq(CGU_DOMAIN_ID_T baseid);
+ 
+ /* Change the base frequency for the requested domain */
+ void cgu_set_base_freq(CGU_DOMAIN_ID_T baseid, ulong fin_sel);
+ 
+ /* Return the current frequecy of the requested clock*/
+ ulong cgu_get_clk_freq(CGU_CLOCK_ID_T clkid);
+ 
+ /* Change the sub-domain frequency for the requested clock */
+ void cgu_set_subdomain_freq(CGU_CLOCK_ID_T clkid, CGU_FDIV_SETUP_T fdiv_cfg);
+ 
+ /* Configure the selected HPLL */
+ void cgu_hpll_config(CGU_HPLL_ID_T id, CGU_HPLL_SETUP_T* pllsetup);
+ 
+ /* Get selected HPLL ulong  */
+ ulong cgu_hpll_status (CGU_HPLL_ID_T id);
+ 
+ /* Issue a software reset to the requested module */
+ void cgu_soft_reset_module(CGU_MOD_ID_T mod);
+ 
+ /* enable / disable external enabling of the requested clock in CGU */
+ void cgu_clk_set_exten(CGU_CLOCK_ID_T clkid, ulong enable);
+ 
+ 
+ /***********************************************************************
+ * CGU driver inline (ANSI C99 based) functions
+ **********************************************************************/
+ static __inline ulong cgu_get_watchdog_bark( void )
+ {
+   return ((CGU_CFG->wd_bark & CGU_WD_BARK) == CGU_WD_BARK);
+ }
+ 
+ static __inline ulong cgu_get_ffast_on( void )
+ {
+   return ((CGU_CFG->ffast_on & CGU_FFAST_ON) == CGU_FFAST_ON);
+ }
+ 
+ static __inline void cgu_set_ffast_on(ulong enable)
+ {
+   if (enable)
+   {
+     CGU_CFG->ffast_on = CGU_FFAST_ON;
+   }
+   else
+   {
+     CGU_CFG->ffast_on = 0;
+   }
+ }
+ 
+ static __inline void cgu_set_ffast_bypass(ulong enable)
+ {
+   if (enable)
+   {
+     CGU_CFG->ffast_bypass = CGU_FFAST_BYPASS;
+   }
+   else
+   {
+     CGU_CFG->ffast_bypass = 0;
+   }
+ }
+ 
+ /* enable / disable the requested clock in CGU */
+ static __inline void cgu_clk_en_dis(CGU_CLOCK_ID_T clkid, ulong enable)
+ {
+   if (enable)
+   {
+     CGU_SB->clk_pcr[clkid] |= CGU_SB_PCR_RUN;
+   }
+   else
+   {
+     CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_RUN;
+   }
+ 
+ }
+ 
+ /***********************************************************************
+ * CGU driver exported global data
+ **********************************************************************/
+ extern const CGU_CLKS_INIT_T g_cgu_default_clks;
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_CGU_DRIVER_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_cgu.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_cgu.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_cgu.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_cgu.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,247 ----
+ /***********************************************************************
+ * $Id:: lpc313x_cgu.h 1529 2009-01-06 02:08:40Z pdurgesh              $
+ *
+ * Project: LPC313X family chip definitions
+ *
+ * Description:
+ *     This file contains the structure definitions and manifest
+ *     constants for the LPC313x chip family component:
+ *         Clock generation and switchbox controller
+ *
+ * Notes:
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+ #ifndef LPC313X_CGU_H
+ #define LPC313X_CGU_H
+ 
+ /**********************************************************************
+ * Include files
+ **********************************************************************/
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #ifdef __cplusplus
+ extern "C"    /* Assume C declarations for C++ */
+ {
+ #endif
+ 
+ /**********************************************************************
+ * The device registers
+ **********************************************************************/
+ /* ----------------
+ * HP PLL Registers
+ * ----------------
+ */
+ typedef volatile struct
+ {
+   volatile ulong fin_select;
+   volatile ulong mdec;
+   volatile ulong ndec;
+   volatile ulong pdec;
+   volatile ulong mode;
+   volatile ulong status;
+   volatile ulong ack;
+   volatile ulong req;
+   volatile ulong inselr;
+   volatile ulong inseli;
+   volatile ulong inselp;
+   volatile ulong selr;
+   volatile ulong seli;
+   volatile ulong selp;
+ } CGU_HP_CFG_REGS, *pCGU_HP_CFG_REGS;
+ 
+ 
+ typedef volatile struct
+ {
+   volatile ulong powermode;
+   volatile ulong wd_bark;
+   volatile ulong ffast_on;
+   volatile ulong ffast_bypass;
+   volatile ulong apb0_resetn_soft;
+   volatile ulong ahb2apb0_pnres_soft;
+   volatile ulong apb1_resetn_soft;
+   volatile ulong ahb2apb1_pnres_soft;
+   volatile ulong apb2_resetn_soft;
+   volatile ulong ahb2apb2_pnres_soft;
+   volatile ulong apb3_resetn_soft;
+   volatile ulong ahb2apb3_pnres_soft;
+   volatile ulong apb4_resetn_soft;
+   volatile ulong ahb2intc_resetn_soft;
+   volatile ulong ahb0_resetn_soft;
+   volatile ulong ebi_resetn_soft;
+   volatile ulong pcm_pnres_soft;
+   volatile ulong pcm_reset_n_soft;
+   volatile ulong pcm_reset_async_n_soft;
+   volatile ulong timer0_pnres_soft;
+   volatile ulong timer1_pnres_soft;
+   volatile ulong timer2_pnres_soft;
+   volatile ulong timer3_pnres_soft;
+   volatile ulong adc_presetn_soft;
+   volatile ulong adc_resetn_adc10bits_soft;
+   volatile ulong pwm_reset_an_soft;
+   volatile ulong uart_sys_rst_an_soft;
+   volatile ulong i2c0_pnres_soft;
+   volatile ulong i2c1_pnres_soft;
+   volatile ulong i2s_cfg_rst_n_soft;
+   volatile ulong i2s_nsof_rst_n_soft;
+   volatile ulong edge_det_rst_n_soft;
+   volatile ulong i2stx_fifo_0_rst_n_soft;
+   volatile ulong i2stx_if_0_rst_n_soft;
+   volatile ulong i2stx_fifo_1_rst_n_soft;
+   volatile ulong i2stx_if_1_rst_n_soft;
+   volatile ulong i2srx_fifo_0_rst_n_soft;
+   volatile ulong i2srx_if_0_rst_n_soft;
+   volatile ulong i2srx_fifo_1_rst_n_soft;
+   volatile ulong i2srx_if_1_rst_n_soft;
+   volatile ulong rserved[5];
+   volatile ulong lcd_interface_pnres_soft;
+   volatile ulong spi_pnres_apb_soft;
+   volatile ulong spi_pnres_ip_soft;
+   volatile ulong dma_pnres_soft;
+   volatile ulong nandflash_ctrl_ecc_reset_n_soft;
+   volatile ulong nandflash_ctrl_aes_reset_n_soft;
+   volatile ulong nandflash_ctrl_nand_reset_n_soft;
+   volatile ulong rng_resetn_soft;
+   volatile ulong sd_mmc_pnres_soft;
+   volatile ulong sd_mmc_nres_cclk_in_soft;
+   volatile ulong usb_otg_ahb_rst_n_soft;
+   volatile ulong red_ctl_reset_n_soft;
+   volatile ulong ahb_mpmc_hresetn_soft;
+   volatile ulong ahb_mpmc_refresh_resetn_soft;
+   volatile ulong intc_resetn_soft;
+   CGU_HP_CFG_REGS hp[2];
+ } CGU_CONFIG_REGS, *pCGU_CONFIG_REGS;
+ 
+ 
+ 
+ /**********************************************************************
+ * Register description of POWERMODE
+ **********************************************************************/
+ #define CGU_POWERMODE_MASK     0x3
+ #define CGU_POWERMODE_NORMAL   0x1
+ #define CGU_POWERMODE_WAKEUP   0x3
+ 
+ /**********************************************************************
+ * Register description of WD_BARK
+ **********************************************************************/
+ #define CGU_WD_BARK            0x1
+ 
+ /**********************************************************************
+ * Register description of FFAST_ON
+ **********************************************************************/
+ #define CGU_FFAST_ON           0x1
+ 
+ /**********************************************************************
+ * Register description of FFAST_BYPASS
+ **********************************************************************/
+ #define CGU_FFAST_BYPASS       0x1
+ 
+ /**********************************************************************
+ * Register description of soft reset registers
+ **********************************************************************/
+ #define CGU_CONFIG_SOFT_RESET  0x1
+ 
+ /**********************************************************************
+ * Register description of HPll REGISTERS
+ **********************************************************************/
+ //#define CGU_HPLL0_ID      0
+ //#define CGU_HPLL1_ID      1
+ 
+ /**********************************************************************
+ * Register description of HP_FIN_SELECT
+ **********************************************************************/
+ #define CGU_HPLL_FIN_SEL_MASK       0xf
+ #define CGU_FIN_SELECT_FFAST        0x0
+ #define CGU_FIN_SELECT_XT_I2SRX_BCK0  0x1
+ #define CGU_FIN_SELECT_XT_I2SRX_WS0   0x2
+ #define CGU_FIN_SELECT_XT_I2SRX_BCK1  0x3
+ #define CGU_FIN_SELECT_XT_I2SRX_WS1   0x4
+ #define CGU_FIN_SELECT_HPPLL0       0x5
+ #define CGU_FIN_SELECT_HPPLL1       0x6
+ #define CGU_FIN_SELECT_MAX          7
+ 
+ /**********************************************************************
+ * Register description of HP_MDEC
+ **********************************************************************/
+ #define CGU_HPLL_MDEC_MASK          0x1ffff
+ /**********************************************************************
+ * Register description of HP_NDEC
+ **********************************************************************/
+ #define CGU_HPLL_NDEC_MSK           0x3ff
+ /**********************************************************************
+ * Register description of HP_PDEC
+ **********************************************************************/
+ #define CGU_HPLL_PDEC_MSK           0x7f
+ /**********************************************************************
+ * Register description of HP_MODE
+ **********************************************************************/
+ #define CGU_HPLL_MODE_POR_VAL       0x6
+ #define CGU_HPLL_MODE_CLKEN         _BIT(0)
+ #define CGU_HPLL_MODE_SKEWEN        _BIT(1)
+ #define CGU_HPLL_MODE_PD            _BIT(2)
+ #define CGU_HPLL_MODE_DIRECTO       _BIT(3)
+ #define CGU_HPLL_MODE_DIRECTI       _BIT(4)
+ #define CGU_HPLL_MODE_FRM           _BIT(5)
+ #define CGU_HPLL_MODE_BANDSEL       _BIT(6)
+ #define CGU_HPLL_MODE_LIMUP_OFF     _BIT(7)
+ #define CGU_HPLL_MODE_BYPASS        _BIT(8)
+ 
+ /**********************************************************************
+ * Register description of HP1_STATUS
+ **********************************************************************/
+ #define CGU_HPLL_STATUS_FR          _BIT(1)
+ #define CGU_HPLL_STATUS_LOCK        _BIT(0)
+ 
+ /**********************************************************************
+ * Register description of HP_ACK & HP_REQ
+ **********************************************************************/
+ #define CGU_HPLL_ACK_P              _BIT(2)
+ #define CGU_HPLL_ACK_N              _BIT(1)
+ #define CGU_HPLL_ACK_M              _BIT(0)
+ 
+ /**********************************************************************
+ * Register description of HP1_INSELR
+ **********************************************************************/
+ #define CGU_HPLL_INSELR_MASK        0xf
+ /**********************************************************************
+ * Register description of HP1_INSELI
+ **********************************************************************/
+ #define CGU_HPLL_INSELI_MASK        0x3f
+ /**********************************************************************
+ * Register description of HP1_INSELP
+ **********************************************************************/
+ #define CGU_HPLL_INSELP_MASK        0x1f
+ /**********************************************************************
+ * Register description of HP1_SELR
+ **********************************************************************/
+ #define CGU_HPLL_SELR_MASK          0xf
+ /**********************************************************************
+ * Register description of HP1_SELI
+ **********************************************************************/
+ #define CGU_HPLL_SELI_MASK          0x3f
+ /**********************************************************************
+ * Register description of HP1_SELP
+ **********************************************************************/
+ #define CGU_HPLL_SELP_MASK          0x1f
+ 
+ /* Macro pointing to CGU configuration registers */
+ #define CGU_CFG  ((CGU_CONFIG_REGS  *)(CGU_BASE))
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_CGU_H */
+ 
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_cgu_switchbox.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_cgu_switchbox.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_cgu_switchbox.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_cgu_switchbox.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,374 ----
+ /***********************************************************************
+ * $Id:: lpc313x_cgu_switchbox.h 1537 2009-01-13 00:00:54Z pdurgesh    $
+ *
+ * Project: LPC313X family chip definitions
+ *
+ * Description:
+ *     This file contains the structure definitions and manifest
+ *     constants for the LPC313X chip family component:
+ *         Clock generation and switchbox controller
+ *
+ * Notes:
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+ #ifndef LPC313X_CGU_SWITCHBOX_H
+ #define LPC313X_CGU_SWITCHBOX_H
+ 
+ /***********************************************************************
+ * Include files
+ ***********************************************************************/
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #ifdef __cplusplus
+ extern "C"    /* Assume C declarations for C++ */
+ {
+ #endif
+ 
+ /***********************************************************************
+ * Useful values
+ ***********************************************************************/
+ #define CGU_SB_FSR_WIDTH   3
+ #define CGU_SB_NR_BASE     12
+ #define CGU_SB_NR_CLK      92
+ #define CGU_SB_NR_BCR      5
+ #define CGU_SB_NR_FRACDIV  24
+ #define CGU_SB_NR_DYN_FDIV 7
+ #define CGU_SB_NR_ESR      89
+ 
+ 
+ /***********************************************************************
+  Register section offsets in APB address space
+ ***********************************************************************/
+ #define SCR_OFFSET 0
+ #define FS1_OFFSET 12
+ #define FS2_OFFSET 24
+ #define SSR_OFFSET 36
+ #define PCR_OFFSET 48
+ #define PSR_OFFSET 140
+ #define ESR_OFFSET 232
+ #define BCR_OFFSET 321
+ #define FDC_OFFSET 326
+ 
+ 
+ /***********************************************************************
+ * CGU Switchbox register structure
+ **********************************************************************/
+ typedef volatile struct
+ {
+   /* Switches controls */
+   volatile ulong base_scr[12]; /* Switch control */
+   volatile ulong base_fs1[12]; /* Frequency select side 1 */
+   volatile ulong base_fs2[12]; /* Frequency select side 2 */
+   volatile ulong base_ssr[12]; /* Switch status */
+   /* Clock enable controls (positive and inverted clock pairs share 
+   control register)*/
+   volatile ulong clk_pcr[92];  /* power control */
+   volatile ulong clk_psr[92];  /* power status */
+   /* enable select from fractional dividers (positive and inverted 
+   clock pairs share esr)*/
+   volatile ulong clk_esr[89];  /* enable select */
+   /* Base controls, currently only fd_run (base wide fractional 
+   divider enable) bit.*/
+   volatile ulong base_bcr[5];  /* Base control */
+   /* Fractional divider controls & configuration*/
+   volatile ulong base_fdc[24]; /* Fractional divider config & ctrl */
+   volatile ulong base_dyn_fdc[7]; /* Fractional divider config & ctrl
+                                    for dynamic fracdivs */
+   volatile ulong base_dyn_sel[7]; /* Fractional divider register for 
+                                    selecting an external signal to 
+                                    trigger high-speed operation */
+ } CGU_SB_REGS_T;
+ 
+ /***********************************************************************
+ * Bit positions
+ ***********************************************************************/
+ /* Switch Control Register */
+ #define CGU_SB_SCR_EN1              _BIT(0)
+ #define CGU_SB_SCR_EN2              _BIT(1)
+ #define CGU_SB_SCR_RST              _BIT(2)
+ #define CGU_SB_SCR_STOP             _BIT(3)
+ #define CGU_SB_SCR_FS_MASK          0x3
+ 
+ /* Switch Status Register */
+ #define CGU_SB_SSR_FS_GET(x)        ( ((x) >> 2) & 0x7)
+ /* Power Control Register */
+ #define CGU_SB_PCR_RUN              _BIT(0)
+ #define CGU_SB_PCR_AUTO             _BIT(1)
+ #define CGU_SB_PCR_WAKE_EN          _BIT(2)
+ #define CGU_SB_PCR_EXTEN_EN         _BIT(3)
+ #define CGU_SB_PCR_ENOUT_EN         _BIT(4)
+ /* Power Status Register */
+ #define CGU_SB_PSR_ACTIVE           _BIT(0)
+ #define CGU_SB_PSR_WAKEUP           _BIT(1)
+ /* Enable Select Register */
+ #define CGU_SB_ESR_ENABLE           _BIT(0)
+ #define CGU_SB_ESR_SELECT(x)        _SBF(1, (x))
+ #define CGU_SB_ESR_SEL_GET(x)       (((x) >> 1) & 0x7)
+ 
+ /* Base control Register */
+ #define CGU_SB_BCR_FD_RUN           _BIT(0)
+ /* Fractional Divider Configuration Register */
+ #define CGU_SB_FDC_RUN              _BIT(0)
+ #define CGU_SB_FDC_RESET            _BIT(1)
+ #define CGU_SB_FDC_STRETCH          _BIT(2)
+ #define CGU_SB_FDC_MADD(x)          _SBF( 3, ((x) & 0xFF))
+ #define CGU_SB_FDC_MSUB(x)          _SBF(11, ((x) & 0xFF))
+ #define CGU_SB_FDC17_MADD(x)        _SBF( 3, ((x) & 0x1FFF))
+ #define CGU_SB_FDC17_MSUB(x)        _SBF(16, ((x) & 0x1FFF))
+ #define CGU_SB_FDC_MADD_GET(x)      (((x) >> 3) & 0xFF)
+ #define CGU_SB_FDC_MSUB_GET(x)      ((((x) >> 11) & 0xFF) | 0xFFFFFF00)
+ #define CGU_SB_FDC17_MADD_GET(x)    (((x) >> 3) & 0x1FFF)
+ #define CGU_SB_FDC17_MSUB_GET(x)    ((((x) >> 16) & 0x1FFF) | 0xFFFFE000)
+ #define CGU_SB_FDC_MADD_POS         3
+ 
+ /* Dynamic Fractional Divider Configuration Register */
+ #define CGU_SB_DYN_FDC_RUN          _BIT(0)
+ #define CGU_SB_DYN_FDC_ALLOW        _BIT(1)
+ #define CGU_SB_DYN_FDC_STRETCH      _BIT(2)
+ 
+ /***********************************************************************
+ * Clock domain base id's
+ ***********************************************************************/
+ typedef enum
+ {
+   CGU_SB_SYS_BASE_ID = 0,
+   CGU_SB_BASE_FIRST = CGU_SB_SYS_BASE_ID,
+   CGU_SB_AHB0_APB0_BASE_ID,
+   CGU_SB_AHB0_APB1_BASE_ID,
+   CGU_SB_AHB0_APB2_BASE_ID,
+   CGU_SB_AHB0_APB3_BASE_ID,
+   CGU_SB_PCM_BASE_ID,
+   CGU_SB_UART_BASE_ID,
+   CGU_SB_CLK1024FS_BASE_ID,
+   CGU_SB_I2SRX_BCK0_BASE_ID,
+   CGU_SB_I2SRX_BCK1_BASE_ID,
+   CGU_SB_SPI_CLK_BASE_ID,
+   CGU_SB_SYSCLK_O_BASE_ID,
+   CGU_SB_BASE_LAST = CGU_SB_SYSCLK_O_BASE_ID
+ } CGU_DOMAIN_ID_T;
+ 
+ /***********************************************************************
+  Clock id's (= clkid in address calculation)
+ ***********************************************************************/
+ typedef enum
+ {
+   /* domain 0 = SYS_BASE */
+   CGU_SB_APB0_CLK_ID = 0,
+   CGU_SYS_FIRST = CGU_SB_APB0_CLK_ID,
+   CGU_SB_APB1_CLK_ID,
+   CGU_SB_APB2_CLK_ID,
+   CGU_SB_APB3_CLK_ID,
+   CGU_SB_APB4_CLK_ID,
+   CGU_SB_AHB2INTC_CLK_ID,
+   CGU_SB_AHB0_CLK_ID,
+   CGU_SB_EBI_CLK_ID,
+   CGU_SB_DMA_PCLK_ID,
+   CGU_SB_DMA_CLK_GATED_ID,
+   CGU_SB_NANDFLASH_S0_CLK_ID,
+   CGU_SB_NANDFLASH_ECC_CLK_ID,
+   CGU_SB_NANDFLASH_AES_CLK_ID, /* valid on LPC3153 & LPC3154 only */ 
+   CGU_SB_NANDFLASH_NAND_CLK_ID,
+   CGU_SB_NANDFLASH_PCLK_ID,
+   CGU_SB_CLOCK_OUT_ID,
+   CGU_SB_ARM926_CORE_CLK_ID,
+   CGU_SB_ARM926_BUSIF_CLK_ID,
+   CGU_SB_ARM926_RETIME_CLK_ID,
+   CGU_SB_SD_MMC_HCLK_ID,
+   CGU_SB_SD_MMC_CCLK_IN_ID,
+   CGU_SB_USB_OTG_AHB_CLK_ID,
+   CGU_SB_ISRAM0_CLK_ID,
+   CGU_SB_RED_CTL_RSCLK_ID,
+   CGU_SB_ISRAM1_CLK_ID,
+   CGU_SB_ISROM_CLK_ID,
+   CGU_SB_MPMC_CFG_CLK_ID,
+   CGU_SB_MPMC_CFG_CLK2_ID,
+   CGU_SB_MPMC_CFG_CLK3_ID,
+   CGU_SB_INTC_CLK_ID,
+   CGU_SYS_LAST = CGU_SB_INTC_CLK_ID,
+ 
+   /* domain 1 = AHB0APB0_BASE */
+   CGU_SB_AHB2APB0_ASYNC_PCLK_ID,
+   CGU_AHB0APB0_FIRST = CGU_SB_AHB2APB0_ASYNC_PCLK_ID,
+   CGU_SB_EVENT_ROUTER_PCLK_ID,
+   CGU_SB_ADC_PCLK_ID,
+   CGU_SB_ADC_CLK_ID,
+   CGU_SB_WDOG_PCLK_ID,
+   CGU_SB_IOCONF_PCLK_ID,
+   CGU_SB_CGU_PCLK_ID,
+   CGU_SB_SYSCREG_PCLK_ID,
+   CGU_SB_OTP_PCLK_ID, /* valid on LPC315x series only */
+   CGU_SB_RNG_PCLK_ID,
+   CGU_AHB0APB0_LAST = CGU_SB_RNG_PCLK_ID,
+ 
+ 
+   /* domain 2 = AHB0APB1_BASE */
+   CGU_SB_AHB2APB1_ASYNC_PCLK_ID,
+   CGU_AHB0APB1_FIRST = CGU_SB_AHB2APB1_ASYNC_PCLK_ID,
+   CGU_SB_TIMER0_PCLK_ID,
+   CGU_SB_TIMER1_PCLK_ID,
+   CGU_SB_TIMER2_PCLK_ID,
+   CGU_SB_TIMER3_PCLK_ID,
+   CGU_SB_PWM_PCLK_ID,
+   CGU_SB_PWM_PCLK_REGS_ID,
+   CGU_SB_PWM_CLK_ID,
+   CGU_SB_I2C0_PCLK_ID,
+   CGU_SB_I2C1_PCLK_ID,
+   CGU_AHB0APB1_LAST = CGU_SB_I2C1_PCLK_ID,
+ 
+   /* domain 3 = AHB0APB2_BASE */
+   CGU_SB_AHB2APB2_ASYNC_PCLK_ID,
+   CGU_AHB0APB2_FIRST = CGU_SB_AHB2APB2_ASYNC_PCLK_ID,
+   CGU_SB_PCM_PCLK_ID,
+   CGU_SB_PCM_APB_PCLK_ID,
+   CGU_SB_UART_APB_CLK_ID,
+   CGU_SB_LCD_PCLK_ID,
+   CGU_SB_LCD_CLK_ID,
+   CGU_SB_SPI_PCLK_ID,
+   CGU_SB_SPI_PCLK_GATED_ID,
+   CGU_AHB0APB2_LAST = CGU_SB_SPI_PCLK_GATED_ID,
+ 
+   /* domain 4 = AHB0APB3_BASE */
+   CGU_SB_AHB2APB3_ASYNC_PCLK_ID,
+   CGU_AHB0APB3_FIRST = CGU_SB_AHB2APB3_ASYNC_PCLK_ID,
+   CGU_SB_I2S_CFG_PCLK_ID,
+   CGU_SB_EDGE_DET_PCLK_ID,
+   CGU_SB_I2STX_FIFO_0_PCLK_ID,
+   CGU_SB_I2STX_IF_0_PCLK_ID,
+   CGU_SB_I2STX_FIFO_1_PCLK_ID,
+   CGU_SB_I2STX_IF_1_PCLK_ID,
+   CGU_SB_I2SRX_FIFO_0_PCLK_ID,
+   CGU_SB_I2SRX_IF_0_PCLK_ID,
+   CGU_SB_I2SRX_FIFO_1_PCLK_ID,
+   CGU_SB_I2SRX_IF_1_PCLK_ID,
+   CGU_SB_RSVD69_ID,
+   CGU_SB_AHB2APB3_RSVD_ID,
+   CGU_AHB0APB3_LAST = CGU_SB_AHB2APB3_RSVD_ID,
+ 
+   /* domain 5 = PCM_BASE */
+   CGU_SB_PCM_CLK_IP_ID,
+   CGU_PCM_FIRST = CGU_SB_PCM_CLK_IP_ID,
+   CGU_PCM_LAST = CGU_SB_PCM_CLK_IP_ID,
+ 
+   /* domain 6 = UART_BASE */
+   CGU_SB_UART_U_CLK_ID,
+   CGU_UART_FIRST = CGU_SB_UART_U_CLK_ID,
+   CGU_UART_LAST = CGU_SB_UART_U_CLK_ID,
+ 
+   /* domain 7 = CLK1024FS_BASE */
+   CGU_SB_I2S_EDGE_DETECT_CLK_ID,
+   CGU_CLK1024FS_FIRST = CGU_SB_I2S_EDGE_DETECT_CLK_ID,
+   CGU_SB_I2STX_BCK0_N_ID,
+   CGU_SB_I2STX_WS0_ID,
+   CGU_SB_I2STX_CLK0_ID,
+   CGU_SB_I2STX_BCK1_N_ID,
+   CGU_SB_I2STX_WS1_ID,
+   CGU_SB_CLK_256FS_ID,
+   CGU_SB_I2SRX_BCK0_N_ID,
+   CGU_SB_I2SRX_WS0_ID,
+   CGU_SB_I2SRX_BCK1_N_ID,
+   CGU_SB_I2SRX_WS1_ID,
+   CGU_SB_RSVD84_ID,
+   CGU_SB_RSVD85_ID,
+   CGU_SB_RSVD86_ID,
+   CGU_CLK1024FS_LAST = CGU_SB_RSVD86_ID,
+ 
+   /* domain 8 = BCK0_BASE */
+   CGU_SB_I2SRX_BCK0_ID,
+   CGU_I2SRX_BCK0_FIRST = CGU_SB_I2SRX_BCK0_ID,
+   CGU_I2SRX_BCK0_LAST = CGU_SB_I2SRX_BCK0_ID,
+ 
+   /* domain 9 = BCK1_BASE */
+   CGU_SB_I2SRX_BCK1_ID,
+   CGU_I2SRX_BCK1_FIRST = CGU_SB_I2SRX_BCK1_ID,
+   CGU_I2SRX_BCK1_LAST = CGU_SB_I2SRX_BCK1_ID,
+ 
+   /* domain 10 = SPI_BASE */
+   CGU_SB_SPI_CLK_ID,
+   CGU_SPI_FIRST = CGU_SB_SPI_CLK_ID,
+   CGU_SB_SPI_CLK_GATED_ID,
+   CGU_SPI_LAST = CGU_SB_SPI_CLK_GATED_ID,
+ 
+   /* domain 11 = SYSCLKO_BASE */
+   CGU_SB_SYSCLK_O_ID,
+   CGU_SYSCLK_O_FIRST = CGU_SB_SYSCLK_O_ID,
+   CGU_SYSCLK_O_LAST = CGU_SB_SYSCLK_O_ID,
+ 
+   CGU_SB_INVALID_CLK_ID = -1
+ } CGU_CLOCK_ID_T;
+ 
+ /***********************************************************************
+ * NR of fractional dividers available for each base frequency,
+ * their bit widths and extractions for sub elements from the
+ * fractional divider configuration register
+ ***********************************************************************/
+ #define CGU_SB_BASE0_FDIV_CNT           7
+ #define CGU_SB_BASE0_FDIV_LOW_ID        0
+ #define CGU_SB_BASE0_FDIV_HIGH_ID       6
+ #define CGU_SB_BASE0_FDIV0_W            8
+ 
+ #define CGU_SB_BASE1_FDIV_CNT           2
+ #define CGU_SB_BASE1_FDIV_LOW_ID        7
+ #define CGU_SB_BASE1_FDIV_HIGH_ID       8
+ #define CGU_SB_BASE1_FDIV0_W            8
+ 
+ #define CGU_SB_BASE2_FDIV_CNT           2
+ #define CGU_SB_BASE2_FDIV_LOW_ID        9
+ #define CGU_SB_BASE2_FDIV_HIGH_ID       10
+ #define CGU_SB_BASE2_FDIV0_W            8
+ 
+ #define CGU_SB_BASE3_FDIV_CNT           3
+ #define CGU_SB_BASE3_FDIV_LOW_ID        11
+ #define CGU_SB_BASE3_FDIV_HIGH_ID       13
+ #define CGU_SB_BASE3_FDIV0_W            8
+ 
+ #define CGU_SB_BASE4_FDIV_CNT           1
+ #define CGU_SB_BASE4_FDIV_LOW_ID        14
+ #define CGU_SB_BASE4_FDIV_HIGH_ID       14
+ #define CGU_SB_BASE4_FDIV0_W            8
+ 
+ #define CGU_SB_BASE5_FDIV_CNT           1
+ #define CGU_SB_BASE5_FDIV_LOW_ID        15
+ #define CGU_SB_BASE5_FDIV_HIGH_ID       15
+ #define CGU_SB_BASE5_FDIV0_W            8
+ 
+ #define CGU_SB_BASE6_FDIV_CNT           1
+ #define CGU_SB_BASE6_FDIV_LOW_ID        16
+ #define CGU_SB_BASE6_FDIV_HIGH_ID       16
+ #define CGU_SB_BASE6_FDIV0_W            8
+ 
+ #define CGU_SB_BASE7_FDIV_CNT           6
+ #define CGU_SB_BASE7_FDIV_LOW_ID        17
+ #define CGU_SB_BASE7_FDIV_HIGH_ID       22
+ #define CGU_SB_BASE7_FDIV0_W            13
+ 
+ #define CGU_SB_BASE8_FDIV_CNT           0
+ #define CGU_SB_BASE9_FDIV_CNT           0
+ #define CGU_SB_BASE10_FDIV_CNT          1
+ #define CGU_SB_BASE10_FDIV_LOW_ID       23
+ #define CGU_SB_BASE10_FDIV_HIGH_ID      23
+ #define CGU_SB_BASE10_FDIV0_W           8
+ 
+ #define CGU_SB_BASE11_FDIV_CNT          0
+ 
+ 
+ /* Macro pointing to CGU switch box registers */
+ #define CGU_SB  ((CGU_SB_REGS_T  *)(CGU_SWITCHBOX_BASE))
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_CGU_SB_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_intc_driver.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_intc_driver.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_intc_driver.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_intc_driver.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,502 ----
+ /***********************************************************************
+  * $Id:: lpc313x_intc_driver.c 1180 2008-09-11 19:32:40Z pdurgesh      $
+  *
+  * Project: LPC313X interrupt driver
+  *
+  * Description:
+  *     This file contains driver support for the LPC313X
+  *     interrupt driver.
+  *
+  * Notes:
+  *     This driver requires that the CP15 MMU driver is correctly
+  *     working.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+ ***********************************************************************/
+ 
+ /* CP15 driver for ARM922 & ARM926 is same, hence we will re-use.*/
+ #include "lpc_arm922t_cp15_driver.h"
+ #include "lpc313x_cgu_driver.h"
+ #include "lpc313x_intc_driver.h"
+ 
+ /***********************************************************************
+  * Interrupt driver package data
+ ***********************************************************************/
+ 
+ /* External vector jump addresses - setting one of these addresses with
+    a new address of a function will cause the new function to be called
+    when the interrupt or exception occurs */
+ extern ulong lpc313x_reset_vector;
+ extern ulong vec_reset_handler;
+ extern ulong vec_undefined_handler;
+ extern ulong vec_swi_handler;
+ extern ulong vec_prefetch_handler;
+ extern ulong vec_abort_handler;
+ extern ulong vec_irq_handler;
+ extern ulong vec_fiq_handler;
+ 
+ /* structure to store interrupt controller driver variables */
+ typedef struct
+ {
+   /* indicates the driver init state */
+   ulong init;
+   /* Pointer to logical interrupt vector area (writable) */
+   ulong *vecarea;
+   /* INTC regs pointer*/
+   INTC_REGS_T* pregs;
+ 
+ } INTC_CTRL_DRV_T;
+ 
+ /* Array of Interrupt handlers */
+ PFV g_irq_func_ptrs[IRQ_END_OF_INTERRUPTS + 1];
+ 
+ /* Interrupt controller data structure */
+ INTC_CTRL_DRV_T g_intc_drv;
+ 
+ /***********************************************************************
+  * Vectored Interrupt driver private functions
+ ***********************************************************************/
+ 
+ 
+ /***********************************************************************
+  *
+  * Function: int_write_arm_vec_table
+  *
+  * Purpose: Writes the vector table and jump addresses to vector area
+  *
+  * Processing:
+  *     Copy the shadowed image of the interrupt and exception vector
+  *     table from memory to the vector jump area (usually at location
+  *     0x00000000). Force out any cached values to external memory.
+  *
+  * Parameters: None
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes:
+  *     Ideally, we would check the state of the V bit in the CP15
+  *     coprocessor register 1 to determine the address of the where
+  *     the vector area is located. If that bit was set, the vectors
+  *     would be located at address 0xFFFF0000 instead of 0x00000000.
+  *     This function assumes that the vector area is at 0x00000000.
+  *
+  **********************************************************************/
+ static void int_write_arm_vec_table(void)
+ {
+   ulong *dst, *dstsave, *src;
+   long vecsize;
+   ulong high_vector;
+ 
+   /* If vector address is automatic address, compute address */
+   dst = g_intc_drv.vecarea;
+   if ((ulong) dst == 0xFFFFFFFF)
+   {
+     /* Assume that vector table is located at low vector
+        (0x00000000) address */
+     dst = (ulong *) ARM_RESET_VEC;
+ 
+     /* Check status of high vector bit in MMU control register and
+        set destination address of vector table to high vector
+        address if bit is set */
+     high_vector = cp15_get_mmu_control_reg();
+ 
+     /* If high bit is set, use high vector addresses instead */
+     if ((high_vector & ARM922T_MMU_CONTROL_V) != 0)
+     {
+       dst = (ulong *) 0xFFFF0000;
+     }
+   }
+ 
+   /* Copy vector block to interrupt vector area */
+   dstsave = dst;
+   for (src = (ulong *) & lpc313x_reset_vector;
+        src <= (ulong *) &vec_fiq_handler; src++)
+   {
+     *dst = *src;
+     dst++;
+   }
+ 
+   /* Write out cached vector table to memory */
+   vecsize = ((long) & vec_fiq_handler -
+              (long) & lpc313x_reset_vector) / 4;
+   cp15_force_cache_coherence(dstsave, (dstsave + vecsize));
+ }
+ 
+ 
+ /***********************************************************************
+  * Interrupt driver public functions
+ ***********************************************************************/
+ 
+ /***********************************************************************
+  *
+  * Function: int_initialize
+  *
+  * Purpose: Initialize the interrupt controller
+  *
+  * Processing:
+  *     For all IRQ interrupt sources, clear the dispatcher jump address
+  *     and disable the interrupt in the interrupt controller. Copy the
+  *     vector table and vector branch instructions to the interrupt
+  *     and exception area with a call to int_write_table.
+  *
+  * Parameters:
+  *     vectbladdr: Pointer to interrupt vector area, or 0xFFFFFFFF to
+  *                 have driver determine address
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void int_initialize(ulong vectbladdr)
+ {
+   ulong source;
+ 
+   if (g_intc_drv.init == FALSE)
+   {
+     /* enable clock to interrupt controller */
+     cgu_clk_en_dis(CGU_SB_AHB2INTC_CLK_ID, TRUE);
+     cgu_clk_en_dis(CGU_SB_INTC_CLK_ID, TRUE);
+ 
+     /* Initialize interrupt controller*/
+     g_intc_drv.pregs = INTC;
+ 
+     /* Set the vector base (we don't use direct vectoring, so this is 0) */
+     g_intc_drv.pregs->irq_vec = 0x00000000;
+     g_intc_drv.pregs->fiq_vec = 0x00000000;
+ 
+     /* Set the priority treshold to 0, i.e. don't mask any interrupt */
+     /* on the basis of priority level, for both targets (IRQ/FIQ)    */
+     g_intc_drv.pregs->irq_prio_mask = 0;
+     g_intc_drv.pregs->fiq_prio_mask = 0;
+ 
+     /* Clear the IRQ vector table and disable all interrupts. Start from
+     index 1 since 0 is unused.*/
+     g_irq_func_ptrs[0] = (PFV) NULL;
+     for (source = 1; source <= IRQ_END_OF_INTERRUPTS; source++)
+     {
+       /* Note: start counting from 0 since the first configuration     */
+       /* register in the table corresponds to interrupt request line 1 */
+ 
+       /* Set the initial control values */
+ 
+       /* Initialize as high-active, Disable the interrupt,
+        * Set target to IRQ , Set priority level to 1 (= lowest) for
+        * all the interrupt lines */
+       g_intc_drv.pregs->request[source] =
+         INTC_REQ_WE_ACT_LOW |
+         INTC_REQ_WE_ENABLE |
+         INTC_REQ_TARGET_IRQ |
+         INTC_REQ_PRIO_LVL(1) |
+         INTC_REQ_WE_PRIO_LVL;
+ 
+       g_irq_func_ptrs[source] = (PFV) NULL;
+     }
+ 
+     /* Save user passed vector area pointer */
+     g_intc_drv.vecarea = (ulong *) vectbladdr;
+ 
+     /* write ARM vector table */
+     int_write_arm_vec_table();
+   }
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: int_install_arm_vec_handler
+  *
+  * Purpose: Install an new ARM exception vector handler
+  *
+  * Processing:
+  *     If the passed fiq_handler_ptr pointer is not NULL, then
+  *     set the handler jump address for the specific interrupt or
+  *     exception to handler_ptr.  Recopy the vector table and vector
+  *     branch instructions to the interrupt and exception area with a
+  *     call to int_write_table.
+  *
+  * Parameters:
+  *     handler_id  : Must be an enumeration of type VECTOR_T
+  *     handler_ptr : Pointer to new interrupt or exception handler
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void int_install_arm_vec_handler(VECTOR_T handler_id,
+                                  PFV handler_ptr)
+ {
+   /* Update address only if it is not NULL */
+   if (handler_ptr != (PFV) NULL)
+   {
+     switch (handler_id)
+     {
+       case RESET_VEC:
+         vec_reset_handler = (ulong) handler_ptr;
+         cp15_force_cache_coherence(
+           (ulong *) &vec_reset_handler,
+           (ulong *) &vec_reset_handler);
+         break;
+ 
+       case UNDEFINED_INST_VEC:
+         vec_undefined_handler = (ulong) handler_ptr;
+         cp15_force_cache_coherence(
+           (ulong *) &vec_undefined_handler,
+           (ulong *) &vec_undefined_handler);
+         break;
+ 
+       case SWI_VEC:
+         vec_swi_handler = (ulong) handler_ptr;
+         cp15_force_cache_coherence(
+           (ulong *) &vec_swi_handler,
+           (ulong *) &vec_swi_handler);
+         break;
+ 
+       case PREFETCH_ABORT_VEC:
+         vec_prefetch_handler = (ulong) handler_ptr;
+         cp15_force_cache_coherence(
+           (ulong *) &vec_prefetch_handler,
+           (ulong *) &vec_prefetch_handler);
+         break;
+ 
+       case DATA_ABORT_VEC:
+         vec_abort_handler = (ulong) handler_ptr;
+         cp15_force_cache_coherence(
+           (ulong *) &vec_abort_handler,
+           (ulong *) &vec_abort_handler);
+         break;
+ 
+       case IRQ_VEC:
+         vec_irq_handler = (ulong) handler_ptr;
+         cp15_force_cache_coherence(
+           (ulong *) &vec_irq_handler,
+           (ulong *) &vec_irq_handler);
+         break;
+ 
+       case FIQ_VEC:
+         vec_fiq_handler = (ulong) handler_ptr;
+         cp15_force_cache_coherence(
+           (ulong *) &vec_fiq_handler,
+           (ulong *) &vec_fiq_handler);
+         break;
+ 
+       default:
+         break;
+     }
+ 
+     /* Update ARM vector table */
+     int_write_arm_vec_table();
+   }
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: int_install_irq_handler
+  *
+  * Purpose: Install an IRQ interrupt handler for an internal interrupt
+  *
+  * Processing:
+  *     For the selected interrupt, sets the function called as the
+  *     passed value.
+  *
+  * Parameters:
+  *     source   : Interrupt source of type INTERRUPT_SOURCE_T
+  *     func_ptr : Pointer to a void function
+  *
+  * Outputs: None
+  *
+  * Returns: Returns TRUE or FALSE.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ ulong int_install_irq_handler(INTERRUPT_SOURCE_T source,
+                                 PFV func_ptr)
+ {
+   ulong ret_value = FALSE;
+ 
+   if (source <= IRQ_END_OF_INTERRUPTS)
+   {
+     g_irq_func_ptrs[source] = func_ptr;
+     ret_value = TRUE;
+   }
+   return ret_value;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: int_enable
+  *
+  * Purpose: Enable an interrupt
+  *
+  * Processing:
+  *     Enables the interrupt in the controller for the selected source.
+  *
+  * Parameters:
+  *     source   : Interrupt source of type INTERRUPT_SOURCE_T
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void int_enable(INTERRUPT_SOURCE_T source)
+ {
+   g_intc_drv.pregs->request[source] = INTC_REQ_ENABLE | INTC_REQ_WE_ENABLE;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: int_disable
+  *
+  * Purpose: Disable an interrupt
+  *
+  * Processing:
+  *     Masks the interrupt in the controller for the selected source.
+  *
+  * Parameters:
+  *     source   : Interrupt source of type INTERRUPT_SOURCE_T
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void int_disable(INTERRUPT_SOURCE_T source)
+ {
+   g_intc_drv.pregs->request[source] = INTC_REQ_WE_ENABLE;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: int_pending
+  *
+  * Purpose: Check to see if a unmasked interrupt is pending
+  *
+  * Processing:
+  *     If the status for the selected interrupt source is set,
+  *     a TRUE is returned. Otherwise, FALSE is returned.
+  *
+  * Parameters:
+  *     source   : Interrupt source of type INTERRUPT_SOURCE_T
+  *
+  * Outputs: None
+  *
+  * Returns: Returns TRUE or FALSE.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ ulong int_pending(INTERRUPT_SOURCE_T source)
+ {
+   return (g_intc_drv.pregs->request[source] & INTC_REQ_PEND);
+ }
+ 
+ 
+ /***********************************************************************
+  *
+  * Function: int_enabled
+  *
+  * Purpose: Check to see if an interrupt is enabled
+  *
+  * Processing:
+  *     If the selected interrupt source is enabled, a TRUE is returned.
+  *     Otherwise, FALSE is returned.
+  *
+  * Parameters:
+  *     source   : Interrupt source of type INTERRUPT_SOURCE_T
+  *
+  * Outputs: None
+  *
+  * Returns: Returns TRUE or FALSE.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ ulong int_enabled(INTERRUPT_SOURCE_T source)
+ {
+   return (g_intc_drv.pregs->request[source] & INTC_REQ_ENABLE);
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: int_clear
+  *
+  * Purpose: Clear a pending (latched) interrupt
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     source   : Interrupt source of type INTERRUPT_SOURCE_T
+  *
+  * Outputs: None
+  *
+  * Returns: Returns TRUE or FALSE.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ ulong int_clear(INTERRUPT_SOURCE_T source)
+ {
+   g_intc_drv.pregs->request[source] = INTC_REQ_CLR_SWINT;
+ 
+   return TRUE;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: int_setup_irq_fiq
+  *
+  * Purpose: Setup an interrupt as an IRQ (FALSE) or and FIQ (TRUE)
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     source  : Interrupt source of type INTERRUPT_SOURCE_T
+  *     use_fiq : TRUE to use an FIQ interrupt type, FALSE for IRQ
+  *
+  * Outputs: None
+  *
+  * Returns: Returns TRUE or FALSE.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ ulong int_setup_irq_fiq(INTERRUPT_SOURCE_T source,
+                           ulong use_fiq)
+ {
+   if (use_fiq == TRUE)
+   {
+     /* FIQ interrupt type */
+     g_intc_drv.pregs->request[source] = INTC_REQ_TARGET_FIQ;
+   }
+   else
+   {
+     /* IRQ interrupt type */
+     g_intc_drv.pregs->request[source] = INTC_REQ_TARGET_IRQ;
+   }
+ 
+   return TRUE;
+ }
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_intc_driver.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_intc_driver.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_intc_driver.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_intc_driver.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,87 ----
+ /***********************************************************************
+  * $Id:: lpc313x_intc_driver.h 1342 2008-11-24 20:25:40Z pdurgesh      $
+  *
+  * Project: LPC313X interrupt driver
+  *
+  * Description:
+  *     This file contains driver support for the LPC32xx interrupt
+  *     driver.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  *********************************************************************/
+ 
+ #ifndef LPC313X_INTC_DRIVER_H
+ #define LPC313X_INTC_DRIVER_H
+ 
+ #include "lpc313x_intc.h"
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+  * Interrupt driver enums & structures
+  **********************************************************************/
+ /* ARM exception vector enumerations */
+ typedef enum
+ {
+   RESET_VEC,
+   UNDEFINED_INST_VEC,
+   SWI_VEC,
+   PREFETCH_ABORT_VEC,
+   DATA_ABORT_VEC,
+   IRQ_VEC,
+   FIQ_VEC
+ } VECTOR_T;
+ 
+ 
+ /***********************************************************************
+  * Interrupt driver functions
+  **********************************************************************/
+ 
+ /* Initialize the interrupt controller */
+ void int_initialize(ulong vectbladdr);
+ 
+ /* Install an new ARM exception vector handler */
+ void int_install_arm_vec_handler(VECTOR_T handler_id,
+                                  PFV handler_ptr);
+ 
+ /* Install an IRQ interrupt function for an internal interrupt */
+ ulong int_install_irq_handler(INTERRUPT_SOURCE_T source,
+                                 PFV func_ptr);
+ 
+ /* Enable an interrupt */
+ void int_enable(INTERRUPT_SOURCE_T source);
+ 
+ /* Disable an interrupt */
+ void int_disable(INTERRUPT_SOURCE_T source);
+ 
+ /* Check to see if a unmasked interrupt is pending */
+ ulong int_pending(INTERRUPT_SOURCE_T source);
+ 
+ /* Check to see if an interrupt is enabled */
+ ulong int_enabled(INTERRUPT_SOURCE_T source);
+ 
+ /* Clear a pending (latched) interrupt */
+ ulong int_clear(INTERRUPT_SOURCE_T source);
+ 
+ /* Setup an interrupt as an IRQ (FALSE) or and FIQ (TRUE) */
+ ulong int_setup_irq_fiq(INTERRUPT_SOURCE_T source,
+                           ulong use_fiq);
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_INTC_DRIVER_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_intc.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_intc.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_intc.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_intc.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,141 ----
+ /***********************************************************************
+ * $Id:: lpc313x_intc.h 1180 2008-09-11 19:32:40Z pdurgesh             $
+ *
+ * Project: LPC313X interrupt controller definitions
+ *
+ * Description:
+ *     This file contains the structure definitions and manifest
+ *     constants for the LPC313X chip family component:
+ *         Interrupt Controller
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+ 
+ #ifndef LPC313X_INTC_H
+ #define LPC313X_INTC_H
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+ * Interrupt controller Register Structures
+ **********************************************************************/
+ 
+ /* Interrupt Controller Module Register Structure */
+ typedef volatile struct
+ {
+   volatile ulong irq_prio_mask; // IRQ priority threshold
+   volatile ulong fiq_prio_mask; // FIQ priority threshold
+   volatile ulong dummy0[62];
+   volatile ulong irq_vec;    // IRQ vector
+   volatile ulong fiq_vec;    // FIQ vector
+   volatile ulong dummy1[62];
+   volatile ulong pending;    // Status of interrupt request   1.. 31
+   volatile ulong dummy2[63];
+   volatile ulong features;   // Interrupt Controller config features
+   volatile ulong dummy3[63];
+   volatile ulong request[30];
+   volatile ulong dummy4[737];
+   volatile ulong modId;
+ } INTC_REGS_T;
+ 
+ /***********************************************************************
+ * Interrupt source defines & enumerations
+ **********************************************************************/
+ /* Interrupt source enumerations */
+ typedef enum
+ {
+   /* main interrupts */
+   IRQ_EVT_ROUTER0 = 1,      /*interrupts from Event router 0*/
+   IRQ_EVT_ROUTER1,          /*interrupts from Event router 1*/
+   IRQ_EVT_ROUTER2,          /*interrupts from Event router 2*/
+   IRQ_EVT_ROUTER3,          /*interrupts from Event router 3*/
+   IRQ_TIMER0,               /*Timer 0 IRQ */
+   IRQ_TIMER1,               /*Timer 1 IRQ */
+   IRQ_TIMER2,               /*Timer 2 IRQ */
+   IRQ_TIMER3,               /*Timer 3 IRQ */
+   IRQ_ADC,                  /*10bit ADC irq*/
+   IRQ_UART,                 /*UART irq */
+   IRQ_I2C0,                 /*I2C 0 IRQ */
+   IRQ_I2C1,                 /*I2C 1 IRQ */
+   IRQ_I2S0_OUT,             /*I2S 0 out IRQ */
+   IRQ_I2S1_OUT,             /*I2S 1 out IRQ */
+   IRQ_I2S0_IN,              /*I2S 0 IN IRQ */
+   IRQ_I2S1_IN,              /*I2S 1 IN IRQ */
+   IRQ_RSVD1,
+   IRQ_LCD = 18,             /*LCD irq */
+   IRQ_SPI_SMS,              /*SPI SMS IRQ */
+   IRQ_SPI_TX,               /*SPI Transmit IRQ */
+   IRQ_SPI_RX,               /*SPI Receive IRQ */
+   IRQ_SPI_OVR,              /*SPI overrun IRQ */
+   IRQ_SPI,                  /*SPI interrupt IRQ */
+   IRQ_DMA,                  /*DMA irq */
+   IRQ_NAND_FLASH,           /*NAND flash irq */
+   IRQ_MCI,                  /*MCI irq */
+   IRQ_USB,                  /*USB irq */
+   IRQ_ISRAM0,               /*ISRAM0 irq */
+   IRQ_ISRAM1,               /*ISRAM1 irq */
+   IRQ_END_OF_INTERRUPTS = IRQ_ISRAM1
+ } INTERRUPT_SOURCE_T;
+ 
+ /***********************************************************************
+  * Priority mask register definitions
+  **********************************************************************/
+ #define INTC_PRIO_LIMIT_MSK   0xFF
+ 
+ /***********************************************************************
+  * Vector register definitions
+  **********************************************************************/
+ #define INTC_VEC_TBL_ADR(n)   ((n) & ~(0x3FF))
+ #define INTC_VEC_GET_INDEX(n) (((n) >> 3) & 0xFF)
+ #define INTC_VEC_INDEX_MSK    _SBF(3, 0xFF)
+ 
+ /***********************************************************************
+  * pending register definitions
+  **********************************************************************/
+ #define INTC_PEND_GET(n)      _BIT(((n) & (0x1F)))
+ 
+ /***********************************************************************
+  * Request register definitions
+  **********************************************************************/
+ #define INTC_REQ_PEND         _BIT(31)
+ #define INTC_REQ_SET_SWINT    _BIT(30)
+ #define INTC_REQ_CLR_SWINT    _BIT(29)
+ #define INTC_REQ_WE_PRIO_LVL  _BIT(28)
+ #define INTC_REQ_WE_TARGET    _BIT(27)
+ #define INTC_REQ_WE_ENABLE    _BIT(26)
+ #define INTC_REQ_WE_ACT_LOW   _BIT(25)
+ 
+ #define INTC_REQ_ACT_LOW      _BIT(17)
+ #define INTC_REQ_ENABLE       _BIT(16)
+ #define INTC_REQ_TARGET(n)    _SBF(8, ((n) & 0x3F))
+ #define INTC_REQ_PRIO_LVL(n)  ((n) & 0xFF)
+ #define INTC_REQ_TARGET_IRQ   (INTC_REQ_WE_TARGET)
+ #define INTC_REQ_TARGET_FIQ   (INTC_REQ_WE_TARGET | _BIT(8))
+ 
+ 
+ /**********************************************************************
+ * Macro to access WDT registers
+ **********************************************************************/
+ #define INTC        ((INTC_REGS_T*)INTC_BASE)
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_INTC_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_ioconf_driver.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_ioconf_driver.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_ioconf_driver.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_ioconf_driver.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,81 ----
+ /***********************************************************************
+  * $Id:: lpc313x_ioconf_driver.h 1338 2008-11-20 23:03:38Z pdurgesh    $
+  *
+  * Project: LPC313X GPIO driver
+  *
+  * Description:
+  *     This file contains driver support for the LPC313X GPIO block.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  *********************************************************************/
+ 
+ #ifndef LPC313X_IOCONF_DRIVER_H
+ #define LPC313X_IOCONF_DRIVER_H
+ 
+ #include "lpc313x_ioconf.h"
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ 
+ /***********************************************************************
+  * GPIO driver functions
+  **********************************************************************/
+ 
+ /* Returns current input states of the input pin */
+ static __inline ulong gpio_get_pin_state(IOCONF_BLOCK_T gpio_block, ulong bitnum)
+ {
+   /* If high, return TRUE. If low, return FALSE */
+   return (IOCONF->block[gpio_block].pins & _BIT(bitnum));
+ }
+ 
+ /* Sets GPIO pin as input pin */
+ static __inline void gpio_set_as_input(IOCONF_BLOCK_T gpio_block, ulong bitnum)
+ {
+   IOCONF->block[gpio_block].mode1_clear = _BIT(bitnum);
+   IOCONF->block[gpio_block].mode0_clear = _BIT(bitnum);
+ }
+ 
+ /* Sets GPIO output pin to high state */
+ static __inline void gpio_set_outpin_high(IOCONF_BLOCK_T gpio_block, ulong bitnum)
+ {
+   IOCONF->block[gpio_block].mode1_set = _BIT(bitnum);
+   IOCONF->block[gpio_block].mode0_set = _BIT(bitnum);
+ }
+ 
+ /* Sets GPIO output pin to high state */
+ static __inline void gpio_set_outpin_low(IOCONF_BLOCK_T gpio_block, ulong bitnum)
+ {
+   IOCONF->block[gpio_block].mode1_set = _BIT(bitnum);
+   IOCONF->block[gpio_block].mode0_clear = _BIT(bitnum);
+ }
+ 
+ /* Sets GPIO/MUX pin as driven by IP pin */
+ static __inline void gpio_set_as_ip_driven(IOCONF_BLOCK_T gpio_block, ulong bitnum)
+ {
+   IOCONF->block[gpio_block].mode1_clear = _BIT(bitnum);
+   IOCONF->block[gpio_block].mode0_set = _BIT(bitnum);
+ }
+ 
+ /***********************************************************************
+  * IOCONF Pin muxing driver functions
+  **********************************************************************/
+ 
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_IOCONF_DRIVER_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_ioconf.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_ioconf.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_ioconf.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_ioconf.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,91 ----
+ /***********************************************************************
+ * $Id:: lpc313x_ioconf.h 1180 2008-09-11 19:32:40Z pdurgesh           $
+ *
+ * Project: LPC313X IO Configuration (IOCONF) controller definitions
+ *
+ * Description:
+ *     This file contains the structure definitions and manifest
+ *     constants for the LPC313X chip family component:
+ *         IO Configuration (IOCONF) controller
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+ 
+ #ifndef LPC313X_IOCONF_H
+ #define LPC313X_IOCONF_H
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+ * IO Configuration (IOCONF) controller Register Structures
+ **********************************************************************/
+ 
+ /* IOCONF Function Block Register Structure */
+ typedef volatile struct
+ {
+   volatile ulong pins;         /* R- 0x00 : current status of pins */
+   volatile ulong _d1[3];
+   volatile ulong mode0;        /* RW 0x10 : */
+   volatile ulong mode0_set;    /* RW 0x14 : */
+   volatile ulong mode0_clear;  /* RW 0x18 : */
+   volatile ulong _d2[1];
+   volatile ulong mode1;        /* RW 0x20 : */
+   volatile ulong mode1_set;    /* RW 0x24 : */
+   volatile ulong mode1_clear;  /* RW 0x28 : */
+   volatile ulong _d3[5];
+ } IOCONF_FUNC_REGS_T;
+ 
+ /* IOCONF Register Structure */
+ typedef volatile struct
+ {
+   IOCONF_FUNC_REGS_T block[13];
+ } IOCONF_REGS_T;
+ 
+ typedef enum
+ {
+   IOCONF_MUX0,
+   IOCONF_MUX1,
+   IOCONF_CGU,
+   IOCONF_DAI0,
+   IOCONF_DAI1,
+   IOCONF_DAO1,
+   IOCONF_EBI,
+   IOCONF_GPIO,
+   IOCONF_I2C1,
+   IOCONF_SPI,
+   IOCONF_NAND_CTRL,
+   IOCONF_PWM,
+   IOCONF_UART
+ } IOCONF_BLOCK_T;
+ 
+ /**********************************************************************
+ *  GPIO PIN defines
+ **********************************************************************/
+ 
+ 
+ /**********************************************************************
+ * Macro to access IOCONF registers
+ **********************************************************************/
+ #define IOCONF      ((IOCONF_REGS_T*)IOCONF_BASE)
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_IOCONF_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_mci_driver.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_mci_driver.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_mci_driver.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_mci_driver.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,1194 ----
+ /***********************************************************************
+ * $Id:: lpc313x_mci_driver.c 1311 2008-11-04 19:34:54Z pdurgesh       $
+ *
+ * Project: LPC313x SD/MMC/SDIO controller driver
+ *
+ * Description:
+ *     This file contains driver support for the LPC313x SD/MMC/SDIO
+ *     controller.
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ *********************************************************************/
+ #include "lpc_sdmmc.h"
+ #include "lpc313x_sysreg.h"
+ #include "lpc313x_ioconf_driver.h"
+ #include "lpc313x_cgu_driver.h"
+ #include "lpc313x_timer_driver.h"
+ #include "mmc.h"
+ 
+ #ifdef CONFIG_MMC
+ 
+ //#define USE_WIDE    /* Allow WIDE mode */
+ #define US_TIMEOUT 1000000 /* give 1 atleast 1 sec for the card to respond */
+ #define MS_ACQUIRE_DELAY	(10)/* inter-command acquire oper condition delay in msec*/
+ #define INIT_OP_RETRIES   10  /* initial OP_COND retries */
+ #define SET_OP_RETRIES    200 /* set OP_COND retries */
+ 
+ /* global instance of the current card*/
+ static MCI_CARD_INFO_T g_card_info;
+ block_dev_desc_t mmc_dev;
+ 
+ /***********************************************************************
+  * MCI driver private functions
+  **********************************************************************/
+ 
+ /***********************************************************************
+  *
+  * Function: prv_card_acquired
+  *
+  * Purpose: Checks whether card is acquired properly or not.
+  *
+  * Processing:
+  *     Check if a valid CID data is present for the card.
+  *
+  * Parameters:
+  *     pdev: Pointer to card info structure
+  *
+  * Outputs: None
+  *
+  * Returns: 1 is card is enumerated else return 0.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static ulong prv_card_acquired(MCI_CARD_INFO_T* pdev)
+ {
+   return (pdev->cid[0] != 0);
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: prv_get_bits
+  *
+  * Purpose: Helper function to get a bit field withing multi-word
+  *  buffer. Used to get fields with-in CSD & EXT-CSD structures.
+  *
+  * Processing:
+  *     Based bit position computes the 32 word index with buffer and
+  *  extracts the bit field value. The function takes care of bit fieds
+  *  which cross the word boundary.
+  *
+  * Parameters:
+  *     start: Start position of the bit field
+  *     end  : Start position of the bit field
+  *     data : Pointer to buffer
+  *
+  * Outputs: None
+  *
+  * Returns: The bit field value.
+  *
+  * Notes:
+  *  The function assumes max. of 32 bi per bit field. For bit fields
+  *  above 32-bit shouldn't use this function.
+  *
+  **********************************************************************/
+ static ulong prv_get_bits(int start, int end, ulong* data)
+ {
+   ulong v;
+   ulong i = end >> 5;
+   ulong j = start & 0x1f;
+ 
+   if (i == (start >> 5))
+     v = (data[i] >> j);
+   else
+     v = ((data[i] << (32 - j)) | (data[start >> 5] >> j));
+ 
+   return (v & ((1 << (end - start + 1)) - 1));
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: prv_clear_all
+  *
+  * Purpose: Clears the FIFOs, response and data, and the interrupt status.
+  *
+  * Processing:
+  *     clears the FIFOs, response and data, and the interrupt status.
+  *
+  * Parameters: None
+  *
+  * Outputs: None
+  *
+  * Returns: None
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static void prv_clear_all(void)
+ {
+   /* reset all blocks */
+   MCI->ctrl |= MCI_CTRL_FIFO_RESET;
+   /* wait till resets clear */
+   while (MCI->ctrl & MCI_CTRL_FIFO_RESET);
+ 
+   /* Clear interrupt status */
+   MCI->rintsts = 0xFFFFFFFF;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: prv_send_cmd
+  *
+  * Purpose: Function to send command to Card interface unit (CIU).
+  *
+  * Processing:
+  *     Send command to Card interface unit (CIU).
+  *
+  * Parameters:
+  *     cmd  : Command with all flags set.
+  *     arg  : Argument for the command
+  *
+  * Outputs: None
+  *
+  * Returns: 1 if times-out.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static int prv_send_cmd(ulong cmd, ulong arg)
+ {
+   volatile int tmo = 50;
+   volatile int delay;
+   /* set command arg reg*/
+   MCI->cmdarg = arg;
+   MCI->cmd = MCI_CMD_START | cmd;
+ 
+   /* poll untill command is accepted by the CIU */
+   while (--tmo && (MCI->cmd & MCI_CMD_START))
+   {
+     if (tmo & 1)
+       delay = 50;
+     else
+       delay = 18000;
+ 
+     while (--delay > 1);
+   }
+ 
+   return (tmo < 1) ? 1 : 0;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: prv_set_clock
+  *
+  * Purpose: Function to set speed of the clock going to card.
+  *
+  * Processing:
+  *     Sets speed of the clock going to external card.
+  *
+  * Parameters:
+  *     speed  : Clock speed.
+  *
+  * Outputs: None
+  *
+  * Returns: None.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static void prv_set_clock(ulong speed)
+ {
+   /* compute SD/MMC clock dividers */
+   ulong mmc_clk = cgu_get_clk_freq(CGU_SB_SD_MMC_CCLK_IN_ID);
+   ulong div = ((mmc_clk / speed) + 2) >> 1;
+ 
+   if ((div == MCI->clkdiv) && MCI->clkena)
+     return; /* requested speed is already set */
+ 
+   /* disable clock */
+   MCI->clkena = 0;
+   MCI->clksrc = 0;
+ 
+   /* inform CIU */
+   prv_send_cmd(MCI_CMD_UPD_CLK | MCI_CMD_PRV_DAT_WAIT, 0);
+ 
+   /* set clock to desired speed */
+   MCI->clkdiv = div;
+   /* inform CIU */
+   prv_send_cmd(MCI_CMD_UPD_CLK | MCI_CMD_PRV_DAT_WAIT, 0);
+ 
+   /* enable clock */
+   MCI->clkena = MCI_CLKEN_ENABLE;
+   /* inform CIU */
+   prv_send_cmd(MCI_CMD_UPD_CLK | MCI_CMD_PRV_DAT_WAIT, 0);
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: prv_pull_response
+  *
+  * Purpose: Function to retrieve command response.
+  *
+  * Processing:
+  *     Retrieves a command response.
+  *
+  * Parameters:
+  *     pdev: Pointer to card info structure
+  *     length  : the length of the expected response, in bits.
+  *
+  * Outputs: None
+  *
+  * Returns: None.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static void prv_pull_response(MCI_CARD_INFO_T* pdev, int length)
+ {
+   
+   /* on this chip response is not a fifo so read all 4 regs */
+   pdev->response[0] = MCI->resp0;
+   pdev->response[1] = MCI->resp1;
+   pdev->response[2] = MCI->resp2;
+   pdev->response[3] = MCI->resp3;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: prv_pull_data
+  *
+  * Purpose: Function to read data from the FIFO.
+  *
+  * Processing:
+  *     Reads the data from fifo.
+  *
+  * Parameters:
+  *     pv: Pointer to buffer
+  *     cnt  : the length of the expected data, in bytes.
+  *
+  * Outputs: None
+  *
+  * Returns: None.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static int prv_pull_data(unsigned char* pv, int cnt)
+ {
+   int j,i = 0;
+   int fcnt;
+ 
+   volatile ulong * pFifo = (ulong *)0x18000100; 
+   ulong *pBuffer = (ulong *)pv;
+   
+   while (i < cnt)
+   {
+     fcnt = MCI_STS_GET_FCNT(MCI->status);
+ 	for(j=0;j<fcnt;j++)
+ 		*pBuffer++ = pFifo[j];
+ 
+     i += (fcnt * 4);
+   }
+   return i;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: prv_push_data
+  *
+  * Purpose: Function to write data to the FIFO.
+  *
+  * Processing:
+  *     Writes the data to fifo.
+  *
+  * Parameters:
+  *     pv: Pointer to buffer
+  *     cnt  : the length of the expected data, in bytes.
+  *
+  * Outputs: None
+  *
+  * Returns: None.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static void prv_push_data(const unsigned char* pv, ulong cb)
+ {
+   int i = 0;
+   int fcnt;
+ 
+   while (i < cb)
+   {
+     fcnt = MCI_FIFO_SZ - (MCI_STS_GET_FCNT(MCI->status) << 2);
+     memcpy((void*)&MCI->data, pv + i, fcnt);
+     i += fcnt;
+   }
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: prv_wait_for_completion
+  *
+  * Purpose: Polls for command completion.
+  *
+  * Processing:
+  *     Appends additional error flags to the status bits requested by
+  *  the caller. And invokes the busy poll routine or wait_func set by
+  *  the application.
+  *
+  * Parameters:
+  *     pdev : Pointer to card info structure
+  *     bit  : Status bits to poll for command completion.
+  *
+  * Outputs: None
+  *
+  * Returns: Status of the command.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static ulong prv_wait_for_completion(MCI_CARD_INFO_T* pdev, ulong bits)
+ {
+   ulong status = 0;
+   int tmo_count = 10;
+ 
+   /* also check error conditions */
+   bits |= MCI_INT_EBE | MCI_INT_SBE | MCI_INT_HLE
+           | MCI_INT_RTO | MCI_INT_RCRC | MCI_INT_RESP_ERR;
+ 
+   if (bits & MCI_INT_DATA_OVER)
+     bits |= MCI_INT_FRUN | MCI_INT_HTO | MCI_INT_DTO
+             | MCI_INT_DCRC;
+ 
+   if (pdev->wait_func == NULL)
+   {
+     /* do busy polling when wait_func is not set*/
+     do
+     {
+       //timer_wait_us(NULL, 1);
+       udelay(5000);
+       status = MCI->rintsts;
+ 
+       if (--tmo_count < 1)
+       {
+         break;
+       }
+     }
+     while ((status  & bits) == 0);
+     /* set time out flag for driver timeout also */
+     status |= ((tmo_count < 1) ? MCI_INT_RTO : 0);
+   }
+   else
+   {
+     /* call wait function set by application */
+     status = pdev->wait_func(pdev, bits);
+   }
+ 
+   return status;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: prv_process_csd
+  *
+  * Purpose: Function to process the CSD & EXT-CSD of the card.
+  *
+  * Processing:
+  *     Computes the card paramaters such as size, read block length,
+  * 	 no. of blocks etc. based on cards CSD & EXT-CSD response.
+  *
+  * Parameters:
+  *     pdev: Pointer to card info structure
+  *
+  * Outputs: None
+  *
+  * Returns: None.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static void prv_process_csd(MCI_CARD_INFO_T* pdev)
+ {
+   long status = 0;
+   long c_size = 0;
+   long c_size_mult = 0;
+   long mult = 0;
+ 
+   /* compute block length based on CSD response */
+   pdev->block_len = 1 << prv_get_bits(80, 83, pdev->csd);
+ 
+   if ((pdev->card_type & CARD_TYPE_HC) &&
+       (pdev->card_type & CARD_TYPE_SD))
+   {
+     /* See section 5.3.3 CSD Register (CSD Version 2.0) of SD2.0 spec
+     an explanation for the calculation of these values
+     */
+     c_size = prv_get_bits(48, 63, (ulong*)pdev->csd) + 1;
+     pdev->blocknr = c_size << 10; /* 512 byte blocks */
+   }
+   else
+   {
+     /* See section 5.3 of the 4.1 revision of the MMC specs for
+     an explanation for the calculation of these values
+     */
+     c_size = prv_get_bits(62, 73, (ulong*)pdev->csd);
+     c_size_mult = prv_get_bits(47, 49, (ulong*)pdev->csd); //csd_c_size_mult ();
+     mult = 1 << (c_size_mult + 2);
+     pdev->blocknr = (c_size + 1) * mult;
+     /* adjust blocknr to 512/block */
+     if (pdev->block_len > MMC_SECTOR_SIZE)
+       pdev->blocknr = pdev->blocknr * (pdev->block_len >> 9);
+ 
+     /* get extended CSD for newer MMC cards CSD spec >= 4.0*/
+     if (((pdev->card_type & CARD_TYPE_SD) == 0) &&
+         (prv_get_bits(122, 125, (ulong*)pdev->csd) >= 4))
+     {
+ 
+       ulong ext_csd[MMC_SECTOR_SIZE/4];
+ 
+       /* put card in trans state */
+       status = mci_execute_command(pdev, CMD_SELECT_CARD, pdev->rca << 16, 0);
+       /* set block size and byte count */
+       MCI->blksiz = MMC_SECTOR_SIZE;
+       MCI->bytcnt = MMC_SECTOR_SIZE;
+       /* send EXT_CSD command */
+       status = mci_execute_command(pdev, CMD_SEND_EXT_CSD, 0, MCI_INT_CMD_DONE
+                                    | MCI_INT_DATA_OVER | MCI_INT_RXDR);
+ 
+       if ((status & MCI_INT_ERROR) == 0)
+       {
+         /* read 52bytes EXT-CSD data */
+         prv_pull_data((unsigned char*)ext_csd, MMC_SECTOR_SIZE);
+ 
+         /* check EXT_CSD_VER is greater than 1.1 */
+         if ((ext_csd[48] & 0xFF) > 1)
+           pdev->blocknr = ext_csd[53]; /* bytes 212:215 represent sec count */
+ 
+         /* switch to 52MHz clock if card type is set to 1 or else set to 26MHz */
+         if ((ext_csd[49] & 0xFF) == 1)
+         {
+           /* for type 1 MMC cards high speed is 52MHz */
+           pdev->speed = MMC_HIGH_BUS_MAX_CLOCK;
+         }
+         else
+         {
+           /* for type 0 MMC cards high speed is 26MHz */
+           pdev->speed = MMC_LOW_BUS_MAX_CLOCK;
+         }
+       }
+     }
+   }
+ 
+   pdev->device_size = pdev->blocknr << 9; /* blocknr * 512 */
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: prv_set_trans_state
+  *
+  * Purpose: Puts current selected card in trans state
+  *
+  * Processing:
+  *     Puts current selected card in trans state
+  *
+  * Parameters:
+  *     pdev: Pointer to card info structure
+  *
+  * Outputs: None
+  *
+  * Returns: Error if unable to put card in trans state.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static int prv_set_trans_state(MCI_CARD_INFO_T* pdev)
+ {
+   ulong status;
+ 
+   /* get current state of the card */
+   status = mci_execute_command(pdev, CMD_SEND_STATUS, pdev->rca << 16, 0);
+   if (status & MCI_INT_RTO)
+   {
+     /* unable to get the card state. So return immediatly. */
+     return _ERROR;
+   }
+   /* check card state in response */
+   status = R1_CURRENT_STATE(pdev->response[0]);
+   switch (status)
+   {
+   case SDMMC_STBY_ST:
+     /* put card in 'Trans' state */
+     status = mci_execute_command(pdev, CMD_SELECT_CARD, pdev->rca << 16, 0);
+     if (status != 0)
+     {
+       /* unable to put the card in Trans state. So return immediatly. */
+       return _ERROR;
+     }
+     break;
+   case SDMMC_TRAN_ST:
+     /*do nothing */
+     break;
+   default:
+     /* card shouldn't be in other states so return */
+     return _ERROR;
+   }
+ 
+ #if defined (USE_WIDE)
+   if (pdev->card_type & CARD_TYPE_SD)
+   {
+     mci_execute_command(pdev, CMD_SD_SET_WIDTH, 2, 0);  /* SD, 4 bit width */
+     /* if positive response */
+     MCI->ctype = MCI_CTYPE_4BIT;
+   }
+ #endif
+ 
+   /* set block length */
+   MCI->blksiz = MMC_SECTOR_SIZE;
+   status = mci_execute_command(pdev, CMD_SET_BLOCKLEN, MMC_SECTOR_SIZE, 0);
+ 
+   return _NO_ERROR;
+ }
+ 
+ /***********************************************************************
+  * MCI driver public functions
+  **********************************************************************/
+ 
+ /***********************************************************************
+  *
+  * Function: mci_execute_command
+  *
+  * Purpose: Function to execute a command.
+  *
+  * Processing:
+  *     Send the requested command to the card and retrieve the response.
+  *
+  * Parameters:
+  *     pdev: Pointer to card info structure
+  *     cmd  : Command with all flags set.
+  *     arg  : Argument for the command
+  *     wait_status  : Status bits to poll for command completion.
+  *
+  * Outputs: None
+  *
+  * Returns: Zero on success. Else returns the status register on error.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ long mci_execute_command(MCI_CARD_INFO_T* pdev,
+                            ulong cmd,
+                            ulong arg,
+                            ulong wait_status)
+ {
+   /* if APP command there are 2 stages */
+   int step = (cmd & CMD_BIT_APP) ? 2 : 1;
+   long status = 0;
+   ulong cmd_reg = 0;
+ 
+   if (!wait_status)
+     wait_status = (cmd & CMD_MASK_RESP) ? MCI_INT_CMD_DONE : MCI_INT_DATA_OVER;
+ 
+   /* Clear the interrupts & FIFOs*/
+   if (cmd & CMD_BIT_DATA)
+     prv_clear_all();
+ 
+ 
+   while (step)
+   {
+     prv_set_clock((cmd & CMD_BIT_LS) ? SD_MMC_ENUM_CLOCK : pdev->speed);
+ 
+ 
+     /* Clear the interrupts */
+       MCI->rintsts = 0xFFFFFFFF;
+ 
+     switch (step)
+     {
+       case 1:     /* Execute command */
+         cmd_reg = ((cmd & CMD_MASK_CMD) >> CMD_SHIFT_CMD)
+                   | ((cmd & CMD_BIT_INIT)  ? MCI_CMD_INIT : 0)
+                   | ((cmd & CMD_BIT_DATA)  ? (MCI_CMD_DAT_EXP | MCI_CMD_PRV_DAT_WAIT) : 0)
+                   | (((cmd & CMD_MASK_RESP) == CMD_RESP_R2) ? MCI_CMD_RESP_LONG : 0)
+                   | ((cmd & CMD_MASK_RESP) ? MCI_CMD_RESP_EXP : 0)
+                   | ((cmd & CMD_BIT_WRITE)  ? MCI_CMD_DAT_WR : 0)
+                   | ((cmd & CMD_BIT_STREAM) ? MCI_CMD_STRM_MODE : 0)
+                   | ((cmd & CMD_BIT_BUSY) ? MCI_CMD_STOP : 0)
+                   | ((cmd & CMD_BIT_AUTO_STOP)  ? MCI_CMD_SEND_STOP : 0)
+                   | MCI_CMD_START
+                   ;
+ 
+         /* wait for previos data finsh for selct/deselct commands */
+         if (((cmd & CMD_MASK_CMD) >> CMD_SHIFT_CMD) == MMC_SELECT_CARD)
+         {
+           cmd_reg |= MCI_CMD_PRV_DAT_WAIT;
+         }
+ 
+         /* wait for command to be accepted by CIU */
+         if (prv_send_cmd(cmd_reg, arg) == 0)
+           --step;
+ 		
+         break;
+ 
+       case 0:
+         return 0;
+ 
+       case 2:      /* APP prefix */
+         cmd_reg = MMC_APP_CMD
+                   | MCI_CMD_RESP_EXP /* Response is status */
+                   | ((cmd & CMD_BIT_INIT)  ? MCI_CMD_INIT : 0)
+                   | MCI_CMD_START
+                   ;
+         if (prv_send_cmd(cmd_reg, pdev->rca << 16) == 0)
+           --step;
+         break;
+     }
+ 
+     /* wait for command response*/
+     status = prv_wait_for_completion(pdev, wait_status);
+ 
+     /* We return an error if there is a timeout, even if we've fetched
+     a response */
+     if (status & MCI_INT_ERROR)
+       return status;
+ 
+     if (status & MCI_INT_CMD_DONE)
+     {
+       switch (cmd & CMD_MASK_RESP)
+       {
+         case 0:
+           break;
+         case CMD_RESP_R1:
+         case CMD_RESP_R3:
+           prv_pull_response(pdev, 48);
+           break;
+         case CMD_RESP_R2:
+           prv_pull_response(pdev, 136);
+           break;
+       }
+     }
+   }
+   return 0;
+ }
+ 
+ 
+ /***********************************************************************
+  *
+  * Function: mci_acquire
+  *
+  * Purpose: Function to enumerate the SD/MMC/SDHC/MMC+ cards.
+  *
+  * Processing:
+  *     This function perform card identification process described in
+  *  MMC 4.2 and SD 2.0 specification. The function uses "state" variable
+  *  to track the identification process.
+  *
+  *  For SD/SDHC cards the "state" transitions from:
+  *  0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7
+  *
+  *  For MMC/ MMC+ cards the "state" transitions from:
+  *  0 -> 1 -> 10 -> 11 -> 12 -> 13 -> 14 -> 15 -> 16 -> 17
+  *
+  * Parameters:
+  *     devid: Pointer to card info structure
+  *
+  * Outputs: None
+  *
+  * Returns: None.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void mci_acquire(MCI_CARD_INFO_T* pdev)
+ {
+   int status;
+   int tries = 0;
+   ulong ocr = OCR_VOLTAGE_RANGE_MSK;
+   ulong r;
+   int state = 0;
+   ulong command = 0;
+   /* preserve wait_func */
+   MCI_CMD_WAIT_FUNC_T temp = pdev->wait_func;
+ 
+   /* clear card struct */
+   memset(pdev, 0, sizeof(MCI_CARD_INFO_T));
+   /* restore wait_func */
+   pdev->wait_func = temp;
+ 
+   /* clear card type */
+   MCI->ctype = 0;
+ 
+   /* we could call board specific card detect routine here */
+ 
+   /* set high speed for the card as 20MHz */
+   pdev->speed = MMC_MAX_CLOCK;
+ 
+   status = mci_execute_command(pdev, CMD_IDLE, 0, MCI_INT_CMD_DONE);
+ 
+   while (state < 100)
+   {
+     switch (state)
+     {
+       case 0:     /* Setup for SD */
+         /* check if it is SDHC card */
+         status = mci_execute_command(pdev, CMD_SD_SEND_IF_COND, SD_SEND_IF_ARG, 0);
+         if (!(status & MCI_INT_RTO))
+         {
+ 
+           /* check response has same echo pattern */
+           if ((pdev->response[0] & SD_SEND_IF_ECHO_MSK) == SD_SEND_IF_RESP)
+             /* it is SD 2.0 card so indicate we are SDHC capable*/
+             ocr |= OCR_HC_CCS;
+         }
+ 
+         ++state;
+         command = CMD_SD_OP_COND;
+         tries = INIT_OP_RETRIES;
+         /* assume SD card */
+         pdev->card_type |= CARD_TYPE_SD;
+         /* for SD cards high speed is 25MHz */
+         pdev->speed = SD_MAX_CLOCK;
+ 
+         break;
+ 
+       case 10:      /* Setup for MMC */
+         /* start fresh for MMC crds */
+         pdev->card_type &= ~CARD_TYPE_SD;
+         status = mci_execute_command(pdev, CMD_IDLE, 0, MCI_INT_CMD_DONE);
+         command = CMD_MMC_OP_COND;
+         tries = INIT_OP_RETRIES;
+         ocr |= OCR_HC_CCS;
+         ++state;
+         /* for MMC cards high speed is 20MHz */
+         pdev->speed = MMC_MAX_CLOCK;
+         break;
+ 
+       case 1:
+       case 11:
+         status = mci_execute_command(pdev, command, 0, 0);
+         if (status & MCI_INT_RTO)
+           state += 9;		/* Mode unavailable */
+         else
+           ++state;
+         break;
+ 
+       case 2:			/* Initial OCR check  */
+       case 12:
+         ocr = pdev->response[0] | (ocr & OCR_HC_CCS);
+         if (ocr & OCR_ALL_READY)
+           ++state;
+         else
+           state += 2;
+         break;
+ 
+       case 3:			/* Initial wait for OCR clear */
+       case 13:
+         while ((ocr & OCR_ALL_READY) && --tries > 0)
+         {
+           timer_wait_ms(NULL, MS_ACQUIRE_DELAY);
+           status = mci_execute_command(pdev, command, 0, 0);
+           ocr = pdev->response[0] | (ocr & OCR_HC_CCS);
+         }
+         if (ocr & OCR_ALL_READY)
+           state += 7;
+         else
+           ++state;
+         break;
+ 
+       case 14:
+         /* for MMC cards set high capacity bit */
+         ocr |= OCR_HC_CCS;
+       case 4:     /* Assign OCR */
+         tries = SET_OP_RETRIES;
+         ocr &= OCR_VOLTAGE_RANGE_MSK | OCR_HC_CCS;	/* Mask for the bits we care about */
+         do
+         {
+           timer_wait_ms(NULL, MS_ACQUIRE_DELAY);
+           status = mci_execute_command(pdev, command, ocr, 0);
+           r = pdev->response[0];
+         }
+         while (!(r & OCR_ALL_READY) && --tries > 0);
+         if (r & OCR_ALL_READY)
+         {
+           /* is it high capacity card */
+           pdev->card_type |= (r & OCR_HC_CCS);
+           ++state;
+         }
+         else
+           state += 6;
+ 
+         break;
+ 
+       case 5:     /* CID polling */
+       case 15:
+         status = mci_execute_command(pdev, CMD_ALL_SEND_CID, 0, 0);
+         memcpy(pdev->cid, pdev->response, 16);
+         ++state;
+         break;
+ 
+       case 6:     /* RCA send, for SD get RCA */
+         status = mci_execute_command(pdev, CMD_SD_SEND_RCA, 0, 0);
+         pdev->rca = (pdev->response[0]) >> 16;
+         ++state;
+         break;
+       case 16:      /* RCA assignment for MMC set to 1 */
+         pdev->rca = 1;
+         status = mci_execute_command(pdev, CMD_MMC_SET_RCA, pdev->rca << 16, 0);
+         ++state;
+         break;
+ 
+       case 7:
+       case 17:
+         status = mci_execute_command(pdev, CMD_SEND_CSD, pdev->rca << 16, 0);
+         memcpy(pdev->csd, pdev->response, 16);
+         state = 100;
+         break;
+ 
+       default:
+         state += 100; /* break from while loop */
+         break;
+     }
+   }
+ 
+   if (prv_card_acquired(pdev))
+   {
+     /* change delay gates per card type */
+     if (pdev->card_type & CARD_TYPE_SD)
+       SYS_REGS->mci_delaymodes = SYS_REG_SD_CARD_DELAY;
+     else
+       SYS_REGS->mci_delaymodes = SYS_REG_MMC_CARD_DELAY;
+ 
+     /* now compute card size, block size and no. of blocks
+     based on CSD response recived. */
+     prv_process_csd(pdev);
+   }
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: mci_open
+  *
+  * Purpose: Opens the MCI card controller
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     ipbase: Pointer to a MCI peripheral block
+  *     arg   : Pointer to wait function to be used during for poll
+  *             command status. Application with OS capabilities can use
+  *             this option to avoid busy wait implemented in the driver's
+  *             default wait routine.
+  *
+  * Outputs: None
+  *
+  * Returns: The pointer to a card info structure or NULL
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ int mmc_init(int verbose)
+ {
+   /* enable SD/MMC clock */
+   cgu_clk_en_dis(CGU_SB_SD_MMC_HCLK_ID, 1);
+   cgu_clk_en_dis(CGU_SB_SD_MMC_CCLK_IN_ID, 1);
+ 
+   /* reset SD/MMC/MCI modules through CGU */
+   cgu_soft_reset_module(SD_MMC_PNRES_SOFT);
+   cgu_soft_reset_module(SD_MMC_NRES_CCLK_IN_SOFT);
+ 
+   /* Set IOCONF to MCI pins */
+   SYS_REGS->mci_delaymodes = 0;
+   SYS_REGS->mux_gpio_mci_sel = 1;
+   /* set the pins as driven by IP in IOCONF */
+   IOCONF->block[IOCONF_MUX0].mode1_clear = 0xF0000003;
+   IOCONF->block[IOCONF_MUX0].mode0_set = 0xF0000003;
+ 
+   /* set delay gates */
+   SYS_REGS->mci_delaymodes = SYS_REG_SD_CARD_DELAY;
+ 
+   /* reset all blocks */
+   MCI->ctrl = MCI_CTRL_RESET | MCI_CTRL_FIFO_RESET
+               | MCI_CTRL_DMA_RESET;
+   /* wait till resets clear */
+   while (MCI->ctrl &
+          (MCI_CTRL_RESET | MCI_CTRL_FIFO_RESET | MCI_CTRL_DMA_RESET));
+ 
+   /* Clear the interrupts for the host controller */
+   MCI->rintsts = 0xFFFFFFFF;
+ 
+   /* Put in max timeout */
+   MCI->tmout = 0xFFFFFFFF;
+ 
+   /* FIFO threshold settings  */
+   MCI->fifoth = (0x2 << 28) | (0xF << 16) | (0x10 << 0);
+ 
+   /* disable clock to CIU */
+   MCI->clkena = 0;
+   MCI->clksrc = 0;
+ 
+   /* clear mmc structure*/
+   memset(&g_card_info, 0, sizeof(MCI_CARD_INFO_T));
+   /* set the wait_func if passed */
+   g_card_info.wait_func = (MCI_CMD_WAIT_FUNC_T)NULL;
+ 
+   /* start card enumeration */
+   mci_acquire(&g_card_info);
+   if(g_card_info.cid[0] != 0)
+ 	printf("Card Detected ok\n");
+   else
+ 	printf("Card Detection failed\n");
+   mmc_dev.if_type = IF_TYPE_MMC;
+   mmc_dev.part_type = PART_TYPE_DOS;
+   mmc_dev.dev = 0;
+   mmc_dev.lun = 0;
+   mmc_dev.type = 0;
+   mmc_dev.blksz = g_card_info.block_len;
+   mmc_dev.lba = g_card_info.blocknr;
+   sprintf((char*)mmc_dev.vendor, "Unknown vendor");
+   sprintf((char*)mmc_dev.product, "Unknown product");
+   sprintf((char*)mmc_dev.revision, "N/A");
+   mmc_dev.removable = 0;  /* should be true??? */
+   mmc_dev.block_read  = mci_read_blocks;
+   mmc_dev.block_write = mci_write_blocks;
+ 
+ #ifdef CONFIG_CMD_FAT
+   fat_register_device(&mmc_dev, 1);   /* partitions start counting with 1 */
+ #endif
+   return (g_card_info.cid[0] == 0) ? 1 : 0;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: mci_close
+  *
+  * Purpose: Close the MCI
+  *
+  * Processing:
+  *     IResets MCI controller and disables clocks going to the MCI.
+  *
+  * Parameters:
+  *     devid: Pointer to card info structure
+  *
+  * Outputs: None
+  *
+  * Returns: The status of the close operation
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ STATUS mci_close(long devid)
+ {
+   /* clear mmc structure*/
+   memset(&g_card_info, 0, sizeof(MCI_CARD_INFO_T));
+   /* reset SD/MMC/MCI modules through CGU */
+   cgu_soft_reset_module(SD_MMC_PNRES_SOFT);
+   cgu_soft_reset_module(SD_MMC_NRES_CCLK_IN_SOFT);
+   /* Turn off SD/MMC clocks */
+   cgu_clk_en_dis(CGU_SB_SD_MMC_HCLK_ID, 0);
+   cgu_clk_en_dis(CGU_SB_SD_MMC_CCLK_IN_ID, 0);
+ 
+   return _NO_ERROR;
+ }
+ 
+ 
+ /***********************************************************************
+  *
+  * Function: mci_read_blocks
+  *
+  * Purpose: Performs the read of data from the SD/MMC card
+  *
+  * Processing:
+  *     Reads the requested blocks in sequence.
+  *
+  * Parameters:
+  *     devid:     Pointer to card info structure
+  *     buffer:    Pointer to data buffer to copy to
+  *     start_block: Start block number
+  *     end_block: End block number
+  *
+  * Outputs: None
+  *
+  * Returns: Number of bytes actually read
+  *
+  * Notes:
+  *  To read single block set start_block = end_block.
+  *
+  **********************************************************************/
+ long mci_read_blocks(	long devid,
+ 							long start_block,
+ 							long blkcnt,
+ 							void* buffer
+                        
+                        		)
+ {
+   MCI_CARD_INFO_T* pdev = &g_card_info;
+   long end_block = start_block + blkcnt - 1; 
+   long cbRead = (end_block - start_block + 1) << 9; /*(end_block - start_block) * 512 */
+   long status;
+   long index;
+ 
+   /* if card is not acquired return immediately */
+   if ((prv_card_acquired(pdev) == 0)
+       || (end_block < start_block) /* check block index in range */
+       || (start_block < 0)
+       || (end_block > pdev->blocknr)
+      )
+   {
+   
+     return 0;
+   }
+   /* put card in trans state */
+   if (prv_set_trans_state(pdev) != _NO_ERROR)
+     return 0;
+ 
+   /* set number of bytes to read */
+   MCI->bytcnt = cbRead;
+ 
+   /* if high capacity card use block indexing */
+   if (pdev->card_type & CARD_TYPE_HC)
+     index = start_block;
+   else
+     index = start_block << 9;
+ 
+   /* check how many blocks to read */
+   if (end_block ==  start_block)
+   {
+     status = mci_execute_command(pdev, CMD_READ_SINGLE, index,
+                                  MCI_INT_CMD_DONE | MCI_INT_DATA_OVER | MCI_INT_RXDR);
+   }
+   else
+   {
+     /* do read multiple */
+     status = mci_execute_command(pdev, CMD_READ_MULTIPLE, index,
+                                  MCI_INT_CMD_DONE | MCI_INT_DATA_OVER | MCI_INT_RXDR);
+   }
+ 
+   memset(buffer,0,cbRead);
+   
+   /* read data from the FIFO */
+   if (status == 0)
+     cbRead = prv_pull_data((unsigned char*)buffer, cbRead);
+   else
+     cbRead = 0; /* return error if command fails */
+ 
+   return cbRead >> 9;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: mci_write_blocks
+  *
+  * Purpose: Performs write of data to the SD/MMC card
+  *
+  * Processing:
+  *     Write the requested blocks in sequence with data passed.
+  *
+  * Parameters:
+  *     devid:     Pointer to card info structure
+  *     buffer:    Pointer to data buffer to copy to
+  *     start_block: Start block number
+  *     end_block: End block number
+  *
+  * Outputs: None
+  *
+  * Returns: Number of bytes actually written
+  *
+  * Notes:
+  *  To write single block set start_block = end_block.
+  *
+  **********************************************************************/
+ long mci_write_blocks(long devid,
+ 							long start_block,
+ 							long blkcnt,
+ 							void* buffer)
+ {
+   MCI_CARD_INFO_T* pdev = &g_card_info;
+   /*(end_block - start_block) * 512 */
+   long end_block = start_block + blkcnt - 1; 
+   long cbWrote = (end_block - start_block + 1) << 9;
+   int status;
+   long index;
+ 
+   /* if card is not acquired return immediately */
+   if ((prv_card_acquired(pdev) == 0)
+       || (end_block < start_block) /* check block index in range */
+       || (start_block < 0)
+       || (end_block > pdev->blocknr)
+      )
+   {
+     return 0;
+   }
+ 
+   /* put card in trans state */
+   if (prv_set_trans_state(pdev) != _NO_ERROR)
+     return 0;
+ 
+   /* set number of bytes to write */
+   MCI->bytcnt = cbWrote;
+ 
+   /* if high capacity card use block indexing */
+   if (pdev->card_type & CARD_TYPE_HC)
+     index = start_block;
+   else
+     index = start_block << 9;
+ 
+   /* check how many blocks to write */
+   if (end_block == start_block)
+   {
+     status = mci_execute_command(pdev, CMD_WRITE_SINGLE, index,
+                                  MCI_INT_CMD_DONE | MCI_INT_TXDR);
+   }
+   else
+   {
+     /* do write multiple */
+     status = mci_execute_command(pdev, CMD_WRITE_MULTIPLE, index,
+                                  MCI_INT_CMD_DONE | MCI_INT_TXDR);
+   }
+   /* write data to the FIFO */
+   if (status == 0)
+   {
+     prv_push_data((unsigned char*)buffer, cbWrote);
+     /* wait for transfer done */
+     status = prv_wait_for_completion(pdev, MCI_INT_DATA_OVER);
+   }
+   else
+   {
+     cbWrote = 0; /* return error if command fails */
+   }
+ 
+   return cbWrote >> 9;
+ }
+ 
+ 
+ 
+ block_dev_desc_t * mmc_get_dev(int dev)
+ {
+ 	return (block_dev_desc_t *)(&mmc_dev);
+ }
+ 
+ int mmc2info(ulong addr)
+ {
+ 	/* This function is used by cmd_cp to determine if source or destination
+ 	 address resides on MMC-card or not. We do not support copy to and from
+ 	 MMC-card so we always return 0. */
+ 	return 0;
+ }
+ 
+ int mmc_write(uchar * src, ulong dst, int size)
+ {
+ #ifdef MMC_DEBUG
+ 	printf("mmc_write: src=%p, dst=%lu, size=%u\n", src, dst, size);
+ #endif
+ 	/* Since mmc2info always returns 0 this function will never be called */
+ 	return 0;
+ }
+ 
+ int mmc_read(ulong src, uchar * dst, int size)
+ {
+ #ifdef MMC_DEBUG
+ 	printf("mmc_read: src=%lu, dst=%p, size=%u\n", src, dst, size);
+ #endif
+ 	/* Since mmc2info always returns 0 this function will never be called */
+ 	return 0;
+ }
+ 
+ #endif
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_mci.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_mci.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_mci.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_mci.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,179 ----
+ /***********************************************************************
+ * $Id:: lpc313x_mci.h 1310 2008-11-04 01:47:18Z pdurgesh              $
+ *
+ * Project: LPC313X Memory Card Interface (MCI) definitions
+ *
+ * Description:
+ *     This file contains the structure definitions and manifest
+ *     constants for the LPC313X chip family component:
+ *         Memory Card Interface (MCI)
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+ 
+ #ifndef LPC313X_MCI_H
+ #define LPC313X_MCI_H
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+ * Memory Card Interface (MCI) Register Structures
+ **********************************************************************/
+ 
+ /* Memory Card Interface (MCI) Module Register Structure */
+ typedef volatile struct
+ {
+   volatile ulong ctrl;    /* control register (R/W) */
+   volatile ulong pwren;   /* power-enable register (R/W) */
+   volatile ulong clkdiv;  /* clock-divider register (R/W) */
+   volatile ulong clksrc;  /* clock-source register (R/W) */
+   volatile ulong clkena;  /* clock enable register (R/W) */
+   volatile ulong tmout;   /* time-out  register (R/W) */
+   volatile ulong ctype;   /* card-type register (R/W) */
+   volatile ulong blksiz;  /* blck-size register (R/W) */
+   volatile ulong bytcnt;  /* byte-count register (R/W) */
+   volatile ulong intmsk;  /* interrupt-mask    register (R/W) */
+   volatile ulong cmdarg;  /* command-argument register (R/W) */
+   volatile ulong cmd;     /* command register (R/W) */
+   volatile ulong resp0;   /* response-0 register (R) */
+   volatile ulong resp1;   /* response-1 register (R) */
+   volatile ulong resp2;   /* response-2 register (R) */
+   volatile ulong resp3;   /* response-3 register (R) */
+   volatile ulong mintsts; /* masked interrupt-status register (R) */
+   volatile ulong rintsts; /* raw interrupt-status register (R/W) */
+   volatile ulong status;  /* status; mainly for debug register (R) */
+   volatile ulong fifoth;  /* FIFO treshold register (R/W) */
+   volatile ulong cdetec;  /* card-detect   register (R) */
+   volatile ulong wrtprt;  /* write-protect register (R) */
+   volatile ulong gpio;    /* GPIO register (R/W) */
+   volatile ulong tcbcnt;  /* transferred CIU card byte count register (R) */
+   volatile ulong tbbcnt;  /* transferred host/DMA to/from BIU-FIFO byte count register (R) */
+   volatile ulong debnce;  /* card detect debounce  register (R/W) */
+   volatile ulong usrid;   /* user ID register (R/W) */
+   volatile ulong verid;   /* synopsys version ID register (R) */
+   volatile ulong hcon;    /* hardware configuration register (R) */
+   volatile ulong reserved[23]; /* Data FIFO (R) */
+   volatile ulong data;    /* Data FIFO (R) */
+ } MCI_REGS_T;
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ /***********************************************************************
+ * useful defines
+ ***********************************************************************/
+ #define SD_MMC_ENUM_CLOCK       400000
+ #define MMC_MAX_CLOCK           20000000
+ #define MMC_LOW_BUS_MAX_CLOCK   26000000
+ #define MMC_HIGH_BUS_MAX_CLOCK  52000000
+ #define SD_MAX_CLOCK            25000000
+ #define MCI_FIFO_SZ             32
+ #define SYS_REG_SD_CARD_DELAY   0x1B
+ #define SYS_REG_MMC_CARD_DELAY  0x16
+ 
+ /***********************************************************************
+ * Control register defines
+ ***********************************************************************/
+ #define MCI_CTRL_CEATA_INT_EN   _BIT(11)
+ #define MCI_CTRL_SEND_AS_CCSD   _BIT(10)
+ #define MCI_CTRL_SEND_CCSD      _BIT(9)
+ #define MCI_CTRL_ABRT_READ_DATA _BIT(8)
+ #define MCI_CTRL_SEND_IRQ_RESP  _BIT(7)
+ #define MCI_CTRL_READ_WAIT      _BIT(6)
+ #define MCI_CTRL_DMA_ENABLE     _BIT(5)
+ #define MCI_CTRL_INT_ENABLE     _BIT(4)
+ #define MCI_CTRL_DMA_RESET      _BIT(2)
+ #define MCI_CTRL_FIFO_RESET     _BIT(1)
+ #define MCI_CTRL_RESET          _BIT(0)
+ 
+ /***********************************************************************
+ * Clock Enable register defines
+ ***********************************************************************/
+ #define MCI_CLKEN_LOW_PWR      _BIT(16)
+ #define MCI_CLKEN_ENABLE       _BIT(0)
+ 
+ /***********************************************************************
+ * time-out register defines
+ ***********************************************************************/
+ #define MCI_TMOUT_DATA(n)      _SBF(8, (n))
+ #define MCI_TMOUT_DATA_MSK     0xFFFFFF00
+ #define MCI_TMOUT_RESP(n)      ((n) & 0xFF)
+ #define MCI_TMOUT_RESP_MSK     0xFF
+ 
+ /***********************************************************************
+ * card-type register defines
+ ***********************************************************************/
+ #define MCI_CTYPE_8BIT         _BIT(16)
+ #define MCI_CTYPE_4BIT         _BIT(0)
+ 
+ /***********************************************************************
+ * Interrupt status & mask register defines
+ ***********************************************************************/
+ #define MCI_INT_SDIO           _BIT(16)
+ #define MCI_INT_EBE            _BIT(15)
+ #define MCI_INT_ACD            _BIT(14)
+ #define MCI_INT_SBE            _BIT(13)
+ #define MCI_INT_HLE            _BIT(12)
+ #define MCI_INT_FRUN           _BIT(11)
+ #define MCI_INT_HTO            _BIT(10)
+ #define MCI_INT_DTO            _BIT(9)
+ #define MCI_INT_RTO            _BIT(8)
+ #define MCI_INT_DCRC           _BIT(7)
+ #define MCI_INT_RCRC           _BIT(6)
+ #define MCI_INT_RXDR           _BIT(5)
+ #define MCI_INT_TXDR           _BIT(4)
+ #define MCI_INT_DATA_OVER      _BIT(3)
+ #define MCI_INT_CMD_DONE       _BIT(2)
+ #define MCI_INT_RESP_ERR       _BIT(1)
+ #define MCI_INT_CD             _BIT(0)
+ #define MCI_INT_ERROR          0xbfc2
+ 
+ /***********************************************************************
+ * Command register defines
+ ***********************************************************************/
+ #define MCI_CMD_START         _BIT(31)
+ #define MCI_CMD_CCS_EXP       _BIT(23)
+ #define MCI_CMD_CEATA_RD      _BIT(22)
+ #define MCI_CMD_UPD_CLK       _BIT(21)
+ #define MCI_CMD_UPD_CLK       _BIT(21)
+ 
+ #define MCI_CMD_INIT          _BIT(15)
+ #define MCI_CMD_STOP          _BIT(14)
+ #define MCI_CMD_PRV_DAT_WAIT  _BIT(13)
+ #define MCI_CMD_SEND_STOP     _BIT(12)
+ #define MCI_CMD_STRM_MODE     _BIT(11)
+ #define MCI_CMD_DAT_WR        _BIT(10)
+ #define MCI_CMD_DAT_EXP       _BIT(9)
+ #define MCI_CMD_RESP_CRC      _BIT(8)
+ #define MCI_CMD_RESP_LONG     _BIT(7)
+ #define MCI_CMD_RESP_EXP      _BIT(6)
+ #define MCI_CMD_INDX(n)       ((n) & 0x1F)
+ 
+ /***********************************************************************
+ * status register defines
+ ***********************************************************************/
+ #define MCI_STS_GET_FCNT(x)	  (((x)>>17) & 0x1FF)
+ 
+ /**********************************************************************
+ * Macro to access MCI registers
+ **********************************************************************/
+ #define MCI        ((MCI_REGS_T*)SD_MMC_BASE)
+ 
+ 
+ #endif /* LPC313X_MCI_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_mpmc.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_mpmc.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_mpmc.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_mpmc.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,314 ----
+ /***********************************************************************
+ * $Id:: lpc313x_mpmc.h 1180 2008-09-11 19:32:40Z pdurgesh             $
+ *
+ * Project: LPC313X multi-port memory controller definitions
+ *
+ * Description:
+ *     This file contains the structure definitions and manifest
+ *     constants for the LPC313X chip family component:
+ *         multi-port memory controller
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+ 
+ #ifndef LPC313X_MPMC_H
+ #define LPC313X_MPMC_H
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+ * multi-port memory controller Register Structures
+ **********************************************************************/
+ 
+ /* structure for dynamic ram controller */
+ typedef volatile struct
+ {
+   /* Dynamic Configuration Register */
+   volatile ulong  config;
+   /* Dynamic Memory RAS and CAS Delay for nDCS0 */
+   volatile ulong  rascas;
+   volatile ulong  _unused[6];
+ } MPMC_DYNAMIC_REGS_T;
+ 
+ /* structure for static device controller */
+ typedef volatile struct
+ {
+   /* Static Memory Configuration for nCS0 */
+   volatile ulong  config;
+   /* Static Memory Write Enable Delay for nCS0 */
+   volatile ulong  wtwen;
+   /* Static Memory Output Enable Delay for nCS0 */
+   volatile ulong  wtoen;
+   /* Static Memory Read Delay for nCS0 */
+   volatile ulong  wtrd;
+   /* Static Memory Page Mode Read Delay for nCS0 */
+   volatile ulong  wtpg;
+   /* Static Memory Write Delay for nCS0 */
+   volatile ulong  wtwr;
+   /* Static Memory Turn Around Delay for nCS0 */
+   volatile ulong  wtturn;
+   volatile ulong  _unused;
+ } MPMC_STATIC_REGS_T;
+ 
+ /* multi-port memory controller Module Register Structure */
+ typedef volatile struct
+ {
+   /* Control Register */
+   volatile ulong  control;
+   /* Status Register */
+   const  volatile ulong  status;
+   /* Configuration Register */
+   volatile ulong  config;
+   volatile ulong  _unused0[5];
+   /* Dynamic Memory Control Register */
+   volatile ulong  sdram_ctrl;
+   /* Dynamic Memory Refresh Timer */
+   volatile ulong  sdram_ref;
+   /* Dynamic Memory read configuration Register */
+   volatile ulong  sdram_rdcfg;
+   volatile ulong  _unused8[1];
+   /* Dynamic Memory Precharge Command Period */
+   volatile ulong  sdram_rp;
+   /* Dynamic Memory Active to Precharge Command Period */
+   volatile ulong  sdram_ras;
+   /* Dynamic Memory Self-Refresh Exit Time */
+   volatile ulong  sdram_srex;
+   /* Dynamic Memory Last Data Out to Active Time */
+   volatile ulong  sdram_apr;
+   /* Dynamic Memory Data-In to Active Command Time */
+   volatile ulong  sdram_dal;
+   /* Dynamic Memory Write Recovery Time */
+   volatile ulong  sdram_wr;
+   /* Dynamic Memory Active to Active Command Period */
+   volatile ulong  sdram_rc;
+   /* Dynamic Memory Auto-Refresh Period, and Auto-Refresh
+      to Active Command Period */
+   volatile ulong  sdram_rfc;
+   /* Dynamic Memory Exit Self-Refresh to Active Command Time */
+   volatile ulong  sdram_xsr;
+   /* Dynamic Memory Active Bank A to Active Bank B Time */
+   volatile ulong  sdram_rrd;
+   /* Dynamic Memory Load Mode Register to Active Command Time */
+   volatile ulong  sdram_mrd;
+   volatile ulong  _unused1[9];
+   /* Static Memory Extended Wait */
+   volatile ulong  static_ext_wait;
+   volatile ulong  _unused2[31];
+   /* Dynamic Configuration Registers */
+   MPMC_DYNAMIC_REGS_T sdram[4];
+   volatile ulong  _unused3[32];
+   MPMC_STATIC_REGS_T  static_mem[4];
+   volatile ulong  _unused4[0x320];
+   volatile ulong  itcr     ;
+   volatile ulong  _unused5[7];
+   volatile ulong  itip     ;
+   volatile ulong  _unused6[7];
+   volatile ulong  itop     ;
+   volatile ulong  _unused7[35];
+   const  volatile ulong  periph_id4[4];
+   const  volatile ulong  periph_id0[4];
+   const  volatile ulong  pcell_id[4];
+ 
+ } MPMC_REGS_T;
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ /***********************************************************************
+  * MPMC Controller Bit Field constants
+  **********************************************************************/
+ #define MPMC_CTL_LOW_PWR               _BIT(2)
+ #define MPMC_CTL_ENABLE                _BIT(0)
+ 
+ /***********************************************************************
+  * MPMC status Bit Field constants
+  **********************************************************************/
+ #define MPMC_STATUS_SA                 _BIT(2)
+ #define MPMC_STATUS_WR_BUF             _BIT(1)
+ #define MPMC_STATUS_BUSY               _BIT(0)
+ 
+ /***********************************************************************
+  * MPMC config Bit Field constants
+  **********************************************************************/
+ #define MPMC_CFG_SDCCLK_1_2            _BIT(8)
+ #define MPMC_CFG_SDCCLK_1_1            (0)
+ 
+ /***********************************************************************
+  * SDRAM Controller Bit Field constants
+  **********************************************************************/
+ #define MPMC_SDRAMC_CTL_DP             _BIT(13)
+ #define MPMC_SDRAMC_CTL_NORMAL_CMD     _SBF(7,0)
+ #define MPMC_SDRAMC_CTL_MODE_CMD       _SBF(7,1)
+ #define MPMC_SDRAMC_CTL_PALL_CMD       _SBF(7,2)
+ #define MPMC_SDRAMC_CTL_NOP_CMD        _SBF(7,3)
+ #define MPMC_SDRAMC_CTL_MCC            _BIT(5)
+ #define MPMC_SDRAMC_CTL_SR             _BIT(2)
+ #define MPMC_SDRAMC_CTL_CS             _BIT(1)
+ #define MPMC_SDRAMC_CTL_CE             _BIT(0)
+ 
+ /***********************************************************************
+  * SDRAM Config Bit Field constants
+  **********************************************************************/
+ #define MPMC_SDRAMC_CFG_SDRAM_MD       _SBF(3,0)
+ #define MPMC_SDRAMC_CFG_LOW_PWR_MD     _SBF(3,1)
+ #define MPMC_SDRAMC_CFG_SYNC_FLASH     _SBF(3,2)
+ #define MPMC_SDRAMC_CFG_BUF_EN         _BIT(19)
+ #define MPMC_SDRAMC_CFG_WP             _BIT(20)
+ 
+ /*16-bit external bus high-performance address mapping */
+ /*16Mb (2Mx8), 2 banks, row length = 11, column length = 9*/
+ #define SDRAMC_16HP_2Mx8_2B_R11_C9    (_SBF(7,0x00))
+ /*16Mb (1Mx16), 2 banks, row length = 11, column length = 8*/
+ #define SDRAMC_16HP_1Mx16_2B_R11_C8   (_SBF(7,0x01))
+ /*64Mb (8Mx8), 4 banks, row length = 12, column length = 9*/
+ #define SDRAMC_16HP_8Mx8_4B_R12_C9    (_SBF(7,0x04))
+ /*64Mb (4Mx16), 4 banks, row length = 12, column length = 8*/
+ #define SDRAMC_16HP_4Mx16_4B_R12_C8   (_SBF(7,0x05))
+ /*128Mb (16Mx8), 4 banks, row length = 12, column length = 10*/
+ #define SDRAMC_16HP_16Mx8_4B_R12_C10  (_SBF(7,0x08))
+ /*128Mb (8Mx16), 4 banks, row length = 12, column length = 9*/
+ #define SDRAMC_16HP_8Mx16_4B_R12_C9   (_SBF(7,0x09))
+ /*256Mb (32Mx8), 4 banks, row length = 13, column length = 10*/
+ #define SDRAMC_16HP_32Mx8_4B_R13_C10  (_SBF(7,0x0C))
+ /*256Mb (16Mx16), 4 banks, row length = 13, column length = 9*/
+ #define SDRAMC_16HP_16Mx16_4B_R13_C9  (_SBF(7,0x0D))
+ /*512Mb (64Mx8), 4 banks, row length = 13, column length = 11*/
+ #define SDRAMC_16HP_64Mx8_4B_R13_C11  (_SBF(7,0x10))
+ /*512Mb (32Mx16), 4 banks, row length = 13, column length = 10*/
+ #define SDRAMC_16HP_32Mx16_4B_R13_C10 (_SBF(7,0x11))
+ 
+ /*16-bit external bus low power SDRAM address mapping */
+ /*16Mb (2Mx8), 2 banks, row length = 11, column length = 9*/
+ #define SDRAMC_16LP_2Mx8_2B_R11_C9    (_SBF(7,0x20))
+ /*16Mb (1Mx16), 2 banks, row length = 11, column length = 8*/
+ #define SDRAMC_16LP_1Mx16_2B_R11_C8   (_SBF(7,0x21))
+ /*64Mb (8Mx8), 4 banks, row length = 12, column length = 9*/
+ #define SDRAMC_16LP_8Mx8_4B_R12_C9    (_SBF(7,0x24))
+ /*64Mb (4Mx16), 4 banks, row length = 12, column length = 8*/
+ #define SDRAMC_16LP_4Mx16_4B_R12_C8   (_SBF(7,0x25))
+ /*128Mb (16Mx8), 4 banks, row length = 12, column length = 10*/
+ #define SDRAMC_16LP_16Mx8_4B_R12_C10  (_SBF(7,0x28))
+ /*128Mb (8Mx16), 4 banks, row length = 12, column length = 9*/
+ #define SDRAMC_16LP_8Mx16_4B_R12_C9   (_SBF(7,0x29))
+ /*256Mb (32Mx8), 4 banks, row length = 13, column length = 10*/
+ #define SDRAMC_16LP_32Mx8_4B_R13_C10  (_SBF(7,0x2C))
+ /*256Mb (16Mx16), 4 banks, row length = 13, column length = 9*/
+ #define SDRAMC_16LP_16Mx16_4B_R13_C9  (_SBF(7,0x2D))
+ /*512Mb (64Mx8), 4 banks, row length = 13, column length = 11*/
+ #define SDRAMC_16LP_64Mx8_4B_R13_C11  (_SBF(7,0x30))
+ /*512Mb (32Mx16), 4 banks, row length = 13, column length = 10*/
+ #define SDRAMC_16LP_32Mx16_4B_R13_C10 (_SBF(7,0x31))
+ 
+ 
+ /***********************************************************************
+  * SDRAM Read Config Bit Field constants
+  **********************************************************************/
+ #define MPMC_SDRAMC_RDCFG_CLKOUTDELAY_STG       _SBF(0,0)
+ #define MPMC_SDRAMC_RDCFG_CMDDELAY_STG          _SBF(0,1)
+ #define MPMC_SDRAMC_RDCFG_CMDDELAY_P1_STG       _SBF(0,2)
+ #define MPMC_SDRAMC_RDCFG_CMDDELAY_P2_STG       _SBF(0,3)
+ 
+ /***********************************************************************
+  * SDRAM RASCAS Bit Field constants
+  **********************************************************************/
+ #define MPMC_SDRAMC_RASCAS_CAS0        _SBF(8,0)
+ #define MPMC_SDRAMC_RASCAS_CAS1        _SBF(8,1)
+ #define MPMC_SDRAMC_RASCAS_CAS2        _SBF(8,2)
+ #define MPMC_SDRAMC_RASCAS_CAS3        _SBF(8,3)
+ #define MPMC_SDRAMC_RASCAS_RAS0        _SBF(0,0)
+ #define MPMC_SDRAMC_RASCAS_RAS1        _SBF(0,1)
+ #define MPMC_SDRAMC_RASCAS_RAS2        _SBF(0,2)
+ #define MPMC_SDRAMC_RASCAS_RAS3        _SBF(0,3)
+ 
+ /***********************************************************************
+  * Macros to calculate SDRAM timings
+  **********************************************************************/
+ /* TBD: Check RTL if divide by 2 possible. If true change macro to the
+    following:
+    (hclk/(((MPMC->config & _BIT(8))>>8)+1)) */
+ #define MPMC_CLOCK(hclk)               (hclk)
+ 
+ #define MPMC_SDRAMC_REFRESH(trf,hclk)  \
+   (((unsigned long long)(trf * hclk)/16000000000ull) & _BITMASK(11))
+ 
+ #define MPMC_SDRAMC_TRP(trp,hclk)      \
+   (((unsigned long long)(trp * MPMC_CLOCK(hclk))/1000000000ull) & _BITMASK(4))
+ #define MPMC_SDRAMC_TRAS(tras,hclk)    \
+   (((unsigned long long)(tras * MPMC_CLOCK(hclk))/1000000000ull) & _BITMASK(4))
+ #define MPMC_SDRAMC_TSREX(tsrex,hclk)  \
+   (((unsigned long long)(tsrex * MPMC_CLOCK(hclk))/1000000000ull) & _BITMASK(4))
+ #define MPMC_SDRAMC_TDAL(tdal,hclk)    \
+   (((unsigned long long)(tdal * MPMC_CLOCK(hclk))/1000000000ull) & _BITMASK(4))
+ #define MPMC_SDRAMC_TWR(twr,hclk)      \
+   (((unsigned long long)(twr * MPMC_CLOCK(hclk))/1000000000ull) & _BITMASK(4))
+ #define MPMC_SDRAMC_TRC(trc,hclk)      \
+   (((unsigned long long)(trc * MPMC_CLOCK(hclk))/1000000000ull) & _BITMASK(5))
+ #define MPMC_SDRAMC_TRFC(trfc,hclk)    \
+   (((unsigned long long)(trfc * MPMC_CLOCK(hclk))/1000000000ull) & _BITMASK(5))
+ #define MPMC_SDRAMC_TXSR(txsr,hclk)    \
+   (((unsigned long long)(txsr * MPMC_CLOCK(hclk))/1000000000ull) & _BITMASK(5))
+ #define MPMC_SDRAMC_TRRD(trrd,hclk)    \
+   (((unsigned long long)(trrd * MPMC_CLOCK(hclk))/1000000000ull) & _BITMASK(5))
+ #define MPMC_SDRAMC_TMRD(tmrd,hclk)    \
+   (((unsigned long long)(tmrd * MPMC_CLOCK(hclk))/1000000000ull) & _BITMASK(5))
+ 
+ 
+ /***********************************************************************
+  * Static Memory config Bit Field constants
+  **********************************************************************/
+ #define MPMC_STATIC_CFG_MW8      _SBF(0,0)  /* Memory width 8 bits */
+ #define MPMC_STATIC_CFG_MW16     _SBF(0,1)  /* Memory width 16 bits */
+ #define MPMC_STATIC_CFG_MW32     _SBF(0,2)  /* Memory width 16 bits */
+ 
+ #define MPMC_STATIC_CFG_PM       _SBF(3,1)
+ #define MPMC_STATIC_CFG_PC       _SBF(6,1)
+ #define MPMC_STATIC_CFG_BLS      _SBF(7,1)
+ #define MPMC_STATIC_CFG_EW       _SBF(8,1)
+ #define MPMC_STATIC_CFG_B        _SBF(19,1)
+ #define MPMC_STATIC_CFG_P        _SBF(20,1)
+ 
+ /***********************************************************************
+  * Macros to calculate static memory timings
+  **********************************************************************/
+ #define MPMC_STATIC_EXWAIT(twait,hclk)   \
+   (((unsigned long long)(twait * hclk)/16000000000) & _BITMASK(10))
+ 
+ #define MPMC_STATIC_WAIT_WEN(twen,hclk)  \
+   (((unsigned long long)(twen * hclk)/1000000000) & _BITMASK(4))
+ 
+ #define MPMC_STATIC_WAIT_OEN(toen,hclk)  \
+   (((unsigned long long)(toen * hclk)/1000000000) & _BITMASK(4))
+ 
+ #define MPMC_STATIC_WAIT_RD(trd,hclk)    \
+   (((unsigned long long)(trd * hclk)/1000000000) & _BITMASK(5))
+ 
+ #define MPMC_STATIC_WAIT_PAGE(tpg,hclk)  \
+   (((unsigned long long)(tpg * hclk)/1000000000) & _BITMASK(5))
+ 
+ #define MPMC_STATIC_WAIT_WR(twr,hclk)    \
+   (((unsigned long long)(twr * hclk)/1000000000) & _BITMASK(5))
+ 
+ #define MPMC_STATIC_WAIT_TURN(trn,hclk)  \
+   (((unsigned long long)(trn * hclk)/1000000000) & _BITMASK(4))
+ 
+ /* Macro pointing to SysRegs registers */
+ #define MPMC  ((MPMC_REGS_T  *)(MPMC_CFG_BASE))
+ 
+ #endif /* LPC313X_MPMC_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_nandc.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_nandc.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_nandc.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_nandc.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,223 ----
+ /***********************************************************************
+ * $Id:: lpc313x_nandc.h 1527 2008-12-19 00:04:28Z pdurgesh            $
+ *
+ * Project: LPC313X NAND Flash controller definitions
+ *
+ * Description:
+ *     This file contains the structure definitions and manifest
+ *     constants for the LPC313X chip family component:
+ *         NAND Flash controller
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+ 
+ #ifndef LPC313X_NANDC_H
+ #define LPC313X_NANDC_H
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+ * NAND Flash controller Register Structures
+ **********************************************************************/
+ 
+ /* NAND Flash controller Module Register Structure */
+ typedef volatile struct
+ {
+   volatile unsigned long  irq_status;
+   volatile unsigned long  irq_mask;
+   volatile unsigned long  irq_status_raw;
+   volatile unsigned long  config;
+   volatile unsigned long  io_config;
+   volatile unsigned long  timing1;
+   volatile unsigned long  timing2;
+   volatile unsigned long  _unused1[1];
+   volatile unsigned long  set_cmd;
+   volatile unsigned long  set_addr;
+   volatile unsigned long  write_data;
+   volatile unsigned long  set_ce;
+   volatile unsigned long  read_data;
+   volatile unsigned long  check_sts;
+   volatile unsigned long  control_flow;
+   volatile unsigned long  _unused2[1];
+   volatile unsigned long  gpio1;
+   volatile unsigned long  gpio2;
+   volatile unsigned long  irq_status2;
+   volatile unsigned long  irq_mask2;
+   volatile unsigned long  irq_status_raw2;
+   volatile unsigned long  aes_key[4];
+   volatile unsigned long  aes_iv[4];
+   volatile unsigned long  aes_state;
+   volatile unsigned long  ecc_error_stat;
+   volatile unsigned long  aes_from_ahb;
+ } NAND_FLASH_CTRL_REGS_T;
+ 
+ /* NAND Flash configuration parameters structure used by bootROM */
+ typedef struct
+ {
+   /******####TBD####Check the padding behaviour of ADS and modify it*/
+   char   		 tag[8];
+   unsigned char  interface_width;
+   unsigned short page_size_in_bytes;
+   unsigned short page_size_in_32bit_words;
+   unsigned short pages_per_block;
+   unsigned long  nbr_of_blocks;
+   unsigned char  amount_of_address_bytes;
+   unsigned char  amount_of_erase_address_bytes;
+   unsigned char  support_read_terminate;
+   unsigned char  page_increment_byte_nr;
+   char   		 device_name[40];
+   unsigned long  timing1;
+   unsigned long  timing2;
+   unsigned char  ecc_mode;
+ } NAND_BOOT_CFG_PARAMS_T;
+ 
+ /**********************************************************************
+ * Register description of irq_status
+ **********************************************************************/
+ #define NAND_IRQ_RB4_POS_EDGE       _BIT(31)
+ #define NAND_IRQ_RB3_POS_EDGE       _BIT(30)
+ #define NAND_IRQ_RB2_POS_EDGE       _BIT(29)
+ #define NAND_IRQ_RB1_POS_EDGE       _BIT(28)
+ #define NAND_IRQ_ERASED_RAM1        _BIT(27)
+ #define NAND_IRQ_ERASED_RAM0        _BIT(26)
+ #define NAND_IRQ_WR_RAM1            _BIT(25)
+ #define NAND_IRQ_WR_RAM0            _BIT(24)
+ #define NAND_IRQ_RD_RAM1            _BIT(23)
+ #define NAND_IRQ_RD_RAM0            _BIT(22)
+ #define NAND_IRQ_ECC_DEC_RAM0       _BIT(21)
+ #define NAND_IRQ_ECC_ENC_RAM0       _BIT(20)
+ #define NAND_IRQ_ECC_DEC_RAM1       _BIT(19)
+ #define NAND_IRQ_ECC_ENC_RAM1       _BIT(18)
+ #define NAND_IRQ_NOERR_RAM0         _BIT(17)
+ #define NAND_IRQ_ERR1_RAM0          _BIT(16)
+ #define NAND_IRQ_ERR2_RAM0          _BIT(15)
+ #define NAND_IRQ_ERR3_RAM0          _BIT(14)
+ #define NAND_IRQ_ERR4_RAM0          _BIT(13)
+ #define NAND_IRQ_ERR5_RAM0          _BIT(12)
+ #define NAND_IRQ_ERR_UNR_RAM0       _BIT(11)
+ #define NAND_IRQ_NOERR_RAM1         _BIT(10)
+ #define NAND_IRQ_ERR1_RAM1          _BIT(9)
+ #define NAND_IRQ_ERR2_RAM1          _BIT(8)
+ #define NAND_IRQ_ERR3_RAM1          _BIT(7)
+ #define NAND_IRQ_ERR4_RAM1          _BIT(6)
+ #define NAND_IRQ_ERR5_RAM1          _BIT(5)
+ #define NAND_IRQ_ERR_UNR_RAM1       _BIT(4)
+ #define NAND_IRQ_AES_DONE_RAM1      _BIT(1)
+ #define NAND_IRQ_AES_DONE_RAM0      _BIT(0)
+ 
+ /**********************************************************************
+ * Register description of config
+ **********************************************************************/
+ #define NAND_CFG_8BIT_ECC           _BIT(12)
+ #define NAND_CFG_TL_528             _SBF(10, 0x0)
+ #define NAND_CFG_TL_516             _SBF(10, 0x2)
+ #define NAND_CFG_TL_512             _SBF(10, 0x3)
+ #define NAND_CFG_TL_MASK            _SBF(10, 0x3)
+ #define NAND_CFG_EO                 _BIT(9)
+ #define NAND_CFG_DC                 _BIT(8)
+ #define NAND_CFG_M                  _BIT(7)
+ #define NAND_CFG_LC_0               _SBF(5, 0x0)
+ #define NAND_CFG_LC_1               _SBF(5, 0x1)
+ #define NAND_CFG_LC_2               _SBF(5, 0x2)
+ #define NAND_CFG_LC_MASK            _SBF(5, 0x3)
+ #define NAND_CFG_ES                 _BIT(4)
+ #define NAND_CFG_DE                 _BIT(3)
+ #define NAND_CFG_AO                 _BIT(2)
+ #define NAND_CFG_WD                 _BIT(1)
+ #define NAND_CFG_EC                 _BIT(0)
+ 
+ /**********************************************************************
+ * Register description of io_config
+ **********************************************************************/
+ #define NAND_IO_CFG_IO_DRIVE        _BIT(24)
+ #define NAND_IO_CFG_DATA_DEF(n)     _SBF(8, ((n) & 0xFFFF))
+ #define NAND_IO_CFG_CLE_1           _SBF(6, 0x01)
+ #define NAND_IO_CFG_ALE_1           _SBF(4, 0x01)
+ #define NAND_IO_CFG_WE_1            _SBF(2, 0x01)
+ #define NAND_IO_CFG_RE_1            _SBF(0, 0x01)
+ 
+ /**********************************************************************
+ * Register description of timing1
+ **********************************************************************/
+ #define NAND_TIM1_TSRD(n)           _SBF(20, ((n) & 0x3))
+ #define NAND_TIM1_TALS(n)           _SBF(16, ((n) & 0x7))
+ #define NAND_TIM1_TALH(n)           _SBF(12, ((n) & 0x7))
+ #define NAND_TIM1_TCLS(n)           _SBF(4, ((n) & 0x7))
+ #define NAND_TIM1_TCLH(n)           ((n) & 0x7)
+ 
+ /**********************************************************************
+ * Register description of timing2
+ **********************************************************************/
+ #define NAND_TIM2_TDRD(n)           _SBF(28, ((n) & 0x7))
+ #define NAND_TIM2_TEBI(n)           _SBF(24, ((n) & 0x7))
+ #define NAND_TIM2_TCH(n)            _SBF(20, ((n) & 0x7))
+ #define NAND_TIM2_TCS(n)            _SBF(16, ((n) & 0x7))
+ #define NAND_TIM2_TRH(n)            _SBF(12, ((n) & 0x7))
+ #define NAND_TIM2_TRP(n)            _SBF(8, ((n) & 0x7))
+ #define NAND_TIM2_TWH(n)            _SBF(4, ((n) & 0x7))
+ #define NAND_TIM2_TWP(n)            ((n) & 0x7)
+ 
+ /**********************************************************************
+ * Register description of set_ce
+ **********************************************************************/
+ #define NAND_SETCE_OVR_EN(n)        _BIT(((n) & 0x3) + 12)
+ #define NAND_SETCE_OVR_V(n)         _BIT(((n) & 0x3) + 8)
+ #define NAND_SETCE_WP               _BIT(4)
+ #define NAND_SETCE_CV_MASK          0x0F
+ #define NAND_SETCE_CV(n)            (0x0F & ~_BIT(((n) & 0x3)))
+ 
+ /**********************************************************************
+ * Register description of check_sts
+ **********************************************************************/
+ #define NAND_CHK_STS_RB4_EDGE       _BIT(8)
+ #define NAND_CHK_STS_RB3_EDGE       _BIT(7)
+ #define NAND_CHK_STS_RB2_EDGE       _BIT(6)
+ #define NAND_CHK_STS_RB1_EDGE       _BIT(5)
+ #define NAND_CHK_STS_RB4_LVL        _BIT(4)
+ #define NAND_CHK_STS_RB3_LVL        _BIT(3)
+ #define NAND_CHK_STS_RB2_LVL        _BIT(2)
+ #define NAND_CHK_STS_RB1_LVL        _BIT(1)
+ #define NAND_CHK_STS_APB_BSY        _BIT(0)
+ 
+ /**********************************************************************
+ * Register description of aes_from_ahb
+ **********************************************************************/
+ #define NAND_CTRL_WR_RAM1           _BIT(5)
+ #define NAND_CTRL_WR_RAM0           _BIT(4)
+ #define NAND_CTRL_RD_RAM1           _BIT(1)
+ #define NAND_CTRL_RD_RAM0           _BIT(0)
+ 
+ /**********************************************************************
+ * Register description of control_flow
+ **********************************************************************/
+ #define NAND_AES_AHB_EN             _BIT(7)
+ #define NAND_AES_AHB_DCRYPT_RAM1    _BIT(1)
+ #define NAND_AES_AHB_DCRYPT_RAM0    _BIT(0)
+ 
+ 
+ 
+ /* Macro pointing to CGU switch box registers */
+ #define NAND_CTRL  ((NAND_FLASH_CTRL_REGS_T  *)(NANDFLASH_CTRL_CFG_BASE))
+ 
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_NANDC_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_nand_driver.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_nand_driver.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_nand_driver.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_nand_driver.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,575 ----
+ #include "lpc313x_sysreg.h"
+ #include "lpc313x_nand_driver.h"
+ #include "lpc313x_cgu_driver.h"
+ 
+ #include <common.h>
+ 
+ #include <nand.h>
+ 
+ #ifdef CONFIG_CMD_NAND
+ 
+ /***********************************************************************
+  * WDT driver package data
+ ***********************************************************************/
+ #ifdef EXPERIMENTAL_TBC
+ static unsigned long CRCLUT[256] = {
+ 	0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,
+ 	0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
+ 	0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,
+ 	0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
+ 	0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,
+ 	0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
+ 	0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,
+ 	0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
+ 	0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,
+ 	0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
+ 	0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,
+ 	0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
+ 	0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,
+ 	0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
+ 	0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,
+ 	0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
+ 	0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,
+ 	0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
+ 	0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,
+ 	0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
+ 	0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,
+ 	0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
+ 	0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,
+ 	0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
+ 	0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,
+ 	0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
+ 	0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,
+ 	0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
+ 	0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,
+ 	0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
+ 	0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,
+ 	0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D
+ };
+ 
+ /*NANDflash*/
+ static unsigned char PMagic[] = {0x4E, 0x41, 0x4E, 0x44, 0x66, 0x6C, 0x73, 0x68};
+ /* BAD,1 */
+ static unsigned char BMagic[] = {0x42,0x41,0x44,0x01};
+ #endif
+ 
+ /* NAND device configuration structure type */
+ typedef struct
+ {
+   NAND_FLASH_CTRL_REGS_T *regptr;     /* Pointer to NAND registers */
+   unsigned long init;           /* Device initialized flag */
+ } NAND_DRV_T;
+ 
+ extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
+ 
+ 
+ /***********************************************************************
+  * NAND driver private functions
+  **********************************************************************/
+ /***
+ 	hardwarespecific function for accesing device ready/busy line
+ 	If set to NULL no access to ready/busy is available and the ready/busy information
+ 	is read from the chip status register
+ ***/
+ static int nand_lpc313x_dev_ready(struct mtd_info *mtd)
+ {
+ 	unsigned long tmp;
+ 	tmp = NAND_CTRL->check_sts;
+ 	return (int)(tmp & NAND_CHK_STS_RB1_LVL); 
+ }
+ /***
+ 	hardwarespecific function for accesing control-lines
+ ***/
+ static void nand_lpc313x_hwcontrol(struct mtd_info *mtd, int cmd)
+ {
+ 	switch(cmd)
+ 	{
+ 		/* Select the chip by setting nCE to low */
+ 		case NAND_CTL_SETNCE:
+ 			NAND_CTRL->set_ce = NAND_SETCE_WP | NAND_SETCE_CV(0);
+ 			break;
+ 		/* Deselect the chip by setting nCE to high */
+ 		case NAND_CTL_CLRNCE:
+ 			NAND_CTRL->set_ce = NAND_SETCE_CV_MASK;
+ 			break;
+ 	}
+ }
+ 
+ /***
+ 	hardwarespecific function for writing commands to the chip
+ ***/
+ 
+ #ifdef LPC313X_NAND_LP_SUPPORT
+ static void nand_lpc313x_command(struct mtd_info *mtd, unsigned command, int column, int page_addr)
+ {
+ 	register struct nand_chip *this = mtd->priv;
+ 	unsigned long tmp;
+ 
+ 	/* Emulate NAND_CMD_READOOB */
+ 	if (command == NAND_CMD_READOOB) {
+ 		column += mtd->oobblock;
+ 		command = NAND_CMD_READ0;
+ 	}
+ 	
+ 	NAND_CTRL->set_cmd  = command; 
+ 
+ 	if (column != -1 || page_addr != -1) {
+ 		/* Serially input address */
+ 		if (column != -1) {
+ 			/* Adjust columns for 16 bit buswidth */
+ 			if (this->options & NAND_BUSWIDTH_16)
+ 				column >>= 1;
+ 			NAND_CTRL->set_addr = (column & 0xff); 
+ 			NAND_CTRL->set_addr = (column >> 8); 
+ 		}
+ 		if (page_addr != -1) {
+ 			NAND_CTRL->set_addr = (unsigned char) (page_addr & 0xff);
+ 			NAND_CTRL->set_addr = (unsigned char) ((page_addr >> 8) & 0xff);
+ 
+ 			/* One more address cycle for devices > 128MiB */
+ 			if (this->chipsize > (128 << 20))
+ 				NAND_CTRL->set_addr = (unsigned char) ((page_addr >> 16) & 0xff);
+ 		}
+ 		/* Latch in address */
+ 		//this->hwcontrol(mtd, NAND_CTL_CLRALE);
+ 	}
+ 
+ 	/*
+ 	 * program and erase have their own busy handlers
+ 	 * status and sequential in needs no delay
+ 	*/
+ 	switch (command) {
+ 
+ 	case NAND_CMD_CACHEDPROG:
+ 	case NAND_CMD_PAGEPROG:
+ 	case NAND_CMD_ERASE1:
+ 	case NAND_CMD_ERASE2:
+ 	case NAND_CMD_SEQIN:
+ 	case NAND_CMD_STATUS:
+ 		return;
+ 
+ 
+ 	case NAND_CMD_RESET:
+ 		if (this->dev_ready)
+ 			break;
+ 		udelay(this->chip_delay);
+ 		NAND_CTRL->set_cmd = NAND_CMD_RESET;
+ 		while (!((tmp = NAND_CTRL->check_sts) & NAND_CHK_STS_RB1_EDGE));
+ 		return;
+ 
+ 	case NAND_CMD_READ0:
+ 		NAND_CTRL->set_cmd = NAND_CMD_READSTART;
+ 		/* Fall through into ready check */
+ 
+ 	/* This applies to read commands */
+ 	default:
+ 		/*
+ 		 * If we don't have access to the busy pin, we apply the given
+ 		 * command delay
+ 		*/
+ 		if (!this->dev_ready) {
+ 			udelay (this->chip_delay);
+ 			return;
+ 		}
+ 	}
+ 
+ 	/* wait until command is processed */
+ 	while (!this->dev_ready(mtd));
+ }
+ #else
+ static void nand_lpc313x_command (struct mtd_info *mtd, unsigned command, int column, int page_addr)
+ {
+ 	unsigned long tmp;
+ 	register struct nand_chip *this = mtd->priv;
+ 
+ 	/*
+ 	 * Write out the command to the device.
+ 	 */
+ 	if (command == NAND_CMD_SEQIN) {
+ 		int readcmd;
+ 
+ 		if (column >= mtd->oobblock) {
+ 			/* OOB area */
+ 			column -= mtd->oobblock;
+ 			readcmd = NAND_CMD_READOOB;
+ 		} else if (column < 256) {
+ 			/* First 256 bytes --> READ0 */
+ 			readcmd = NAND_CMD_READ0;
+ 		} else {
+ 			column -= 256;
+ 			readcmd = NAND_CMD_READ1;
+ 		}
+ 		NAND_CTRL->set_cmd  = readcmd;
+ 	}
+ 	NAND_CTRL->set_cmd  =  command;
+ 
+ 	if (column != -1 || page_addr != -1) {
+ 		/* Serially input address */
+ 		if (column != -1) {
+ 			/* Adjust columns for 16 bit buswidth */
+ 			if (this->options & NAND_BUSWIDTH_16)
+ 				column >>= 1;
+ 			NAND_CTRL->set_addr = column;
+ 		}
+ 		if (page_addr != -1) {
+ 			NAND_CTRL->set_addr = (unsigned char)  (page_addr & 0xff);
+ 			NAND_CTRL->set_addr = (unsigned char) ((page_addr >> 8) & 0xff);
+ 			/* One more address cycle for devices > 32MiB */
+ 			if (this->chipsize > (32 << 20))
+ 				NAND_CTRL->set_addr = (unsigned char) ((page_addr >> 16) & 0x0f);
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * program and erase have their own busy handlers
+ 	 * status and sequential in needs no delay
+ 	*/
+ 	switch (command) {
+ 
+ 	case NAND_CMD_PAGEPROG:
+ 	case NAND_CMD_ERASE1:
+ 	case NAND_CMD_ERASE2:
+ 	case NAND_CMD_SEQIN:
+ 	case NAND_CMD_STATUS:
+ 		return;
+ 
+ 	case NAND_CMD_RESET:
+ 		if (this->dev_ready)
+ 			break;
+ 		udelay(this->chip_delay);
+ 		NAND_CTRL->set_cmd = NAND_CMD_STATUS;
+ 		while (!((tmp = NAND_CTRL->check_sts) & NAND_CHK_STS_RB1_EDGE));
+ 		return;
+ 
+ 	/* This applies to read commands */
+ 	default:
+ 		/*
+ 		 * If we don't have access to the busy pin, we apply the given
+ 		 * command delay
+ 		*/
+ 		if (!this->dev_ready) {
+ 			udelay (this->chip_delay);
+ 			return;
+ 		}
+ 	}
+ 
+ 	/* wait until command is processed */
+ 	while (!this->dev_ready(mtd));
+ }
+ #endif
+ 
+ 
+ 
+ 
+ /*** 
+ ***/
+ static int nand_lpc313x_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
+ {
+ 
+ 	if (state == FL_ERASING)
+ 		udelay(4000);	/* max is actually 3ms */
+ 	else
+ 		udelay(1000);	/* max is actually 700us */
+ 
+ 	if (!nand_lpc313x_dev_ready(mtd)) {
+ 		printf("Timeout!");
+ 		return 0x01;
+ 	}
+ 
+ 	nand_lpc313x_command(mtd, NAND_CMD_STATUS, -1, -1);
+ 	return this->read_byte(mtd);
+ }
+ 
+ 
+ static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+ 
+ static struct nand_bbt_descr smallpage_memorybased = {
+ 	.options = 0,
+ 	.offs = 5,
+ 	.len = 1,
+ 	.pattern = scan_ff_pattern
+ };
+ 
+ static struct nand_bbt_descr largepage_memorybased = {
+ 	.options = NAND_BBT_SCAN2NDPAGE,
+ 	.offs = 0,
+ 	.len = 2,	/*actually this is 1 for Micron, remain compat with Linux*/
+ 	.pattern = scan_ff_pattern
+ };
+ 
+ static struct nand_bbt_descr smallpage_flashbased = {
+ 	.options =  0,
+ 	.offs = 5,
+ 	.len = 1,
+ 	.pattern = scan_ff_pattern
+ };
+ 
+ static struct nand_bbt_descr largepage_flashbased = {
+ 	.options = NAND_BBT_SCAN2NDPAGE,
+ 	.offs = 0,
+ 	.len = 2,
+ 	.pattern = scan_ff_pattern
+ };
+ 
+ static uint8_t bbt_pattern[] = {'B', 'b', 't', '0' };
+ static uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };
+ 
+ static struct nand_bbt_descr bbt_main_descr = {
+ 	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+ 		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+ 	.offs =	8,
+ 	.len = 4,
+ 	.veroffs = 12,
+ 	.maxblocks = 4,
+ 	.pattern = bbt_pattern
+ };
+ 
+ static struct nand_bbt_descr bbt_mirror_descr = {
+ 	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+ 		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+ 	.offs =	8,
+ 	.len = 4,
+ 	.veroffs = 12,
+ 	.maxblocks = 4,
+ 	.pattern = mirror_pattern
+ };
+ 
+ /**
+  * nand_default_bbt - [NAND Interface] Select a default bad block table for the device
+  * @mtd:	MTD device structure
+  *
+  * This function selects the default bad block table
+  * support for the device and calls the nand_scan_bbt function
+  *
+ */
+ int nand_lpc313x_bbt (struct mtd_info *mtd)
+ {
+ 	struct nand_chip *this = mtd->priv;
+ 
+ 	/* Is a flash based bad block table requested ? */
+ 	if (this->options & NAND_USE_FLASH_BBT) {
+ 		/* Use the default pattern descriptors */
+ 		if (!this->bbt_td) {
+ 			this->bbt_td = &bbt_main_descr;
+ 			this->bbt_md = &bbt_mirror_descr;
+ 		}
+ 		if (!this->badblock_pattern) {
+ 			this->badblock_pattern = (mtd->oobblock > 512) ?
+ 				&largepage_flashbased : &smallpage_flashbased;
+ 		}
+ 	} else {
+ 		this->bbt_td = NULL;
+ 		this->bbt_md = NULL;
+ 		if (!this->badblock_pattern) {
+ 			this->badblock_pattern = (mtd->oobblock > 512) ?
+ 				&largepage_memorybased : &smallpage_memorybased;
+ 		}
+ 	}
+ 	return nand_scan_bbt (mtd, this->badblock_pattern);
+ }
+ 
+ 
+ #ifdef EXPERIMENTAL_TBC
+ unsigned long CalcCRC(unsigned char *pData, unsigned long Length)
+ {
+ 	unsigned long i,result;
+ 	unsigned long idx,lu;
+ 
+ 	result = 0xffffffff;
+ 	for(i=0;i<Length;i++)
+ 	{
+ 		idx = pData[i] ^ result;
+ 		idx &= 0x000000FF;
+ 		lu = CRCLUT[idx];
+ 		result = (result >> 8) ^ lu;
+ 	}
+ 	return (result ^ 0xFFFFFFFF);
+ }
+ 
+ int IsValidParams(uint8_t *buf)
+ {
+ 	unsigned long CalcedCRC, ReadCRC;
+ 	size_t Retlen;
+ 
+ 	if(memcmp(buf, PMagic, sizeof(PMagic)) != 0)
+ 	{
+ 		printf("IsValidParams Bad magic\n");
+ 		return 1;
+ 	}
+ 
+ 	CalcedCRC = CalcCRC(buf, 0xFC);
+ 	ReadCRC = *(unsigned long*)&buf[0xFC];
+ 
+ 	if(CalcedCRC != ReadCRC)
+ 	{
+ 		printf("IsValidParams Bad CRC (%08X != %08X)\n",CalcedCRC,ReadCRC);
+ 		return 1;
+ 	}
+ 	printf("Found NAND params\n");
+ 	return 0;
+ }
+ 
+ static unsigned char SmallPageParams[] = {
+ 	0x4E, 0x41, 0x4E, 0x44, 0x66, 0x6C, 0x73, 0x68,		/* 'NANDflsh' */
+ 	0x00,												/* interface width (8) */
+ 	0x00,												/* rsvd */
+ 	0x00, 0x02,											/* page size in bytes 0x0200 */
+ 	0x80, 0x00,											/* page size in words 0x0200 */
+ 	0x20, 0x00,											/* pages per block 0x0020 */
+ 	0x00, 0x08, 0x00, 0x00,								/* number of blocks 0x0800 */
+ 	0x03,												/* number of address bytes 3 */
+ 	0x02,												/* number of erase address bytes 2 */
+ 	0x00,												/* support read terminate 0 */
+ 	0x01,												/* page increment byte nr 1 */
+ 														/* device name */
+ 	'N','u','m','o','n','y','x',' ',
+ 	'N','A','N','D','2','5','6','W',
+ 	'3','A', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	
+ 	0x00, 0x00, 0x00, 0x00,								/* timing 1 */
+ 	0x00, 0x00, 0x00, 0x00,								/* timing 2 */
+ 	0x00,												/* ECC type 0 */
+ 	0x00, 0x00, 0x00, 
+ 														/* user def */  
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+ 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ };
+ 
+ void GetNANDParams(unsigned char * pbuffer)
+ {
+ 	printf("GetNANDParams %08X\n",pbuffer);
+ 	memcpy(pbuffer, SmallPageParams, sizeof(SmallPageParams));
+ 	*((unsigned long *)&pbuffer[sizeof(SmallPageParams)]) = CalcCRC(SmallPageParams, sizeof(SmallPageParams));
+ }
+ 
+ void GetBBList(struct mtd_info *mtd, unsigned long * pbuffer, uint8_t *bbt)
+ {
+ 	struct nand_chip *this = mtd->priv;
+ 	int i,numblocks;
+ 	uint8_t dat;
+ 
+ 	printf("GetBBList %08X %08X\n",this->bbt,pbuffer);
+ 
+ 	unsigned long * p = pbuffer;
+ 	p++;
+ 	
+ 	numblocks = (int) (mtd->size >> this->bbt_erase_shift);
+ 
+ 	/* walk through the memory table */
+ 	for (i = 0; i < numblocks; i++) 
+ 	{
+ 		int j = nand_isbad_bbt (mtd, i << this->bbt_erase_shift, 1);
+ 		if(j)
+ 		{
+ 			printf("-BB %d %X\n",j,i);
+ 			*p = i;
+ 			 p++;
+ 		}
+ 	}
+ 	*pbuffer = ((p - pbuffer) >> 2);
+ 	printf("Num Bad Blocks %d\n",*pbuffer);
+ 	*p = 0x01444142;
+ 	 p++;
+ 	*p = CalcCRC(pbuffer, (p - pbuffer));
+ }
+ 
+ int IsValidBBList(uint8_t *buf, uint8_t *bbt)
+ {
+ 	unsigned long NumBadBlocks,bbc,bb;
+ 	unsigned long CalcedCRC, ReadCRC;
+ 	size_t Retlen;
+ 
+ 	NumBadBlocks = *(unsigned long*)buf;
+ 	if(NumBadBlocks >= 125)
+ 		NumBadBlocks = 125;
+ 	printf("Num Bad Blocks %d\n",NumBadBlocks);
+ 
+ 	if(memcmp(&buf[(1 + NumBadBlocks) * 4], BMagic, sizeof(BMagic)) != 0)
+ 	{
+ 		printf("IsValidBBList Bad magic\n");
+ 		return 1;
+ 	}
+ 	
+ 	CalcedCRC = CalcCRC(buf, (1 + NumBadBlocks + 1) * 4);
+ 	ReadCRC = *(unsigned long*)&buf[(1 + NumBadBlocks + 1) * 4];
+ 	if(CalcedCRC != ReadCRC)
+ 	{
+ 		printf("IsValidBBList Bad CRC (%08X != %08X)\n",CalcedCRC,ReadCRC);
+ 		return 1;
+ 	}
+ 	for(bbc = 0; bbc < NumBadBlocks; bbc++)
+ 	{
+ 		bb = *(unsigned long*)&buf[(1 + bbc) * 4];
+ 		printf("B:%x @ %08X\n",bbc,bb);
+ 		bbt[bb >> 2] |= 0x03 << (bb & 0x6);		// Should be >> 3 ???
+ 	}
+ 	return 0;
+ }
+ #endif
+ 
+ static void nand_lpc313x_init( void )
+ {
+ 	unsigned long tmp;
+ 	/* enable NAND clocks */
+ 	cgu_clk_en_dis(CGU_SB_NANDFLASH_S0_CLK_ID, 1);
+ 	cgu_clk_en_dis(CGU_SB_NANDFLASH_ECC_CLK_ID, 1);
+ 	cgu_clk_en_dis(CGU_SB_NANDFLASH_NAND_CLK_ID, 1);
+ 	cgu_clk_en_dis(CGU_SB_NANDFLASH_PCLK_ID, 1);
+ 
+ 	/* reset NAND controller */
+ 	cgu_soft_reset_module(NANDFLASH_NAND_RESET_N_SOFT);
+ 	cgu_soft_reset_module(NANDFLASH_ECC_RESET_N_SOFT);
+ 
+ 	/* check NAND mux signals */
+ 	SYS_REGS->mux_nand_mci_sel = 0;
+ 
+ 	/* configure NAND flash based on the open_cfg structure*/
+ 	NAND_CTRL->set_ce = NAND_SETCE_WP | NAND_SETCE_CV(0);
+ 	NAND_CTRL->config = NAND_CFG_EC | NAND_CFG_DC;
+ 	/* set 8 bit device */
+ 	NAND_CTRL->config = NAND_CFG_EC | NAND_CFG_DC;
+ 
+ 	/* reset nand */
+ 	tmp = NAND_CTRL->check_sts;
+ 	NAND_CTRL->set_cmd = NAND_CMD_RESET;
+ 	do{	}while (!((tmp = NAND_CTRL->check_sts) & NAND_CHK_STS_RB1_LVL));
+ 
+ 	NAND_CTRL->set_ce = NAND_SETCE_CV_MASK;
+ 
+ }
+ 
+ /***********************************************************************
+  * NAND driver public functions
+  **********************************************************************/
+ 
+ int board_nand_init(struct nand_chip *nand)
+ {
+ 	nand->IO_ADDR_R			= (void  __iomem *)&NAND_CTRL->read_data;
+ 	nand->IO_ADDR_W			= (void  __iomem *)&NAND_CTRL->write_data;
+ 
+ 	nand->hwcontrol 		= nand_lpc313x_hwcontrol;
+ 	nand->dev_ready			= nand_lpc313x_dev_ready;
+ 	nand->cmdfunc			= nand_lpc313x_command;
+ 	nand->waitfunc			= nand_lpc313x_wait;
+ 	nand->scan_bbt			= nand_lpc313x_bbt;
+ 	nand->options           = NAND_USE_FLASH_BBT;
+ 	nand->eccmode     		= NAND_ECC_SOFT; 	
+ 	nand->chip_delay		= 100; 
+ 	nand_lpc313x_init();
+ 
+ 	return(0);
+ }
+ 
+ #endif
+ 
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_nand_driver.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_nand_driver.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_nand_driver.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_nand_driver.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,87 ----
+ /***********************************************************************
+  * $Id:: lpc313x_nand_driver.h 1388 2008-12-01 19:20:06Z pdurgesh    $
+  *
+  * Project: LPC313x NAND controller driver
+  *
+  * Description:
+  *     This file contains driver support for the LPC313x NAND
+  *     controller.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  *********************************************************************/
+ 
+ #ifndef LPC313X_NAND_DRIVER_H
+ #define LPC313X_NAND_DRIVER_H
+ 
+ #include "lpc313x_nandc.h"
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ /***********************************************************************
+  * NAND device structure and it defines
+  **********************************************************************/
+ 
+ 
+ /***********************************************************************
+  * MCI device configuration commands (IOCTL commands and arguments)
+  **********************************************************************/
+ 
+ /* MCI device commands (IOCTL commands) */
+ typedef enum
+ {
+   NAND_GET_CSD,
+   NAND_GET_EXT_CSD
+ } NAND_IOCTL_CMD_T;
+ 
+ 
+ 
+ 
+ /***********************************************************************
+  * MCI driver API functions
+  **********************************************************************/
+ 
+ /* Open the MCI */
+ long nand_open(void *ipbase, long arg);
+ 
+ /* Close the MCI */
+ STATUS nand_close(long devid);
+ 
+ /* MCI configuration block */
+ STATUS nand_ioctl(long devid,
+                   long cmd,
+                   long arg);
+ 
+ /* MCI read function - read all 16 data registers */
+ long nand_read_blocks(long devid,
+                         void *buffer,
+                         long start_block,
+                         long end_block);
+ 
+ /* MCI write function - writes all 16 data registers */
+ long nand_write_blocks(long devid,
+                          void *buffer,
+                          long start_block,
+                          long end_block);
+ 
+ /***********************************************************************
+  * Other NAND driver functions
+  **********************************************************************/
+ 
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_NAND_DRIVER_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_spi_driver.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_spi_driver.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_spi_driver.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_spi_driver.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,765 ----
+ /***********************************************************************
+  * $Id:: lpc313x_spi_driver.c 1529 2009-01-06 02:08:40Z pdurgesh       $
+  *
+  * Project: LPC313x SPI driver
+  *
+  * Description:
+  *     This file contains driver support for the SPI module on the
+  *     LPC313x
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  **********************************************************************/
+ 
+ #include "lpc313x_cgu_driver.h"
+ #include "lpc313x_intc_driver.h"
+ #include "lpc313x_spi_driver.h"
+ 
+ /***********************************************************************
+  * SPI driver private data and types
+  **********************************************************************/
+ /* SPI device configuration structure type */
+ typedef struct
+ {
+   ulong init;          /* Device initialized flag */
+   SPI_REGS_T *regptr;    /* Pointer to SPI registers */
+   SPI_CB_T cbs;
+ } SPI_DRVDAT_T;
+ 
+ /* SPI device configuration structure */
+ static SPI_DRVDAT_T g_spidrv;
+ 
+ 
+ /***********************************************************************
+  * SPI driver private functions
+  **********************************************************************/
+ 
+ SPI_SLAVE_ID_T spi_get_cur_slave(SPI_REGS_T *regptr)
+ {
+   SPI_SLAVE_ID_T sid = SPI_INVALID_ID;
+   switch (regptr->slave_enable)
+   {
+     case SPI_SLV_EN(SPI_SLAVE1_ID):
+       sid = SPI_SLAVE1_ID;
+       break;
+     case SPI_SLV_EN(SPI_SLAVE2_ID):
+       sid = SPI_SLAVE2_ID;
+       break;
+     case SPI_SLV_EN(SPI_SLAVE3_ID):
+       sid = SPI_SLAVE3_ID;
+       break;
+     default:
+       sid = SPI_INVALID_ID;
+       break;
+   }
+   return sid;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: spi_set_clock
+  *
+  * Purpose: Sets or resets the serial clock rate of the SPI interface
+  *          (in Hz)
+  *
+  * Processing:
+  *     Determine the best dividers to generate the closest possible
+  *     target clock rate for the SPI.
+  *
+  * Parameters:
+  *     pspidrvdat   : Pointer to driver data
+  *     target_clock : The value in Hz for the new SPI serial clock
+  *
+  * Outputs: None
+  *
+  * Returns: _ERROR if the configuration setup failed, otherwise _NO_ERROR
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static STATUS spi_get_clock_div(ulong target_clock,
+                                 ulong *pDivSet)
+ {
+   ulong div, spi_clk, ps, div1;
+   STATUS retvalue = _ERROR;
+ 
+   /* The SPI clock is derived from the (main system oscillator / 2),
+      so compute the best divider from that clock */
+   spi_clk = cgu_get_clk_freq(CGU_SB_SPI_CLK_ID);
+ 
+   /* Find closest divider to get at or under the target frequency.
+      Use smallest prescaler possible and rely on the divider to get
+      the closest target frequency */
+   div = (spi_clk + target_clock / 2) / target_clock;
+ 
+   if ((div < SPI_MAX_DIVIDER) && (div > SPI_MIN_DIVIDER))
+   {
+     ps = (((div - 1) / 512) + 1) * 2;
+     div1 = ((((div + ps / 2) / ps) - 1));
+ 
+     /* write the divider settings */
+     *pDivSet = SPI_SLV1_CLK_PS(ps) | SPI_SLV1_CLK_DIV1((div1));
+ 
+     retvalue = _NO_ERROR;
+   }
+ 
+   return retvalue;
+ }
+ /***********************************************************************
+  *
+  * Function: spi_slave_configure
+  *
+  * Purpose: Configure SPI interface
+  *
+  * Processing:
+  *     Setup the general capabilities of the SPI controller.
+  *
+  * Parameters:
+  *     pspicfg : Pointer to an SPI_CONFIG_T structure
+  *     pspidrvdat: Pointer to driver data
+  *
+  * Outputs: None
+  *
+  * Returns:
+  *     _ERROR if the configuration setup failed, otherwise _NO_ERROR
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static STATUS spi_slave_configure(SPI_DRVDAT_T *pspidrvdat,
+                                   SPI_SLAVE_CONFIG_T *pSlaveCfg)
+ {
+   ulong set1, set2;
+   STATUS setup = _ERROR;
+   SPI_REGS_T *pSpiRegs = pspidrvdat->regptr;
+ 
+   /* get clock divider setting */
+   if (spi_get_clock_div(pSlaveCfg->clk, &set1) == _NO_ERROR)
+   {
+     /* set no of words for SMS mode and inter frame delay timing */
+     set1 |= SPI_SLV1_NUM_WORDS(pSlaveCfg->words) |
+             SPI_SLV1_INTER_TX_DLY(pSlaveCfg->inter_delay);
+ 
+     /* set data width & pre-post delay timing */
+     set2 = SPI_SLV2_WD_SZ(pSlaveCfg->databits - 1) |
+            SPI_SLV2_PPCS_DLY(pSlaveCfg->pp_delay);
+ 
+     /* set the transfer mode */
+     switch (pSlaveCfg->mode)
+     {
+       case SSI_MODE:
+         set2 = SPI_SLV2_SSI_MODE;
+         break;
+       case SPI_MODE1:
+         set2 |= SPI_SLV2_SPH;
+         break;
+       case SPI_MODE2:
+         set2 |= SPI_SLV2_SPO;
+         break;
+       case SPI_MODE3:
+         set2 |= SPI_SLV2_SPO | SPI_SLV2_SPH;
+         break;
+       default:
+         break;
+     }
+     /* check is CS high is needed */
+     if (pSlaveCfg->cs_high)
+       set2 |= SPI_SLV2_CS_HIGH;
+ 
+     /* finally write to the register */
+     pSpiRegs->slv_setting[pSlaveCfg->sid].setting1 = set1;
+     pSpiRegs->slv_setting[pSlaveCfg->sid].setting2 = set2;
+ 
+     setup = _NO_ERROR;
+   }
+   return setup;
+ }
+ 
+ 
+ /***********************************************************************
+  *
+  * Function: spi_configure
+  *
+  * Purpose: Configure SPI interface
+  *
+  * Processing:
+  *     Setup the general capabilities of the SPI controller.
+  *
+  * Parameters:
+  *     pspicfg : Pointer to an SPI_CONFIG_T structure
+  *     pspidrvdat: Pointer to driver data
+  *
+  * Outputs: None
+  *
+  * Returns:
+  *     _ERROR if the configuration setup failed, otherwise _NO_ERROR
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static STATUS spi_configure(SPI_DRVDAT_T *pspidrvdat,
+                             SPI_CONFIG_T *pspicfg)
+ {
+   STATUS setup = _NO_ERROR;
+   SPI_REGS_T *pSpiRegs = pspidrvdat->regptr;
+   ulong i;
+ 
+   /* reset the SPI block */
+   pSpiRegs->spi_config = SPI_CFG_SW_RESET;
+ 
+   /* Master/slave mode control */
+   if (pspicfg->master_mode != 0)
+   {
+     /* configure each slave settings. In master mode slave[0] settings
+     are used. */
+     for (i = 0; i < SPI_NUM_SLAVES; i++)
+     {
+       /* if databits is zero then no slave connected to this CS */
+       if ((pspicfg->slave[i].databits != 0) &&
+           (pspicfg->slave[i].sid == i))
+       {
+         setup = spi_slave_configure(pspidrvdat, &pspicfg->slave[i]);
+ 
+         if (setup == _NO_ERROR)
+         {
+           /* enable the last configured slave only */
+           pSpiRegs->slave_enable = SPI_SLV_EN(i);
+           /* inform the SPI block about changes in slave enable */
+           pSpiRegs->spi_config |= SPI_CFG_UPDATE_EN;
+         }
+       }
+     }
+     /* set master mode & also set inter slave delay */
+     pSpiRegs->spi_config |= SPI_CFG_INTER_DLY(pspicfg->inter_slave_delay);
+   }
+   else
+   {
+     /* in slave mode slave[0] setting registers are used for config */
+     pspicfg->slave[SPI_DEFAULT_ID].sid = SPI_DEFAULT_ID;
+     setup = spi_slave_configure(pspidrvdat, &pspicfg->slave[SPI_DEFAULT_ID]);
+     if (setup == _NO_ERROR)
+     {
+       /* set master mode & also set inter slave delay */
+       pSpiRegs->spi_config |= SPI_CFG_SLAVE_MODE |
+                               SPI_CFG_INTER_DLY(pspicfg->inter_slave_delay);
+       pSpiRegs->slave_enable = 0;
+     }
+   }
+ 
+ 
+   return setup;
+ }
+ #if 0
+ /***********************************************************************
+  *
+  * Function: spi_int
+  *
+  * Purpose: SPI standard interrupt function
+  *
+  * Processing:
+  *     Handle the SPI interrupt. Route to the necessary callback
+  *     function as needed. Disable interrupt if a callback is not
+  *     associated with it.
+  *
+  * Parameters:
+  *     pspidrvdat : Pointer to an SPI driver data
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static void spi_int(SPI_DRVDAT_T *pspidrvdat)
+ {
+   SPI_REGS_T *pSpiRegs = pspidrvdat->regptr;
+ 
+   /* Interrupt was due to a receive data FIFO service request */
+   if ((pSpiRegs->int_status & (SPI_RX_INT | SPI_OVR_INT)) != 0)
+   {
+     if (pspidrvdat->cbs.rxcb == NULL)
+     {
+       /* Disable interrupt, no support for it */
+       pSpiRegs->int_clr_enable = (SPI_RX_INT | SPI_OVR_INT);
+     }
+     else
+     {
+       /* Handle callback */
+       pspidrvdat->cbs.rxcb();
+       pSpiRegs->int_clr_status = (SPI_RX_INT | SPI_OVR_INT);
+     }
+   }
+ 
+   /* Interrupt was due to a transmit data FIFO service request */
+   if ((pSpiRegs->int_status & SPI_TX_INT) != 0)
+   {
+     if (pspidrvdat->cbs.txcb == NULL)
+     {
+       /* Disable interrupt, no support for it */
+       pSpiRegs->int_clr_enable = SPI_TX_INT;
+     }
+     else
+     {
+       /* Handle callback */
+       pspidrvdat->cbs.txcb();
+       pSpiRegs->int_clr_status = (SPI_TX_INT);
+     }
+   }
+ }
+ #endif
+ /***********************************************************************
+  * SPI driver public functions
+  **********************************************************************/
+ 
+ /***********************************************************************
+  *
+  * Function: spi_open
+  *
+  * Purpose: Open the SPI
+  *
+  * Processing:
+  *     Initializes the SPI clocks and default state.
+  *
+  * Parameters:
+  *     ipbase: SPI descriptor device address
+  *     arg   : Pointer to config structure, or NULL if not used
+  *
+  * Outputs: None
+  *
+  * Returns: The pointer to a SPI config structure or 0
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ long spi_open(void *ipbase,
+                 long arg)
+ {
+   SPI_CONFIG_T spi_cfg, *pspicfg;
+   long status = 0;
+ 
+   /* Map SPI registers to data index */
+   if (g_spidrv.init == 0)
+   {
+     /* Save and return address of peripheral block */
+     g_spidrv.regptr = (SPI_REGS_T *) ipbase;
+     /* No initial callbacks */
+     g_spidrv.cbs.txcb = NULL;
+     g_spidrv.cbs.rxcb = NULL;
+ 
+     /* Enable SPI clock */
+     cgu_clk_en_dis(CGU_SB_SPI_PCLK_ID, 1);
+     cgu_clk_en_dis(CGU_SB_SPI_PCLK_GATED_ID, 1);
+     cgu_clk_en_dis(CGU_SB_SPI_CLK_ID, 1);
+     cgu_clk_en_dis(CGU_SB_SPI_CLK_GATED_ID, 1);
+ 
+     /* Initialize device */
+     if (arg == 0)
+     {
+       /* Create and use defaults */
+       spi_cfg.master_mode = 1;
+       spi_cfg.inter_slave_delay = 1;
+       spi_cfg.slave[0].sid = SPI_SLAVE1_ID;
+       spi_cfg.slave[0].databits = 8;
+       spi_cfg.slave[0].mode = SPI_MODE0;
+       spi_cfg.slave[0].cs_high = 0;
+       spi_cfg.slave[0].pp_delay = 0;
+       spi_cfg.slave[0].inter_delay = 0;
+       spi_cfg.slave[0].clk = 1000000;
+       spi_cfg.slave[1].databits = 0;
+       spi_cfg.slave[2].databits = 0;
+ 
+       pspicfg = &spi_cfg;
+     }
+     else
+     {
+       pspicfg = (SPI_CONFIG_T *) arg;
+     }
+     if (spi_configure(&g_spidrv, pspicfg) == _NO_ERROR)
+     {
+       /* Device is valid */
+       g_spidrv.init = 1;
+       status = (long) & g_spidrv;
+ 
+       /* Install SPI interrupt handler */
+       /* int_install_irq_handler(IRQ_SPI, spi_int); */
+ 
+       /* Empty FIFO */
+       g_spidrv.regptr->tx_fifo_flush = SPI_TXFF_FLUSH;
+ 
+       /* Clear latched interrupts */
+       g_spidrv.regptr->int_clr_enable = SPI_ALL_INTS;
+       g_spidrv.regptr->int_clr_status = SPI_ALL_INTS;
+ 
+       /* Enable interrupts */
+       g_spidrv.regptr->int_set_enable = (SPI_OVR_INT |
+                                          SPI_RX_INT | SPI_TX_INT);
+       /* finally SPI block */
+       //g_spidrv.regptr->spi_config |= SPI_CFG_ENABLE;
+     }
+   }
+ 
+   return status;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: spi_close
+  *
+  * Purpose: Close the SPI
+  *
+  * Processing:
+  *     Disable the SPI clock and device.
+  *
+  * Parameters:
+  *     devid: Pointer to SPI config structure
+  *
+  * Outputs: None
+  *
+  * Returns: The status of the close operation
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ STATUS spi_close(long devid)
+ {
+   SPI_DRVDAT_T *pspidrvdat = (SPI_DRVDAT_T *) devid;
+   STATUS status = _ERROR;
+ 
+   if (pspidrvdat->init != 0)
+   {
+     /* 'Uninitialize' device */
+     pspidrvdat->init = 0;
+     status = _NO_ERROR;
+ 
+     /* Disable device */
+     pspidrvdat->regptr->spi_config &= ~SPI_CFG_ENABLE;
+ 
+     /* Disable clock */
+     cgu_clk_en_dis(CGU_SB_SPI_PCLK_ID, 0);
+     cgu_clk_en_dis(CGU_SB_SPI_PCLK_GATED_ID, 0);
+     cgu_clk_en_dis(CGU_SB_SPI_CLK_ID, 0);
+     cgu_clk_en_dis(CGU_SB_SPI_CLK_GATED_ID, 0);
+   }
+ 
+   return status;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: spi_ioctl
+  *
+  * Purpose: SPI configuration block
+  *
+  * Processing:
+  *     This function is a large case block. Based on the passed function
+  *     and option values, set or get the appropriate SPI parameter.
+  *
+  * Parameters:
+  *     devid: Pointer to SPI config structure
+  *     cmd:   ioctl command
+  *     arg:   ioctl argument
+  *
+  * Outputs: None
+  *
+  * Returns: The status of the ioctl operation
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ STATUS spi_ioctl(long devid,
+                  long cmd,
+                  long arg)
+ {
+   SPI_REGS_T *spiregs;
+   SPI_CB_T *pspicb;
+   ulong spiclk, tmp, tmp2, i;
+   SPI_DRVDAT_T *spidrvdat = (SPI_DRVDAT_T *) devid;
+   STATUS status = _ERROR;
+ 
+   if (spidrvdat->init != 0)
+   {
+     status = _NO_ERROR;
+     spiregs = spidrvdat->regptr;
+ 
+     switch (cmd)
+     {
+       case SPI_ENABLE:
+         if (arg == 1)
+         {
+           /* Enable SPI */
+           spiregs->spi_config |= SPI_CFG_ENABLE;
+         }
+         else
+         {
+           /* Disable SPI */
+           spiregs->spi_config &= ~SPI_CFG_ENABLE;
+         }
+         break;
+ 
+       case SPI_SET_ACTIVE_SLAVE:
+         /* enable the last configured slave only */
+         spiregs->slave_enable = SPI_SLV_EN(arg);
+         /* inform the SPI block about changes in slave enable */
+         spiregs->spi_config |= SPI_CFG_UPDATE_EN;
+         break;
+ 
+       case SPI_CONFIG:
+         status = spi_configure(spidrvdat,
+                                (SPI_CONFIG_T *) arg);
+         break;
+ 
+       case SPI_SLAVE_CONFIG:
+         status = spi_slave_configure(spidrvdat,
+                                      (SPI_SLAVE_CONFIG_T *) arg);
+         break;
+ 
+       case SPI_ENABLE_LOOPB:
+         /* Enable or disable loopback mode */
+         if (arg == 1)
+         {
+           /* Enable SPI loopback mode */
+           spiregs->spi_config |= SPI_CFG_LOOPBACK;
+         }
+         else
+         {
+           /* Disable SPI loopback mode */
+           spiregs->spi_config &= ~SPI_CFG_LOOPBACK;
+         }
+         break;
+ 
+       case SPI_SO_DISABLE:
+         /* Slave output disable */
+         if (arg != 0)
+         {
+           spiregs->spi_config |= SPI_CFG_SLAVE_DISABLE;
+         }
+         else
+         {
+           spiregs->spi_config &= ~SPI_CFG_SLAVE_DISABLE;
+         }
+         break;
+ 
+       case SPI_FLUSH_RX_FIFO:
+         while ((spiregs->status & SPI_ST_RX_EMPTY) == 0)
+         {
+           tmp = spiregs->fifo_data;
+         }
+         break;
+       case SPI_FLUSH_TX_FIFO:
+         while ((spiregs->status & SPI_ST_TX_EMPTY) == 0)
+         {
+           spiregs->tx_fifo_flush = SPI_TXFF_FLUSH;
+         }
+         break;
+       case SPI_SET_CALLBACKS:
+         pspicb = (SPI_CB_T *) arg;
+         spidrvdat->cbs.txcb = pspicb->txcb;
+         spidrvdat->cbs.rxcb = pspicb->rxcb;
+         break;
+ 
+       case SPI_CLEAR_INTS:
+         spiregs->int_clr_status = ((ulong) arg) & SPI_ALL_INTS;
+         break;
+ 
+       case SPI_GET_STATUS:
+         /* Return an SPI status */
+         i = 0;
+         switch (arg)
+         {
+           case SPI_SLV3_CLOCK_ST:
+             i++;
+           case SPI_SLV2_CLOCK_ST:
+             i++;
+           case SPI_SLV1_CLOCK_ST:
+           case SPI_CLOCK_ST:
+             /* Return clock speed of SPI interface */
+             tmp = SPI_SLV1_CLK_DIV1_GET(spiregs->slv_setting[i].setting1);
+             tmp2 = SPI_SLV1_CLK_PS_GET(spiregs->slv_setting[i].setting1);
+             /* Compute SPI bit clock rate */
+             spiclk = cgu_get_clk_freq(CGU_SB_SPI_CLK_ID);
+             status = spiclk / (tmp2 * (tmp + 1));
+             break;
+ 
+           case SPI_PENDING_INTS_ST:
+             status = (spiregs->int_status & spiregs->int_enable);
+             break;
+ 
+           case SPI_RAW_INTS_ST:
+             status = spiregs->int_status;
+             break;
+           case SPI_FIFO_ST:
+           default:
+             status = spiregs->status;
+             break;
+         }
+         break;
+ 
+       default:
+         /* Unsupported parameter */
+         status = LPC_BAD_PARAMS;
+     }
+   }
+ 
+   return status;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: spi_read
+  *
+  * Purpose: SPI read function
+  *
+  * Processing:
+  *     Reads data from the SPI FIFO.
+  *
+  * Parameters:
+  *     devid:     Pointer to SPI config structure
+  *     buffer:    Pointer to data buffer to copy to (2 byte aligned)
+  *     max_fifo:  Number of items (of programmed data width) to read
+  *
+  * Outputs: None
+  *
+  * Returns: Number of items read from the SPI FIFO
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ long spi_read(long devid,
+                 void *buffer,
+                 long max_fifo)
+ {
+   long count = 0;
+   SPI_DRVDAT_T *spicfgptr = (SPI_DRVDAT_T *) devid;
+   SPI_REGS_T* pregs;
+   ushort *data16 = NULL;
+   unsigned char *data8 = NULL;
+   SPI_SLAVE_ID_T sid;
+ 
+   if (spicfgptr->init == 1)
+   {
+     pregs = spicfgptr->regptr;
+     /* get current active slave */
+     sid = spi_get_cur_slave(pregs);
+ 
+     if (sid != SPI_INVALID_ID)
+     {
+       /* determine sample width */
+       if (SPI_SLV2_WD_SZ(pregs->slv_setting[sid].setting2) > 8)
+       {
+         data16 = (ushort *)buffer;
+       }
+       else
+       {
+         data8 = (unsigned char *)buffer;
+       }
+       /* Loop until transmit ring buffer is full or until n_bytes
+          expires */
+       while ((max_fifo > 0) &&
+              ((pregs->status & SPI_ST_RX_EMPTY) != SPI_ST_RX_EMPTY))
+       {
+         if (data16 == NULL)
+         {
+           *data8 = (unsigned char)pregs->fifo_data;
+           data8++;
+         }
+         else
+         {
+           *data16 = (ushort)pregs->fifo_data;
+           data16++;
+         }
+ 
+         /* Increment data count and decrement buffer size count */
+         count++;
+         max_fifo--;
+       }
+     }
+   }
+ 
+   return count;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: spi_write
+  *
+  * Purpose: SPI write function
+  *
+  * Processing:
+  *     Write data to the SPI FIFO.
+  *
+  * Parameters:
+  *     devid:   Pointer to SPI config structure
+  *     buffer:  Pointer to data buffer to copy from (2 byte aligned)
+  *     n_fifo:  Number of times to write data to the transmit fifo
+  *
+  * Outputs: None
+  *
+  * Returns: Number of items written to the transmit fifo
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ long spi_write(long devid,
+                  void *buffer,
+                  long n_fifo)
+ {
+   SPI_REGS_T* pregs;
+   long count = 0;
+   SPI_DRVDAT_T *spicfgptr = (SPI_DRVDAT_T *) devid;
+   ushort *data16 = NULL;
+   unsigned char *data8 = NULL;
+   SPI_SLAVE_ID_T sid;
+ 
+   if (spicfgptr->init == 1)
+   {
+     pregs = spicfgptr->regptr;
+     /* get current active slave */
+     sid = spi_get_cur_slave(pregs);
+ 
+     if (sid != SPI_INVALID_ID)
+     {
+       if (SPI_SLV2_WD_SZ(pregs->slv_setting[sid].setting2) > 8)
+       {
+         data16 = (ushort *)buffer;
+       }
+       else
+       {
+         data8 = (unsigned char *)buffer;
+       }
+       /* restrict single to max fifo depth */
+       n_fifo = (n_fifo > SPI_FIFO_DEPTH) ? SPI_FIFO_DEPTH : n_fifo;
+       /* Loop until transmit ring buffer is full or until n_bytes
+          expires */
+       while ((n_fifo > 0) &&
+              ((pregs->status & SPI_ST_TX_FF) != SPI_ST_TX_FF))
+       {
+         if (data16 == NULL)
+         {
+           pregs->fifo_data = (ulong) * data8;
+           data8++;
+         }
+         else
+         {
+           pregs->fifo_data = (ulong) * data16;
+           data16++;
+         }
+ 
+         /* Increment data count and decrement buffer size count */
+         count++;
+         n_fifo--;
+       }
+     }
+   }
+ 
+   return count;
+ }
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_spi_driver.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_spi_driver.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_spi_driver.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_spi_driver.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,197 ----
+ /***********************************************************************
+  * $Id:: lpc313x_spi_driver.h 1180 2008-09-11 19:32:40Z pdurgesh       $
+  *
+  * Project: LPC313X SPI driver
+  *
+  * Description:
+  *     This file contains driver support for the SPI module on the
+  *     LPC313X
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  **********************************************************************/
+ 
+ #ifndef LPC313X_SPI_DRIVER_H
+ #define LPC313X_SPI_DRIVER_H
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ #include "lpc313x_spi.h"
+ 
+ /***********************************************************************
+  * SPI device driver enums
+  **********************************************************************/
+ 
+ /* SPI slave ids */
+ typedef enum
+ {
+   SPI_SLAVE1_ID = 0,
+   SPI_DEFAULT_ID = SPI_SLAVE1_ID,
+   SPI_SLAVE2_ID,
+   SPI_SLAVE3_ID,
+   SPI_INVALID_ID = 0xFF
+ } SPI_SLAVE_ID_T;
+ 
+ /* SPI transfer mode */
+ typedef enum
+ {
+   SPI_MODE0,
+   SPI_MODE1,
+   SPI_MODE2,
+   SPI_MODE3,
+   SSI_MODE
+ } SPI_TRANS_MODE_T;
+ 
+ /* SPI device commands (IOCTL commands) */
+ typedef enum
+ {
+   /* Enable or disable the SPI, use arg = 0 to disable, arg = 1
+      to enable */
+   SPI_ENABLE,
+   /* selects the current slave for upcoming transactions */
+   SPI_SET_ACTIVE_SLAVE,
+   /* Setup the SPI controller, use arg as a pointer to type
+      SPI_CONFIG_T */
+   SPI_CONFIG,
+   /* Setup the slave settings, use arg as a pointer to type
+      SPI_SLAVE_CONFIG_T */
+   SPI_SLAVE_CONFIG,
+   /* Enable or disable loopback mode, use arg as '1' to enable or
+      '0' to disable */
+   SPI_ENABLE_LOOPB,
+   /* Slave output disable, use '1' to disable, or '0' for normal
+      operation */
+   SPI_SO_DISABLE,
+   /* Flush RX FIFO */
+   SPI_FLUSH_RX_FIFO,
+   /* Flush TX FIFO */
+   SPI_FLUSH_TX_FIFO,
+   /* Setup callbacks, use arg as a pointer to type SPI_CB_T */
+   SPI_SET_CALLBACKS,
+   /* Clear SPI interrupts, use arg as a OR'ed value of
+      SPI_IIR_RORRIS or SPI_IIR_RTRIS */
+   SPI_CLEAR_INTS,
+   /* Get a SPI status, use an argument type of SPI_IOCTL_STS_T
+      as the argument to return the correct status */
+   SPI_GET_STATUS
+ } SPI_IOCTL_CMD_T;
+ 
+ /* SPI device arguments for SPI_GET_STATUS command (IOCTL arguments) */
+ typedef enum
+ {
+   /* main status of SPI block */
+   SPI_FIFO_ST,
+   /* Returns SPI clock rate for slave0 in Hz */
+   SPI_SLV1_CLOCK_ST,
+   /* Returns SPI clock rate for slave0 in Hz */
+   SPI_SLV2_CLOCK_ST,
+   /* Returns SPI clock rate for slave0 in Hz */
+   SPI_SLV3_CLOCK_ST,
+   /* Returns SPI clock rate in Hz. Returns value set for slave0. */
+   SPI_CLOCK_ST,
+   /* Returns masked pending interrupts (a combination of
+      SPI_IIR_RORRIS, SPI_IIR_RTRIS, SPI_IIR_RXRIS, and
+      SPI_IIR_TXRIS) */
+   SPI_PENDING_INTS_ST,
+   /* Returns raw pending interrupts (a combination of SPI_IIR_RORRIS,
+      SPI_IIR_RTRIS, SPI_IIR_RXRIS, and SPI_IIR_TXRIS) */
+   SPI_RAW_INTS_ST
+ } SPI_IOCTL_STS_T;
+ 
+ 
+ /***********************************************************************
+  * SPI device configuration commands (IOCTL commands and arguments)
+  **********************************************************************/
+ 
+ /* Structure for setting up SPI parameters */
+ typedef struct
+ {
+   /* slave index */
+   SPI_SLAVE_ID_T sid;
+   /* Number of data bits, must be between 4 and 16 */
+   ulong databits;
+   /* Number of words required in sequential multi-slave transfer mode */
+   ulong words;
+   /* Transfer mode  */
+   SPI_TRANS_MODE_T mode;
+   /* Flag used to set cs polarity high between frames */
+   ulong cs_high;
+   /* Post & pre transfer delay */
+   ulong pp_delay;
+   /* inter transfer delay */
+   ulong inter_delay;
+   /* Serial clock rate */
+   ulong clk;
+ } SPI_SLAVE_CONFIG_T;
+ 
+ /* Structure for setting up SPI parameters */
+ typedef struct
+ {
+   /* Master/slave mode, use TRUE for master mode */
+   ulong master_mode;
+   /* inter-slave delay */
+   ulong inter_slave_delay;
+   /* slave configuartions */
+   SPI_SLAVE_CONFIG_T slave[3];
+ } SPI_CONFIG_T;
+ 
+ /* Callbacks for SPI */
+ typedef struct
+ {
+   /* Transmit callback when more data is needed */
+   PFV txcb;
+   /* Receive callback (FIFO, FIFO timeout, and RX overtrun) */
+   PFV rxcb;
+ } SPI_CB_T;
+ 
+ /***********************************************************************
+  * SPI driver API functions
+  **********************************************************************/
+ 
+ /* Open the SPI */
+ long spi_open(void *ipbase,
+                 long arg);
+ 
+ /* Close the SPI */
+ STATUS spi_close(long devid);
+ 
+ /* SPI configuration block */
+ STATUS spi_ioctl(long devid,
+                  long cmd,
+                  long arg);
+ 
+ /* SPI write function - the buffer must be aligned on a 16-bit
+    boundary if the data size is 9 bits or more */
+ long spi_write(long devid,
+                  void *buffer,
+                  long n_fifo);
+ 
+ /* SPI read function - the buffer must be aligned on a 16-bit
+    boundary if the data size is 9 bits or more */
+ long spi_read(long devid,
+                 void *buffer,
+                 long max_fifo);
+ 
+ /* SPI0 interrupt handler */
+ void spi0_int(void);
+ 
+ /* SPI1 interrupt handler */
+ void spi1_int(void);
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_SPI_DRIVER_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_spi.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_spi.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_spi.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_spi.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,153 ----
+ /***********************************************************************
+ * $Id:: lpc313x_spi.h 1181 2008-09-11 20:59:59Z pdurgesh              $
+ *
+ * Project: LPC313X Serial Peripheral Interface (SPI) definitions
+ *
+ * Description:
+ *     This file contains the structure definitions and manifest
+ *     constants for the LPC313X chip family component:
+ *         Serial Peripheral Interface (SPI)
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+ 
+ #ifndef LPC313X_SPI_H
+ #define LPC313X_SPI_H
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+ * Serial Peripheral Interface (SPI) Register Structures
+ **********************************************************************/
+ /* SPI slave setting Register Structure */
+ typedef volatile struct
+ {
+   volatile ulong setting1;
+   volatile ulong setting2;
+ } SPI_SLV_SETTING_T;
+ 
+ /* Serial Peripheral Interface (SPI) Module Register Structure */
+ typedef volatile struct
+ {
+   volatile ulong       spi_config ;     /*  0x000            */
+   volatile ulong       slave_enable ;   /*  0x004            */
+   volatile ulong       tx_fifo_flush ;  /*  0x008            */
+   volatile ulong       fifo_data ;      /*  0x00C            */
+   volatile ulong       nhp_pop ;        /*  0x010            */
+   volatile ulong       nhp_mode ;       /*  0x014            */
+   volatile ulong       dma_settings ;   /*  0x018            */
+   volatile const ulong status ;         /*  0x01C            */
+   volatile const ulong hw_info ;        /*  0x020            */
+   SPI_SLV_SETTING_T     slv_setting[3] ; /*  0x024 ... 0x038  */
+   volatile const ulong _reserved1[998] ;
+   volatile ulong       int_threshold ; /*  0xFD4            */
+   volatile ulong       int_clr_enable; /*  0xFD8            */
+   volatile ulong       int_set_enable; /*  0xFDC            */
+   volatile const ulong int_status ;    /*  0xFE0            */
+   volatile const ulong int_enable ;    /*  0xFE4            */
+   volatile ulong       int_clr_status ;/*  0xFE8            */
+   volatile ulong       int_set_status ;/*  0xFEC            */
+   volatile const ulong _reserved2[3] ;
+   volatile const ulong module_id ;     /*  0xFFC            */
+ } SPI_REGS_T;
+ /***********************************************************************
+  * SPI device contants
+  **********************************************************************/
+ #define SPI_FIFO_DEPTH  64 /* 64 words (16bit) deep */
+ #define SPI_NUM_SLAVES  3  /* number of slaves supported */
+ #define SPI_MAX_DIV2    254
+ #define SPI_MAX_DIVIDER 65024 /* = 254 * (255 + 1) */
+ #define SPI_MIN_DIVIDER 2
+ 
+ /***********************************************************************
+  * SPI Configuration register definitions
+  **********************************************************************/
+ #define SPI_CFG_INTER_DLY(n)      _SBF(16, ((n) & 0xFFFF))
+ #define SPI_CFG_INTER_DLY_GET(n)  (((n) >> 16) & 0xFFFF)
+ #define SPI_CFG_UPDATE_EN         _BIT(7)
+ #define SPI_CFG_SW_RESET          _BIT(6)
+ #define SPI_CFG_SLAVE_DISABLE     _BIT(4)
+ #define SPI_CFG_MULTI_SLAVE       _BIT(3)
+ #define SPI_CFG_LOOPBACK          _BIT(2)
+ #define SPI_CFG_SLAVE_MODE        _BIT(1)
+ #define SPI_CFG_ENABLE            _BIT(0)
+ /***********************************************************************
+  * SPI slave_enable register definitions
+  **********************************************************************/
+ #define SPI_SLV_EN(n)             _SBF(((n) << 1), 0x1)
+ #define SPI_SLV_SUSPEND(n)        _SBF(((n) << 1), 0x3)
+ 
+ /***********************************************************************
+  * SPI tx_fifo_flush register definitions
+  **********************************************************************/
+ #define SPI_TXFF_FLUSH            _BIT(1)
+ 
+ /***********************************************************************
+  * SPI dma_settings register definitions
+  **********************************************************************/
+ #define SPI_DMA_TX_EN             _BIT(1)
+ #define SPI_DMA_RX_EN             _BIT(0)
+ 
+ /***********************************************************************
+  * SPI status register definitions
+  **********************************************************************/
+ #define SPI_ST_SMS_BUSY           _BIT(5)
+ #define SPI_ST_BUSY               _BIT(4)
+ #define SPI_ST_RX_FF              _BIT(3)
+ #define SPI_ST_RX_EMPTY           _BIT(2)
+ #define SPI_ST_TX_FF              _BIT(1)
+ #define SPI_ST_TX_EMPTY           _BIT(0)
+ 
+ /***********************************************************************
+  * SPI slv_setting registers definitions
+  **********************************************************************/
+ #define SPI_SLV1_INTER_TX_DLY(n)  _SBF(24, ((n) & 0xFF))
+ #define SPI_SLV1_NUM_WORDS(n)     _SBF(16, ((n) & 0xFF))
+ #define SPI_SLV1_CLK_PS(n)        _SBF(8, ((n) & 0xFF))
+ #define SPI_SLV1_CLK_PS_GET(n)    (((n) >> 8) & 0xFF)
+ #define SPI_SLV1_CLK_DIV1(n)      ((n) & 0xFF)
+ #define SPI_SLV1_CLK_DIV1_GET(n)  ((n) & 0xFF)
+ 
+ #define SPI_SLV2_PPCS_DLY(n)      _SBF(9, ((n) & 0xFF))
+ #define SPI_SLV2_CS_HIGH          _BIT(8)
+ #define SPI_SLV2_SSI_MODE         _BIT(7)
+ #define SPI_SLV2_SPO              _BIT(6)
+ #define SPI_SLV2_SPH              _BIT(5)
+ #define SPI_SLV2_WD_SZ(n)         ((n) & 0x1F)
+ 
+ /***********************************************************************
+  * SPI int_threshold registers definitions
+  **********************************************************************/
+ #define SPI_INT_TSHLD_TX          _SBF(8, ((n) & 0xFF))
+ #define SPI_INT_TSHLD_RX          ((n) & 0xFF)
+ 
+ /***********************************************************************
+  * SPI intterrupt registers definitions
+  **********************************************************************/
+ #define SPI_SMS_INT               _BIT(4)
+ #define SPI_TX_INT                _BIT(3)
+ #define SPI_RX_INT                _BIT(2)
+ #define SPI_OVR_INT               _BIT(0)
+ #define SPI_ALL_INTS              (SPI_SMS_INT | SPI_TX_INT | SPI_RX_INT | SPI_OVR_INT)
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_SPI_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_sysreg.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_sysreg.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_sysreg.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_sysreg.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,198 ----
+ /***********************************************************************
+ * $Id:: lpc313x_sysreg.h 1180 2008-09-11 19:32:40Z pdurgesh           $
+ *
+ * Project: LPC313X System Control Registers (SysCReg) definitions
+ *
+ * Description:
+ *     This file contains the structure definitions and manifest
+ *     constants for the LPC313X chip family component:
+ *         System Control Registers (SysCReg)
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+ 
+ #ifndef LPC313X_SYSREG_H
+ #define LPC313X_SYSREG_H
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+ * System Control (SysCReg) Register Structures
+ **********************************************************************/
+ typedef volatile struct
+ {
+   volatile ulong spare_reg0;
+   volatile ulong activate_testpins;
+   volatile ulong ebi_ip2024_1;
+   volatile ulong ebi_ip2024_2;
+   volatile ulong ebi_ip2024_3;
+   volatile ulong ccp_ring_osc_cfg;
+   volatile ulong ssa1_adc_pd_adc10bits;
+   volatile ulong cgu_dyn_hp0;
+   volatile ulong cgu_dyn_hp1;
+   volatile ulong abc_cfg;
+   volatile ulong sd_mmc_cfg;
+   volatile ulong mci_delaymodes;
+   volatile ulong usb_atx_pll_pd_reg;
+   volatile ulong usb_otg_cfg;
+   volatile ulong usb_otg_port_ind_ctl;
+   volatile ulong sys_usb_tpr_dyn;
+   volatile ulong usb_pll_ndec;
+   volatile ulong usb_pll_mdec;
+   volatile ulong usb_pll_pdec;
+   volatile ulong usb_pll_selr;
+   volatile ulong usb_pll_seli;
+   volatile ulong usb_pll_selp;
+   volatile ulong isram0_latency_cfg;
+   volatile ulong isram1_latency_cfg;
+   volatile ulong isrom_latency_cfg;
+   volatile ulong ahb_mpmc_pl172_misc;
+   volatile ulong mpmp_delaymodes;
+   volatile ulong mpmc_waitread_delay0;
+   volatile ulong mpmc_waitread_delay1;
+   volatile ulong wire_ebi_msize_init;
+   volatile ulong mpmc_testmode0;
+   volatile ulong mpmc_testmode1;
+   volatile ulong ahb0_extprio;
+   volatile ulong arm926_shadow_pointer;
+   volatile ulong sleepstatus;
+   volatile ulong chip_id;
+   volatile ulong mux_lcd_ebi_sel;
+   volatile ulong mux_gpio_mci_sel;
+   volatile ulong mux_nand_mci_sel;
+   volatile ulong mux_uart_spi_sel;
+   volatile ulong mux_dao_ipint_sel;
+   volatile ulong ebi_d_9_pctrl;
+   volatile ulong ebi_d_10_pctrl;
+   volatile ulong ebi_d_11_pctrl;
+   volatile ulong ebi_d_12_pctrl;
+   volatile ulong ebi_d_13_pctrl;
+   volatile ulong ebi_d_14_pctrl;
+   volatile ulong dai_bck0_pctrl;
+   volatile ulong mgpio9_pctrl;
+   volatile ulong mgpio6_pctrl;
+   volatile ulong mlcd_db_7_pctrl;
+   volatile ulong mlcd_db_4_pctrl;
+   volatile ulong mlcd_db_2_pctrl;
+   volatile ulong mnand_rybn0_pctrl;
+   volatile ulong gpio1_pctrl;
+   volatile ulong ebi_d_4_pctrl;
+   volatile ulong mdao_clk0_pctrl;
+   volatile ulong mdao_bck0_pctrl;
+   volatile ulong ebi_a_1_cle_pctrl;
+   volatile ulong ebi_ncas_blout_0_pctrl;
+   volatile ulong nand_ncs_3_pctrl;
+   volatile ulong mlcd_db_0_pctrl;
+   volatile ulong ebi_dqm_0_noe_pctrl;
+   volatile ulong ebi_d_0_pctrl;
+   volatile ulong ebi_d_1_pctrl;
+   volatile ulong ebi_d_2_pctrl;
+   volatile ulong ebi_d_3_pctrl;
+   volatile ulong ebi_d_5_pctrl;
+   volatile ulong ebi_d_6_pctrl;
+   volatile ulong ebi_d_7_pctrl;
+   volatile ulong ebi_d_8_pctrl;
+   volatile ulong ebi_d_15_pctrl;
+   volatile ulong dao_data1_pctrl;
+   volatile ulong dao_bck1_pctrl;
+   volatile ulong dao_ws1_pctrl;
+   volatile ulong dai_data0_pctrl;
+   volatile ulong dai_ws0_pctrl;
+   volatile ulong dai_data1_pctrl;
+   volatile ulong dai_bck1_pctrl;
+   volatile ulong dai_ws1_pctrl;
+   volatile ulong sysclk_o_pctrl;
+   volatile ulong pwm_data_pctrl;
+   volatile ulong uart_rxd_pctrl;
+   volatile ulong uart_txd_pctrl;
+   volatile ulong i2c_sda1_pctrl;
+   volatile ulong i2c_scl1_pctrl;
+   volatile ulong clk_256fs_o_pctrl;
+   volatile ulong gpio0_pctrl;
+   volatile ulong gpio2_pctrl;
+   volatile ulong gpio3_pctrl;
+   volatile ulong gpio4_pctrl;
+   volatile ulong gpio_tst_0_dd_pctrl;
+   volatile ulong gpio_tst_1_dd_pctrl;
+   volatile ulong gpio_tst_2_dd_pctrl;
+   volatile ulong gpio_tst_3_dd_pctrl;
+   volatile ulong gpio_tst_4_dd_pctrl;
+   volatile ulong gpio_tst_5_dd_pctrl;
+   volatile ulong gpio_tst_6_dd_pctrl;
+   volatile ulong gpio_tst_7_dd_pctrl;
+   volatile ulong ad_nint_i_pctrl;
+   volatile ulong play_det_i_pctrl;
+   volatile ulong spi_miso_pctrl;
+   volatile ulong spi_mosi_pctrl;
+   volatile ulong spi_cs_in_pctrl;
+   volatile ulong spi_sck_pctrl;
+   volatile ulong spi_cs_out0_pctrl;
+   volatile ulong nand_ncs_0_pctrl;
+   volatile ulong nand_ncs_1_pctrl;
+   volatile ulong nand_ncs_2_pctrl;
+   volatile ulong mlcd_csb_pctrl;
+   volatile ulong mlcd_db_1_pctrl;
+   volatile ulong mlcd_e_rd_pctrl;
+   volatile ulong mlcd_rs_pctrl;
+   volatile ulong mlcd_rw_wr_pctrl;
+   volatile ulong mlcd_db_3_pctrl;
+   volatile ulong mlcd_db_5_pctrl;
+   volatile ulong mlcd_db_6_pctrl;
+   volatile ulong mlcd_db_8_pctrl;
+   volatile ulong mlcd_db_9_pctrl;
+   volatile ulong mlcd_db_10_pctrl;
+   volatile ulong mlcd_db_11_pctrl;
+   volatile ulong mlcd_db_12_pctrl;
+   volatile ulong mlcd_db_13_pctrl;
+   volatile ulong mlcd_db_14_pctrl;
+   volatile ulong mlcd_db_15_pctrl;
+   volatile ulong mgpio5_pctrl;
+   volatile ulong mgpio7_pctrl;
+   volatile ulong mgpio8_pctrl;
+   volatile ulong mgpio10_pctrl;
+   volatile ulong mnand_rybn1_pctrl;
+   volatile ulong mnand_rybn2_pctrl;
+   volatile ulong mnand_rybn3_pctrl;
+   volatile ulong muart_cts_n_pctrl;
+   volatile ulong muart_rts_n_pctrl;
+   volatile ulong mdao_data0_pctrl;
+   volatile ulong mdao_ws0_pctrl;
+   volatile ulong ebi_nras_blout_1_pctrl;
+   volatile ulong ebi_a_0_ale_pctrl;
+   volatile ulong ebi_nwe_pctrl;
+   volatile ulong eshctrl_sup4;
+   volatile ulong eshctrl_sup8;
+ } SYSCREG_REGS_T;
+ 
+ /***********************************************************************
+  * SYSREGS Pad control register definitions
+  **********************************************************************/
+ #define SYSREG_PCTRL_PULLUP     _SBF(1, 0x00)
+ #define SYSREG_PCTRL_PULLDOWN   _SBF(1, 0x03)
+ #define SYSREG_PCTRL_RPTR       _SBF(1, 0x01)
+ #define SYSREG_PCTRL_INPUT      _SBF(1, 0x02)
+ 
+ /* Macro pointing to SysRegs registers */
+ #define SYS_REGS  ((SYSCREG_REGS_T  *)(SYSCREG_BASE))
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_SYSREG_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_timer_driver.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_timer_driver.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_timer_driver.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_timer_driver.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,577 ----
+ /***********************************************************************
+  * $Id:: lpc313x_timer_driver.c 1355 2008-11-25 00:31:05Z pdurgesh     $
+  *
+  * Project: LPC313x timer driver
+  *
+  * Description:
+  *     This file contains driver support for the LPC313x timer.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  *********************************************************************/
+ 
+ #include "lpc313x_timer_driver.h"
+ #include "lpc313x_cgu_driver.h"
+ 
+ /***********************************************************************
+  * Timer driver package data
+ ***********************************************************************/
+ 
+ /* Timer device configuration structure type */
+ typedef struct
+ {
+   uchar id;
+   uchar init;
+   uchar clk_id;
+   uchar reset_id;
+   TIMER_REGS_T *regptr;
+ } TIMER_CFG_T;
+ 
+ /* Timer driver data */
+ static TIMER_CFG_T g_tmr_cfg [4] =
+ {
+   {0, 0, (uchar)CGU_SB_TIMER0_PCLK_ID, (uchar)TIMER0_PNRES_SOFT, TIMER_CNTR0},
+   {1, 0, (uchar)CGU_SB_TIMER1_PCLK_ID, (uchar)TIMER1_PNRES_SOFT, TIMER_CNTR1},
+   {2, 0, (uchar)CGU_SB_TIMER2_PCLK_ID, (uchar)TIMER2_PNRES_SOFT, TIMER_CNTR2},
+   {3, 0, (uchar)CGU_SB_TIMER3_PCLK_ID, (uchar)TIMER3_PNRES_SOFT, TIMER_CNTR3}
+ };
+ 
+ /***********************************************************************
+  * Timer driver private functions
+  **********************************************************************/
+ /***********************************************************************
+  *
+  * Function: timer_ptr_to_timer_num
+  *
+  * Purpose: Convert a timer register pointer to a timer number
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     pTimer : Pointer to a timer register set
+  *
+  * Outputs: None
+  *
+  * Returns: The timer number (0 to 3) or -1 if register pointer is bad
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ long timer_ptr_to_timer_num(TIMER_REGS_T *pTimer)
+ {
+   long tnum = -1;
+ 
+   if (pTimer == TIMER_CNTR0)
+   {
+     tnum = 0;
+   }
+   else if (pTimer == TIMER_CNTR1)
+   {
+     tnum = 1;
+   }
+   else if (pTimer == TIMER_CNTR2)
+   {
+     tnum = 2;
+   }
+   else if (pTimer == TIMER_CNTR3)
+   {
+     tnum = 3;
+   }
+ 
+   return tnum;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: timer_usec_to_val
+  *
+  * Purpose: Convert a time to a timer count value
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     clk_id : Timer clock ID
+  *     usec   : Time in microseconds
+  *
+  * Outputs: None
+  *
+  * Returns: The number of required clock ticks to give the time delay
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ ulong timer_usec_to_val(CGU_CLOCK_ID_T clk_id, ulong usec, ulong* pcon)
+ {
+   unsigned long long clkdlycnt;
+   unsigned long long freq;
+ 
+   /* Determine the value to exceed before the count reaches the desired
+      delay time */
+   freq = (unsigned long long)cgu_get_clk_freq(clk_id);
+   if ((freq > 1000000) && (pcon != NULL))
+   {
+     /* if timer freq is greater than 1MHz use pre-dividers */
+     *pcon &= ~TM_CTRL_PS_MASK;
+     if (usec > 100000)
+     {
+       /* use divide by 256 pre-divider for delay greater than 100 msec*/
+       *pcon |= TM_CTRL_PS256;
+       /* divide by 256 */
+       freq = freq >> 8;
+     }
+     else if (usec > 1000)
+     {
+       /* use divide by 16 pre-divider for delay greater than 1 msec*/
+       *pcon |= TM_CTRL_PS16;
+       /* divide by 16 */
+       freq = freq >> 4;
+     }
+   }
+ 
+   clkdlycnt =	((freq * (unsigned long long)usec) / 1000000);
+ 
+   return (ulong)clkdlycnt;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: timer_delay_cmn
+  *
+  * Purpose: Delay for a period of microseconds
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     pTimer: Pointer to timer register set to use
+  *     usec  :  the delay time in microseconds
+  *
+  * Outputs: None
+  *
+  * Returns: The clock rate of the timer in Hz, or 0 if invalid
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void timer_delay_cmn(TIMER_REGS_T* pTimerRegs, ulong usec)
+ {
+   ulong control = 0;
+   ulong clkdlycnt;
+   TIMER_CFG_T *pTimer = NULL;
+   long tnum = timer_ptr_to_timer_num(pTimerRegs);
+ 
+   /* check if valid regs pointer is passed. If not find a free timer.*/
+   if (tnum < 0)
+   {
+     tnum = 3;
+     while (tnum >= 0)
+     {
+       if (g_tmr_cfg[tnum].init == 0)
+         break;
+ 
+       tnum--;
+     }
+   }
+   /* no timer is free so simply return */
+   if (tnum < 0)
+   {
+     return;
+   }
+ 
+   /* get timer device config structure */
+   pTimer = &g_tmr_cfg[tnum];
+ 
+   /* Enable timer system clock */
+   cgu_clk_en_dis((CGU_CLOCK_ID_T)pTimer->clk_id, 1);
+ 
+   /* Determine the value to exceed before the count reaches the desired
+      delay time */
+   clkdlycnt = timer_usec_to_val((CGU_CLOCK_ID_T)pTimer->clk_id, usec, &control);
+ 
+   /* Reset timer */
+   pTimer->regptr->control &= ~TM_CTRL_ENABLE;
+   pTimer->regptr->load = clkdlycnt;
+ 
+   /* Enable the timer in free running mode*/
+   pTimer->regptr->control = control | TM_CTRL_ENABLE;
+ 
+   /* Loop until terminal count matches or exceeds computed delay count */
+   while (pTimer->regptr->value <= clkdlycnt);
+ 
+   /* Disable timer system clock */
+   cgu_clk_en_dis((CGU_CLOCK_ID_T)pTimer->clk_id, 0);
+ 
+   /* Stop timer */
+   pTimer->regptr->control &= ~TM_CTRL_ENABLE;
+ }
+ 
+ /***********************************************************************
+  * Timer driver public functions
+  **********************************************************************/
+ 
+ /***********************************************************************
+  *
+  * Function: timer_open
+  *
+  * Purpose: Open the timer
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     ipbase: Pointer to a timer peripheral block
+  *     arg   : Not used
+  *
+  * Outputs: None
+  *
+  * Returns: The pointer to a timer config structure or NULL
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ long timer_open(void *ipbase,
+                   long arg)
+ {
+   TIMER_CFG_T *pTimer;
+   long tnum, tptr = (long) NULL;
+ 
+   /* Try to find a matching timer number based on the pass pointer */
+   tnum = timer_ptr_to_timer_num((TIMER_REGS_T *) ipbase);
+   if (tnum >= 0)
+   {
+     pTimer = &g_tmr_cfg[tnum];
+     /* Has the timer been previously initialized? */
+     if (pTimer->init == 0)
+     {
+       /* Timer is free */
+       pTimer->init = 1;
+       pTimer->regptr = (TIMER_REGS_T *) ipbase;
+ 
+       /* Enable timer system clock */
+       cgu_clk_en_dis((CGU_CLOCK_ID_T)pTimer->clk_id, 1);
+ 
+       /* Setup default timer state as standard timer mode, timer
+          disabled and all match and counters disabled */
+       cgu_soft_reset_module((CGU_MOD_ID_T)pTimer->reset_id);
+       /*
+       pTimer->regptr->control &= ~TM_CTRL_ENABLE;
+       pTimer->regptr->clear = 1;
+       pTimer->regptr->load = 0;
+       */
+       /* Return pointer to specific timer structure */
+       tptr = (long) pTimer;
+     }
+   }
+ 
+   return tptr;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: timer_close
+  *
+  * Purpose: Close the timer
+  *
+  * Processing:
+  *     If init is not 1, then return _ERROR to the caller as the
+  *     device was not previously opened. Otherwise, disable the timers,
+  *     set init to 0, and return _NO_ERROR to the caller.
+  *
+  * Parameters:
+  *     devid: Pointer to timer config structure
+  *
+  * Outputs: None
+  *
+  * Returns: The status of the close operation
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ STATUS timer_close(long devid)
+ {
+   TIMER_CFG_T *pTimer;
+   STATUS status = _ERROR;
+ 
+   /* Get timer device structure */
+   pTimer = (TIMER_CFG_T *) devid;
+   if (pTimer->init == 1)
+   {
+     /* Disable all timer fucntions */
+     pTimer->regptr->control &= ~TM_CTRL_ENABLE;
+     pTimer->regptr->clear = 1;
+     pTimer->regptr->load = 0;
+ 	pTimer->init = 0;
+ 
+     /* Disable timer system clock */
+     cgu_clk_en_dis((CGU_CLOCK_ID_T)pTimer->clk_id, 0);
+   }
+ 
+   return status;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: timer_ioctl
+  *
+  * Purpose: Timer configuration block
+  *
+  * Processing:
+  *     This function is a large case block. Based on the passed function
+  *     and option values, set or get the appropriate timer parameter.
+  *
+  * Parameters:
+  *     devid: Pointer to timer config structure
+  *     cmd:   ioctl command
+  *     arg:   ioctl argument
+  *
+  * Outputs: None
+  *
+  * Returns: The status of the ioctl operation
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ STATUS timer_ioctl(long devid,
+                    long cmd,
+                    long arg)
+ {
+   ulong tmp;
+   TIMER_CFG_T *pTimer;
+   TMR_CFG_ARG_T *pCfg;
+   long status = _ERROR;
+ 
+   /* Get timer device structure */
+   pTimer = (TIMER_CFG_T *) devid;
+   
+   if (pTimer->init == 1)
+   {
+     status = _NO_ERROR;
+ 
+     switch (cmd)
+     {
+       case TMR_ENABLE:
+         if (arg != 0)
+         {
+           /* Enable the timer */
+           pTimer->regptr->control |= TM_CTRL_ENABLE;
+         }
+         else
+         {
+           /* Disable the timer */
+           pTimer->regptr->control &= ~TM_CTRL_ENABLE;
+         }
+         break;
+ 
+       case TMR_RESET:
+         cgu_soft_reset_module((CGU_MOD_ID_T)pTimer->reset_id);
+         break;
+ 
+       case TMR_CLEAR_INTS:
+         pTimer->regptr->clear = 1;
+         break;
+ 
+       case TMR_SET_CFG:
+         pCfg = (TMR_CFG_ARG_T*)arg;
+         tmp = 0;
+         pTimer->regptr->load = timer_usec_to_val((CGU_CLOCK_ID_T)pTimer->clk_id, pCfg->usecs, &tmp);
+         /* set periodic if requested */
+         if (pCfg->periodic)
+         {
+           tmp |= TM_CTRL_PERIODIC;
+         }
+ 
+         if (pCfg->enable)
+         {
+           /* Enable the timer */
+           tmp |= TM_CTRL_ENABLE;
+         }
+         pTimer->regptr->clear = 1;
+         pTimer->regptr->control = tmp;
+         break;
+ 
+       case TMR_SET_LOAD:
+         pTimer->regptr->load = (ulong) arg;
+         break;
+ 
+       case TMR_SET_PERIODIC_MODE:
+         if (arg != 0)
+           pTimer->regptr->load = (ulong) arg;
+ 
+         pTimer->regptr->control |= TM_CTRL_PERIODIC;
+         break;
+ 
+       case TMR_SET_FREERUN_MODE:
+         if (arg != 0)
+           pTimer->regptr->load = (ulong) arg;
+ 
+         pTimer->regptr->control &= ~TM_CTRL_PERIODIC;
+         break;
+ 
+       case TMR_SET_PSCALE:
+         tmp = pTimer->regptr->control & ~TM_CTRL_PS_MASK;
+         tmp = tmp | (arg & TM_CTRL_PS_MASK);
+         pTimer->regptr->control = tmp;
+         break;
+ 
+       case TMR_SET_MSECS:
+         arg = arg * 1000;
+       case TMR_SET_USECS:
+         tmp = pTimer->regptr->control;
+         pTimer->regptr->load = timer_usec_to_val((CGU_CLOCK_ID_T)pTimer->clk_id, arg, &tmp);
+         pTimer->regptr->control = tmp;
+         break;
+ 
+       case TMR_GET_STATUS:
+         /* Return a timer status */
+         switch (arg)
+         {
+           case TMR_GET_COUNT:
+             status = pTimer->regptr->value;
+             break;
+ 
+           case TMR_GET_PS_SCALE:
+             status = pTimer->regptr->control & TM_CTRL_PS_MASK;
+             break;
+ 
+           case TMR_GET_CLOCK:
+             status = cgu_get_clk_freq((CGU_CLOCK_ID_T)pTimer->clk_id);
+             break;
+ 
+           default:
+             /* Unsupported parameter */
+             status = LPC_BAD_PARAMS;
+             break;
+         }
+         break;
+ 
+       default:
+         /* Unsupported parameter */
+         status = LPC_BAD_PARAMS;
+     }
+   }
+ 
+   return status;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: timer_read
+  *
+  * Purpose: Timer read function (stub only)
+  *
+  * Processing:
+  *     Return 0 to the caller.
+  *
+  * Parameters:
+  *     devid:     Pointer to timer descriptor
+  *     buffer:    Pointer to data buffer to copy to
+  *     max_bytes: Number of bytes to read
+  *
+  * Outputs: None
+  *
+  * Returns: Number of bytes actually read (always 0)
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ long timer_read(long devid,
+                   void *buffer,
+                   long max_bytes)
+ {
+   return 0;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: timer_write
+  *
+  * Purpose: Timer write function (stub only)
+  *
+  * Processing:
+  *     Return 0 to the caller.
+  *
+  * Parameters:
+  *     devid:   Pointer to timer descriptor
+  *     buffer:  Pointer to data buffer to copy from
+  *     n_bytes: Number of bytes to write
+  *
+  * Outputs: None
+  *
+  * Returns: Number of bytes actually written (always 0)
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ long timer_write(long devid,
+                    void *buffer,
+                    long n_bytes)
+ {
+   return 0;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: timer_wait_ms
+  *
+  * Purpose: Delay for msec milliseconds (minimum)
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     pTimerRegs: Pointer to timer register set to use
+  *     msec  :  the delay time in milliseconds
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes:
+  *     Use of this function will destroy any previous timer settings
+  *     (for the specific timer used) and should not be used if that
+  *     timer is simultaneously being used for something else.
+  *
+  **********************************************************************/
+ void timer_wait_ms(TIMER_REGS_T *pTimerRegs, ulong msec)
+ {
+   timer_delay_cmn(pTimerRegs, (msec * 1000));
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: timer_wait_us
+  *
+  * Purpose: Delay for usec microseconds (minimum)
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     pTimerRegs: Pointer to timer register set to use
+  *     usec  :  the delay time in microseconds
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes:
+  *     Use of this function will destroy any previous timer settings
+  *     (for the specific timer used) and should not be used if that
+  *     timer is simultaneously being used for something else.
+  *
+  **********************************************************************/
+ void timer_wait_us(TIMER_REGS_T *pTimerRegs, ulong usec)
+ {
+   timer_delay_cmn(pTimerRegs, usec);
+ }
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_timer_driver.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_timer_driver.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_timer_driver.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_timer_driver.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,134 ----
+ /***********************************************************************
+  * $Id:: lpc313x_timer_driver.h 1201 2008-10-03 19:25:38Z pdurgesh     $
+  *
+  * Project: LPC313X timer driver
+  *
+  * Description:
+  *     This file contains driver support for the LPC313X timer.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  *********************************************************************/
+ 
+ #ifndef LPC313X_TIMER_DRIVER_H
+ #define LPC313X_TIMER_DRIVER_H
+ 
+ #include "lpc313x_timer.h"
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+  * Timer device configuration commands (IOCTL commands and arguments)
+  **********************************************************************/
+ 
+ /* Timer device commands (IOCTL commands) */
+ typedef enum
+ {
+   TMR_ENABLE,      /* Enable or disable the timer, use arg with a
+               value of '1' or '0' in arg to enable or
+               disable */
+   TMR_RESET,       /* Resets the timer count and prescale values, arg
+               value does not matter */
+   /* Clear a pending interrupt */
+   TMR_CLEAR_INTS,
+   /* Configure timer to the specified mode & duration*/
+   TMR_SET_CFG,
+   /* Set a load count value, use arg as load value */
+   TMR_SET_LOAD,
+   /* Configure timer/counter to periodic mode, use arg as load
+   value*/
+   TMR_SET_PERIODIC_MODE,
+   /* Configure timer/counter to free running mode, use arg as load
+   value*/
+   TMR_SET_FREERUN_MODE,
+   /* Set a prescale divider. Valid arg values are TM_CTRL_PS1 or
+   TM_CTRL_PS16 or TM_CTRL_PS256*/
+   TMR_SET_PSCALE,
+   TMR_SET_MSECS,   /* Set the prescale register count to initiate a
+               terminal count increment in the number of
+             milliseconds specified in arg */
+   TMR_SET_USECS,   /* Set the prescale register count to initiate a
+               terminal count increment in the number of
+             microseconds specified in arg */
+   TMR_GET_STATUS  /* Get a timer status, use a pointer to the
+              MST_ARG_T structure with the timer enumeration
+              and a arg value of MST_IOCTL_STS_T */
+ } TMR_IOCTL_CMD_T;
+ 
+ /* Timer device arguments for TMR_GET_STATUS command (IOCTL
+    arguments) */
+ typedef enum
+ {
+   TMR_GET_COUNT,   /* Returns the current timer count */
+   TMR_GET_PS_SCALE, /* Returns the current prescaler count */
+   TMR_GET_CLOCK  /* Returns the clock rate (Hz) driving the clock */
+ } MST_ARG_T;
+ 
+ /* Structure used for some IOCTLS */
+ typedef struct
+ {
+   long arg1;
+   ulong arg2;
+ } TMR_ARG_T;
+ 
+ /* Structure used for TMR_SET_CFG */
+ typedef struct
+ {
+   ulong periodic;
+   ulong usecs;
+   ulong enable;
+ } TMR_CFG_ARG_T;
+ 
+ /***********************************************************************
+  * TIMER driver API functions
+  **********************************************************************/
+ 
+ /* Open the timer */
+ long timer_open(void *ipbase,
+                   long arg);
+ 
+ /* Close the timer */
+ STATUS timer_close(long devid);
+ 
+ /* Timer configuration block */
+ STATUS timer_ioctl(long devid,
+                    long cmd,
+                    long arg);
+ 
+ /* Timer read function (stub only) */
+ long timer_read(long devid,
+                   void *buffer,
+                   long max_bytes);
+ 
+ /* Timer write function (stub only) */
+ long timer_write(long devid,
+                    void *buffer,
+                    long n_bytes);
+ 
+ /***********************************************************************
+  * Other TIMER driver functions
+  **********************************************************************/
+ 
+ /* Delay for msec milliseconds (minimum) */
+ void timer_wait_ms(TIMER_REGS_T *pTimerRegs, ulong msec);
+ 
+ /* Delay for usec microseconds (minimum) */
+ void timer_wait_us(TIMER_REGS_T *pTimerRegs, ulong usec);
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_TIMER_DRIVER_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_timer.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_timer.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_timer.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_timer.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,76 ----
+ /***********************************************************************
+ * $Id:: lpc313x_timer.h 1180 2008-09-11 19:32:40Z pdurgesh            $
+ *
+ * Project: LPC313X Timer Module definitions
+ *
+ * Description:
+ *     This file contains the structure definitions and manifest
+ *     constants for the LPC313X chip family component:
+ *         Timer Module
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+ 
+ #ifndef LPC313X_TIMER_H
+ #define LPC313X_TIMER_H
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+ * Timer Module Register Structures
+ **********************************************************************/
+ 
+ /* Timer Module Register Structure */
+ typedef volatile struct
+ {
+   /* LSB */
+   volatile ulong load;      /* Timer load               */
+   volatile const ulong value;/* Timer Counter          */
+   volatile ulong control;    /* Timer Control Register */
+   volatile ulong clear;      /* clears the interrupt      */
+   volatile ulong test;       /* validation purpose       */
+   /* MSB */
+ } TIMER_REGS_T;
+ 
+ /**********************************************************************
+ *  Timer Control Register (TimerCtrl) (0x08) Read/Write
+ **********************************************************************/
+ #define TM_CTRL_ENABLE    _BIT(7)
+ #define TM_CTRL_MODE      _BIT(6)
+ #define TM_CTRL_PERIODIC  _BIT(6)
+ #define TM_CTRL_PS1       _SBF(2, 0)
+ #define TM_CTRL_PS16      _SBF(2, 1)
+ #define TM_CTRL_PS256     _SBF(2, 2)
+ #define TM_CTRL_PS_MASK   _SBF(2, 0x3)
+ 
+ /**********************************************************************
+ * Macro to access TIMER registers
+ **********************************************************************/
+ #define TIMER_CNTR0       ((TIMER_REGS_T*)TIMER0_BASE)
+ #define TIMER_CNTR1       ((TIMER_REGS_T*)TIMER1_BASE)
+ #define TIMER_CNTR2       ((TIMER_REGS_T*)TIMER2_BASE)
+ #define TIMER_CNTR3       ((TIMER_REGS_T*)TIMER3_BASE)
+ 
+ 
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_TIMER_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_uart_driver.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_uart_driver.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_uart_driver.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_uart_driver.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,664 ----
+ /***********************************************************************
+  * $Id:: lpc313x_uart_driver.c 1310 2008-11-04 01:47:18Z pdurgesh      $
+  *
+  * Project: LPC313x standard UART driver
+  *
+  * Description:
+  *     This file contains driver support for the LPC313x standard UART
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  *********************************************************************/
+ 
+ #include "lpc313x_uart_driver.h"
+ #include "lpc313x_intc_driver.h"
+ #include "lpc313x_cgu_driver.h"
+ 
+ /***********************************************************************
+  * UART driver package data
+ ***********************************************************************/
+ 
+ /* UART device configuration structure type */
+ typedef struct
+ {
+   UART_REGS_T *regptr;
+   UART_CBS_T cbs;
+   ulong baudrate;
+   ulong uart_init;
+ } UART_CFG_T;
+ 
+ /* UART driver data */
+ static UART_CFG_T uartdat;
+ 
+ /***********************************************************************
+  * UART driver private functions
+  **********************************************************************/
+ 
+ /***********************************************************************
+  *
+  * Function: uart_int_handler
+  *
+  * Purpose: General UART interrupt handler and router
+  *
+  * Processing:
+  *     Handles transmit, receive, and status interrupts for the UART.
+  *     Based on the interrupt status, routes the interrupt to the
+  *     respective callback to be handled by the user application using
+  *     this driver.
+  *
+  * Parameters: None
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: If a callback doesn't exist, the interrupt will be disabled.
+  *
+  **********************************************************************/
+ void uart_int_handler(UART_CFG_T *puartcfg)
+ {
+   volatile ulong tmp;
+ 
+   /* Determine the interrupt source */
+   tmp = puartcfg->regptr->iir_fcr & UART_IIR_INTSRC_MASK;
+   switch (tmp)
+   {
+     case UART_IIR_INTSRC_RXLINE:
+     default:
+       /* RX line status interrupt, needs servicing */
+       if (puartcfg->cbs.rxerrcb != NULL)
+       {
+         puartcfg->cbs.rxerrcb();
+       }
+       else
+       {
+         /* No callback, disable interrupt */
+         puartcfg->regptr->dlm_ie &= ~UART_IE_RXLINE_STS;
+       }
+       break;
+ 
+     case UART_IIR_INTSRC_THRE:
+       /* Disable interrupt, write will re-enable it */
+       if (puartcfg->cbs.txcb != NULL)
+       {
+         puartcfg->cbs.txcb();
+       }
+       break;
+ 
+     case UART_IIR_INTSRC_RDA:
+     case UART_IIR_INTSRC_CTI:
+       /* Receive interrupt, needs servicing */
+       if (puartcfg->cbs.rxcb != NULL)
+       {
+         puartcfg->cbs.rxcb();
+       }
+       else
+       {
+         /* No callback, disable interrupt */
+         puartcfg->regptr->dlm_ie &= ~UART_IE_RDA;
+       }
+       break;
+   }
+ }
+ 
+ 
+ /***********************************************************************
+  *
+  * Function: uart_flush_fifos
+  *
+  * Purpose: Flushes one or both of the UART FIFOs
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     pregs     : Pointer to a UART register base
+  *     flushword : Masked flush value
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void uart_flush_fifos(UART_REGS_T *pregs,
+                       ulong flushword)
+ {
+   pregs->iir_fcr |= (flushword & (UART_FCR_TXFIFO_FLUSH |
+                                   UART_FCR_RXFIFO_FLUSH));
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: uart_set_divisors
+  *
+  * Purpose: Determines best dividers to get a target clock rate
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     puartcfg   : Pointer to UART configuration data
+  *     baudrate   : Desired UART baud rate
+  *
+  * Outputs:
+  *	  baudrate : Sets the estimated buadrate value in puartcfg structre.
+  *
+  * Returns: Error status.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ STATUS uart_set_divisors(UART_CFG_T *puartcfg, ulong baudrate)
+ {
+   STATUS errorStatus = _ERROR;
+ 
+   ulong uClk;
+   ulong calcBaudrate = 0;
+   ulong temp = 0;
+ 
+   ulong mulFracDiv, dividerAddFracDiv;
+   ulong diviser = 0 ;
+   ulong mulFracDivOptimal = 1;
+   ulong dividerAddOptimal = 0;
+   ulong diviserOptimal = 0;
+ 
+   ulong relativeError = 0;
+   ulong relativeOptimalError = 100000;
+ 
+   /* get UART block clock */
+   uClk = cgu_get_clk_freq(CGU_SB_UART_U_CLK_ID);
+ 
+   uClk = uClk >> 4; /* div by 16 */
+   /* In the Uart IP block, baud rate is calculated using FDR and DLL-DLM registers
+    * The formula is :
+    * BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
+    * It involves floating point calculations. That's the reason the formulae are adjusted with
+    * Multiply and divide method.*/
+   /* The value of mulFracDiv and dividerAddFracDiv should comply to the following expressions:
+    * 0 < mulFracDiv <= 15, 0 <= dividerAddFracDiv <= 15 */
+   for (mulFracDiv = 1 ; mulFracDiv <= 15 ;mulFracDiv++)
+   {
+     for (dividerAddFracDiv = 0 ; dividerAddFracDiv <= 15 ;dividerAddFracDiv++)
+     {
+       temp = (mulFracDiv * uClk) / ((mulFracDiv + dividerAddFracDiv));
+ 
+       diviser = temp / baudrate;
+       if ((temp % baudrate) > (baudrate / 2))
+         diviser++;
+ 
+       if (diviser > 2 && diviser < 65536)
+       {
+         calcBaudrate = temp / diviser;
+ 
+         if (calcBaudrate <= baudrate)
+           relativeError = baudrate - calcBaudrate;
+         else
+           relativeError = calcBaudrate - baudrate;
+ 
+         if ((relativeError < relativeOptimalError))
+         {
+           mulFracDivOptimal = mulFracDiv ;
+           dividerAddOptimal = dividerAddFracDiv;
+           diviserOptimal = diviser;
+           relativeOptimalError = relativeError;
+           puartcfg->baudrate = calcBaudrate;
+           if (relativeError == 0)
+             break;
+         }
+       } /* End of if */
+     } /* end of inner for loop */
+     if (relativeError == 0)
+       break;
+   } /* end of outer for loop  */
+ 
+   if (relativeOptimalError < (baudrate / 30))
+   {
+     /* Disable all UART interrupts */
+     puartcfg->regptr->dlm_ie = 0;
+ 
+     /* Set the `Divisor Latch Access Bit` and enable so the DLL/DLM access*/
+     puartcfg->regptr->lcr |= UART_LCR_DIVLATCH_EN;
+     /* Initialise the `Divisor latch LSB` and `Divisor latch MSB` registers */
+     puartcfg->regptr->dll_fifo = UART_LOAD_DLL(diviserOptimal);
+     puartcfg->regptr->dlm_ie = UART_LOAD_DLM(diviserOptimal);
+     puartcfg->regptr->lcr &= ~ UART_LCR_DIVLATCH_EN;
+ 
+     /* Initialise the Fractional Divider Register */
+     puartcfg->regptr->fdr = UART_FDR_MUL_SET(mulFracDivOptimal) | UART_FDR_DIVADD_SET(dividerAddOptimal);
+ 
+     errorStatus = _NO_ERROR;
+   }
+   return errorStatus;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: uart_setup_trans_mode
+  *
+  * Purpose: Sets up a UART data transfer mode
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     puartcfg   : Pointer to UART configuration data
+  *     puartsetup : Pointer to a UART transfer mode setup structure
+  *
+  * Outputs: None
+  *
+  * Returns: _NO_ERROR if setup was ok, otherwise _ERROR
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ STATUS uart_setup_trans_mode(UART_CFG_T *puartcfg,
+                              UART_CONTROL_T *puartsetup)
+ {
+   ulong tmp = 0;
+   STATUS err = _NO_ERROR;
+ 
+   /* Setup stop bits */
+   switch (puartsetup->stopbits)
+   {
+     case 2:
+       tmp |= UART_LCR_STOP2BITS;
+     case 1:
+       break;
+ 
+     default:
+       err = _ERROR;
+       break;
+   }
+ 
+   /* Setup parity */
+   switch (puartsetup->parity)
+   {
+     case UART_PAR_EVEN:
+       tmp |= (UART_LCR_PARITY_EVEN | UART_LCR_PARITY_ENABLE);
+       break;
+ 
+     case UART_PAR_ODD:
+       tmp |= (UART_LCR_PARITY_ODD | UART_LCR_PARITY_ENABLE);
+       break;
+ 
+     case UART_PAR_NONE:
+       break;
+ 
+     default:
+       err = _ERROR;
+       break;
+   }
+ 
+   /* Setup data bits */
+   switch (puartsetup->databits)
+   {
+     case 5:
+       tmp |= UART_LCR_WLEN_5BITS;
+       break;
+ 
+     case 6:
+       tmp |= UART_LCR_WLEN_6BITS;
+       break;
+ 
+     case 7:
+       tmp |= UART_LCR_WLEN_7BITS;
+       break;
+ 
+     case 8:
+       tmp |= UART_LCR_WLEN_8BITS;
+       break;
+ 
+     default:
+       err = _ERROR;
+       break;
+   }
+ 
+   /* Find closest baud rate for desired clock frequency */
+   err = uart_set_divisors(puartcfg, puartsetup->baud_rate);
+ 
+   if (err == _NO_ERROR)
+   {
+     /* Set new UART settings */
+     puartcfg->regptr->lcr = tmp;
+   }
+ 
+   return err;
+ }
+ 
+ /***********************************************************************
+  * UART driver public functions
+  **********************************************************************/
+ 
+ /***********************************************************************
+  *
+  * Function: uart_open
+  *
+  * Purpose: Open the UART
+  *
+  * Processing:
+  *     See function.
+  *
+  * Parameters:
+  *     ipbase: Pointer to a UART peripheral block
+  *     arg   : Pointer to UART setup structure or NULL
+  *
+  * Outputs: None
+  *
+  * Returns: The pointer to a UART config structure or NULL
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ long uart_open(void *ipbase,
+                  long arg)
+ {
+   UART_CONTROL_T uarttran;
+   volatile ulong tmp;
+   long tptr = (long) NULL;
+   UART_CONTROL_T *pucfg = (UART_CONTROL_T *) arg;
+ 
+   /* Has the UART been previously initialized? */
+   if (uartdat.uart_init == 0)
+   {
+     /* UART is free */
+     uartdat.uart_init = 1;
+     uartdat.regptr = (UART_REGS_T *) ipbase;
+ 
+     /* Enable UART system clock */
+     cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
+     cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
+ 
+     /* No callbacks by default */
+     uartdat.cbs.rxcb = NULL;
+     uartdat.cbs.txcb = NULL;
+     uartdat.cbs.rxerrcb = NULL;
+ 
+     /* Install UART interrupt handler - nah, lets not, wonder if we need em :) 
+     int_install_irq_handler(IRQ_UART, uart_int_handler);
+ 	*/
+ 
+     /* Setup default UART state for 115200N81 with FIFO mode */
+     if (pucfg == NULL)
+     {
+       uarttran.baud_rate = 115200;
+       uarttran.parity = UART_PAR_NONE;
+       uarttran.stopbits = 1;
+       uarttran.databits = 8;
+       uart_setup_trans_mode(&uartdat, &uarttran);
+     }
+     else
+     {
+       uart_setup_trans_mode(&uartdat, pucfg);
+     }
+ 
+     /* Clear FIFOs, set FIFO level, and pending interrupts */
+     uartdat.regptr->iir_fcr = (UART_FCR_RXFIFO_TL16 |
+                                UART_FCR_FIFO_EN | UART_FCR_TXFIFO_FLUSH |
+                                UART_FCR_RXFIFO_FLUSH);
+     tmp = uartdat.regptr->iir_fcr;
+     tmp = uartdat.regptr->lsr;
+ 
+     /* Receive and RX line status interrupts enabled */
+     uartdat.regptr->dlm_ie = (UART_IE_RXLINE_STS |
+                               UART_IE_RDA | UART_IE_THRE);
+ 
+     /* Return pointer to specific UART structure */
+     tptr = (long) & uartdat;
+   }
+ 
+   return tptr;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: uart_close
+  *
+  * Purpose: Close the UART
+  *
+  * Processing:
+  *     If init is not 1, then return _ERROR to the caller as the
+  *     device was not previously opened. Otherwise, disable the UART,
+  *     set init to 0, and return _NO_ERROR to the caller.
+  *
+  * Parameters:
+  *     devid: Pointer to UART config structure
+  *
+  * Outputs: None
+  *
+  * Returns: The status of the close operation
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ STATUS uart_close(long devid)
+ {
+   UART_CFG_T *puart = (UART_CFG_T *) devid;
+   STATUS status = _ERROR;
+ 
+   /* Close and disable device if it was previously initialized */
+   if (puart->uart_init == 1)
+   {
+     /* Disable interrupts */
+     puart->regptr->dlm_ie = 0;
+ 
+     /* Turn off clocking */
+     cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 0);
+     cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 0);
+   }
+ 
+   return status;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: uart_ioctl
+  *
+  * Purpose: UART configuration block
+  *
+  * Processing:
+  *     This function is a large case block. Based on the passed function
+  *     and option values, set or get the appropriate UART parameter.
+  *
+  * Parameters:
+  *     devid: Pointer to UART config structure
+  *     cmd:   ioctl command
+  *     arg:   ioctl argument
+  *
+  * Outputs: None
+  *
+  * Returns: The status of the ioctl operation
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ STATUS uart_ioctl(long devid,
+                   long cmd,
+                   long arg)
+ {
+   UART_CBS_T *pcbs;
+   UART_CFG_T *puart = (UART_CFG_T *) devid;
+   STATUS status = _ERROR;
+ 
+   /* Close and disable device if it was previously initialized */
+   if (puart->uart_init == 1)
+   {
+     status = _NO_ERROR;
+ 
+     switch (cmd)
+     {
+       case UART_CLEAR_FIFOS:
+         uart_flush_fifos(puart->regptr, (ulong) arg);
+         break;
+ 
+       case UART_SETUP_TRANSFER:
+         uart_setup_trans_mode(puart, (UART_CONTROL_T *) arg);
+         break;
+ 
+       case UART_LOOPBACK_EN:
+         if (arg != 0)
+         {
+           puart->regptr->mcr |= UART_MCR_LOOP;
+         }
+         else
+         {
+           puart->regptr->mcr &= ~UART_MCR_LOOP;
+         }
+         break;
+ 
+       case UART_FORCE_BREAK:
+         if (arg != 0)
+         {
+           puart->regptr->lcr |= UART_LCR_BREAK_EN;
+         }
+         else
+         {
+           puart->regptr->lcr &= ~UART_LCR_BREAK_EN;
+         }
+         break;
+ 
+       case UART_INSTALL_CBS:
+         pcbs = (UART_CBS_T *) arg;
+         puart->cbs.rxcb = pcbs->rxcb;
+         puart->cbs.txcb = pcbs->txcb;
+         puart->cbs.rxerrcb = pcbs->rxerrcb;
+         break;
+ 
+       case UART_GET_STATUS:
+         /* Return a UART status */
+         switch (arg)
+         {
+           case UART_GET_IP_CLOCK:
+             status = cgu_get_clk_freq(CGU_SB_UART_U_CLK_ID);
+             break;
+ 
+           case UART_GET_DERIVED_CLOCK:
+             status = puart->baudrate;
+             break;
+ 
+           case UART_GET_LINE_STATUS:
+             status = (STATUS) puart->regptr->lsr;
+             break;
+ 
+           default:
+             /* Unsupported parameter */
+             status = LPC_BAD_PARAMS;
+             break;
+         }
+         break;
+ 
+       default:
+         /* Unsupported parameter */
+         status = LPC_BAD_PARAMS;
+     }
+   }
+ 
+   return status;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: uart_read
+  *
+  * Purpose: UART read function (stub only)
+  *
+  * Processing:
+  *     Read the passed number of bytes in the passed buffer, or the
+  *     amount of data that is available, whichever is less.
+  *
+  * Parameters:
+  *     devid:     Pointer to UART descriptor
+  *     buffer:    Pointer to data buffer to copy to
+  *     max_bytes: Number of bytes to read
+  *
+  * Outputs: None
+  *
+  * Returns: Number of bytes actually read
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ long uart_read(long devid,
+                  void *buffer,
+                  long max_bytes)
+ {
+   long bread = 0;
+   UART_CFG_T *puart = (UART_CFG_T *) devid;
+   UART_REGS_T *pregs = puart->regptr;
+   unsigned char *buff8 = (unsigned char *) buffer;
+ 
+   while ((max_bytes > 0) && ((pregs->lsr & UART_LSR_RDR) != 0))
+   {
+     *buff8 = (unsigned char) pregs->dll_fifo;
+     buff8++;
+     max_bytes--;
+     bread++;
+   }
+ 
+   return bread;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: uart_write
+  *
+  * Purpose: Timer UART function
+  *
+  * Processing:
+  *     Write the passed number of bytes in the passed buffer to the UART
+  *     FIFO, or the amounf of data that the FIFO can handle.
+  *
+  * Parameters:
+  *     devid:   Pointer to UART descriptor
+  *     buffer:  Pointer to data buffer to copy from
+  *     n_bytes: Number of bytes to write
+  *
+  * Outputs: None
+  *
+  * Returns: Number of bytes actually written (always 0)
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ long uart_write(long devid,
+                   void *buffer,
+                   long n_bytes)
+ {
+   long bwrite = 0;
+   UART_CFG_T *puart = (UART_CFG_T *) devid;
+   UART_REGS_T *pregs = puart->regptr;
+   unsigned char *buff8 = (unsigned char *) buffer;
+ 
+   /* Only add data if the current FIFO level can be determined */
+   while ((pregs->lsr & UART_LSR_TEMT) == 0){}
+ 
+   if ((pregs->lsr & UART_LSR_TEMT) != 0)
+   {
+     /* Assuming TX fifo is 32 byte deep. */
+     if (n_bytes > 32)
+     {
+       n_bytes = 32;
+     }
+     while (n_bytes > 0)
+     {
+       pregs->dll_fifo = (ulong) * buff8;
+       buff8++;
+       n_bytes--;
+       bwrite++;
+     }
+   }
+ 
+   return bwrite;
+ }
+ 
+ 
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_uart_driver.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_uart_driver.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_uart_driver.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_uart_driver.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,120 ----
+ /***********************************************************************
+  * $Id:: lpc313x_uart_driver.h 1180 2008-09-11 19:32:40Z pdurgesh      $
+  *
+  * Project: LPC3xxx standard UART driver
+  *
+  * Description:
+  *     This file contains driver support for the LPC313X standard UART.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  *********************************************************************/
+ 
+ #ifndef LPC313X_UART_DRIVER_H
+ #define LPC313X_UART_DRIVER_H
+ 
+ #include "lpc313x_uart.h"
+ #include "lpc_params.h"
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+  * UART device configuration commands (IOCTL commands and arguments)
+  **********************************************************************/
+ 
+ /* Structure containing callback functions for data FIFO management
+    and error management */
+ typedef struct
+ {
+   /* Pointer to RX FIFO callback, called when their is data to
+      read in the RX FIFO */
+   PFV rxcb;
+   /* Pointer to TX FIFO callback, called when transmit data is
+      needed in the FIFO */
+   PFV txcb;
+   /* Pointer to error/break handler callback, called when their is
+      a frame, parity, RX FIFO overrun error, or a break */
+   PFV rxerrcb;
+ } UART_CBS_T;
+ 
+ /* UART device commands (IOCTL commands) */
+ typedef enum
+ {
+   /* Clear RX and/or TX UART FIFOs, use arg as a OR'ed combination
+      of UART_FCR_TXFIFO_FLUSH and/or UART_FCR_RXFIFO_FLUSH to
+      select which FIFOs to clear */
+   UART_CLEAR_FIFOS,
+   /* Setup general UART parameters, use arg as a pointer to a
+      structure of type UART_CONTROL_T */
+   UART_SETUP_TRANSFER,
+   /* Enable or disable loopback mode for the UART, use arg as '0'
+      to disable, or any other value to enable */
+   UART_LOOPBACK_EN,
+   /* Force a break condition on the TX line, use arg as '0' to clear
+      the break, or any other value to set a break */
+   UART_FORCE_BREAK,
+   /* Install UART data handler callback functions, use arg as a
+      pointer to type UART_CBS_T */
+   UART_INSTALL_CBS,
+   /* Get a UART status, use arg as value of type UART_IOCTL_STS_T */
+   UART_GET_STATUS
+ } UART_IOCTL_CMD_T;
+ 
+ /* UART device arguments for UART_GET_STATUS command (IOCTL
+    arguments) */
+ typedef enum
+ {
+   /* Returns the clock rate driving the standard UARTS */
+   UART_GET_IP_CLOCK,
+   /* Returns the actual clock rate the UARTs will transfer data at,
+      after division */
+   UART_GET_DERIVED_CLOCK,
+   /* Returns the current line status register value, this is useful
+      for popping the FIFO one byte at a time and getting the status
+      for each byte, or using polling operation */
+   UART_GET_LINE_STATUS
+ } UART_IOCTL_STS_T;
+ 
+ /***********************************************************************
+  * UART driver API functions
+  **********************************************************************/
+ 
+ /* Open the UART */
+ long uart_open(void *ipbase,
+                  long arg);
+ 
+ /* Close the UART */
+ STATUS uart_close(long devid);
+ 
+ /* UART configuration block */
+ STATUS uart_ioctl(long devid,
+                   long cmd,
+                   long arg);
+ 
+ /* UART read function */
+ long uart_read(long devid,
+                  void *buffer,
+                  long max_bytes);
+ 
+ /* UART write function */
+ long uart_write(long devid,
+                   void *buffer,
+                   long n_bytes);
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_UART_DRIVER_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_uart.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_uart.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc313x_uart.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc313x_uart.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,214 ----
+ /***********************************************************************
+ * $Id:: lpc313x_uart.h 1180 2008-09-11 19:32:40Z pdurgesh             $
+ *
+ * Project: LPC313X UART definitions
+ *
+ * Description:
+ *     This file contains the structure definitions and manifest
+ *     constants for the LPC313X chip family component:
+ *         Universal Asynchronous Receiver Transmitter (UART)
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+ 
+ #ifndef LPC313X_UART_H
+ #define LPC313X_UART_H
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+ * Universal Asynchronous Receiver Transmitter (UART) Register Structures
+ **********************************************************************/
+ 
+ /* UART Module Register Structure */
+ typedef volatile struct
+ {
+   /* LSB*/
+   volatile ulong dll_fifo;     /* UART data FIFO/holding/dll reg */
+   volatile ulong dlm_ie;       /* UART high divisor/int enable reg */
+   volatile ulong iir_fcr;      /* UART int pending/FIFO contrl reg */
+   volatile ulong lcr;         /* Line Control Register */
+   volatile ulong mcr;         /* Modem Control Register */
+   volatile const ulong lsr;   /* Line Status Register*/
+   volatile const ulong msr;   /* Modem Status Register*/
+   volatile ulong scr;         /* Scratch Pad Register */
+   volatile ulong acr;         /* Auto-baud Control Register */
+   volatile ulong icr;         /* Irda Control Register */
+   volatile ulong fdr;         /* Fractional Divider Register */
+   volatile const ulong unused;/* Unused registers */
+   volatile ulong pop;         /* NHP Pop Register */
+   volatile ulong mode;        /* NHP Mode Selection Register */
+   volatile const ulong unused1[999];/* Unused registers */
+   volatile const ulong cfg;   /* Configuration Register */
+   volatile ulong intce;       /* Interrupt Clear Enable Register */
+   volatile ulong intse;       /* Interrupt Set Enable Register */
+   volatile const ulong ints;  /* Interrupt Status Register */
+   volatile const ulong inte;  /* Interrupt Enable Register */
+   volatile ulong intcs;       /* Interrupt Clear Status Register */
+   volatile ulong intss;       /* Interrupt Set Status Register */
+   volatile const ulong unused2[3]; /* Unused registers */
+   volatile const ulong mid;   /* Module Identification Register */
+   /* MSB*/
+ } UART_REGS_T;
+ 
+ /**********************************************************************
+ * dll and dlm register definitions
+ **********************************************************************/
+ /* Macro for loading most and least significant halfs of divisors */
+ #define UART_LOAD_DLL(div)          ((div) & 0xFF)
+ #define UART_LOAD_DLM(div)          (((div) >> 8) & 0xFF)
+ 
+ /**********************************************************************
+ * ie register definitions
+ **********************************************************************/
+ /* Bit for enabling the Auto-baud Time-Out interrupt */
+ #define UART_IE_ABTO               _BIT(9)
+ /* Bit for enabling the End of Auto-Baud interrupt */
+ #define UART_IE_ABEO               _BIT(8)
+ /* Bit for enabling the cts_ansignal transition interrupt */
+ #define UART_IE_CTS                _BIT(7)
+ /* Bit for enabling the Modem Status interrupt */
+ #define UART_IE_MS                 _BIT(3)
+ /* Bit for enabling the RX line status interrupt(s) */
+ #define UART_IE_RXLINE_STS         _BIT(2)
+ /* Bit for enabling the transmit holding register empty interrupt */
+ #define UART_IE_THRE               _BIT(1)
+ /* Bit for enabling the receive data available (RDA) interrupt */
+ #define UART_IE_RDA                _BIT(0)
+ 
+ /**********************************************************************
+ * iir register definitions
+ **********************************************************************/
+ /* Bit for the Auto-baud Time-Out interrupt status*/
+ #define UART_IR_INT_ABTO           _BIT(9)
+ /* Bit for the End of Auto-Baud interrupt status*/
+ #define UART_IR_INT_ABEO           _BIT(8)
+ /* Bit for masking interrupt pending status */
+ #define UART_IIR_INT_PENDING       _BIT(0)
+ /* Mask for getting interrupt source */
+ #define UART_IIR_INTSRC_MASK       0xE
+ /* Interrupt sources */
+ #define UART_IIR_INTSRC_MS         0x0
+ #define UART_IIR_INTSRC_THRE       0x2
+ #define UART_IIR_INTSRC_RDA        0x4
+ #define UART_IIR_INTSRC_RXLINE     0x6
+ #define UART_IIR_INTSRC_CTI        0xC /* Character timeout */
+ 
+ 
+ /**********************************************************************
+ * fcr register definitions
+ **********************************************************************/
+ /* Receive FIFO trigger level selections */
+ #define UART_FCR_RXFIFO_TL1        _SBF(6, 0)
+ #define UART_FCR_RXFIFO_TL16       _SBF(6, 1)
+ #define UART_FCR_RXFIFO_TL24       _SBF(6, 2)
+ #define UART_FCR_RXFIFO_TL28       _SBF(6, 3)
+ /* DMA mode select bit  */
+ #define UART_FCR_DMA_MODE          _BIT(3)
+ /* Clear TX FIFO bit */
+ #define UART_FCR_TXFIFO_FLUSH      _BIT(2)
+ /* Clear RX FIFO bit */
+ #define UART_FCR_RXFIFO_FLUSH      _BIT(1)
+ /* Enable FIFO bit  */
+ #define UART_FCR_FIFO_EN           _BIT(0)
+ 
+ /**********************************************************************
+ * lcr register definitions
+ **********************************************************************/
+ /* Bit for enabling divisor latch and IER register */
+ #define UART_LCR_DIVLATCH_EN       _BIT(7)
+ /* Bit for enabling break transmission (forces TX low) */
+ #define UART_LCR_BREAK_EN          _BIT(6)
+ /* Parity selection */
+ #define UART_LCR_PARITY_ODD        0x0
+ #define UART_LCR_PARITY_EVEN       _BIT(4)
+ #define UART_LCR_PARITY_FORCE1     _BIT(5)
+ #define UART_LCR_PARITY_FORCE0     (_BIT(5) | _BIT(4))
+ /* Parity selection mask */
+ #define UART_LCR_PARITY_MASK       (_BIT(5) | _BIT(4))
+ /* Parity enable bit */
+ #define UART_LCR_PARITY_ENABLE     _BIT(3)
+ /* Stop bit selection */
+ #define UART_LCR_STOP1BIT          0x0
+ #define UART_LCR_STOP2BITS         _BIT(2)
+ /* Word length selections */
+ #define UART_LCR_WLEN_5BITS        _SBF(0, 0)
+ #define UART_LCR_WLEN_6BITS        _SBF(0, 1)
+ #define UART_LCR_WLEN_7BITS        _SBF(0, 2)
+ #define UART_LCR_WLEN_8BITS        _SBF(0, 3)
+ /* Word length mask */
+ #define UART_LCR_WLEN_MASK         (_BIT(1) | _BIT(0))
+ 
+ /**********************************************************************
+ * mcr register definitions
+ **********************************************************************/
+ /* Bit for Auto-cts flow control enable */
+ #define UART_MCR_AUTO_CTS         _BIT(7)
+ /* Bit for Auto-rts flow control enable */
+ #define UART_MCR_AUTO_RTS         _BIT(6)
+ /* Bit for Loop-back mode enable */
+ #define UART_MCR_LOOP             _BIT(4)
+ /* Bit for Inverse control for the out2_n output */
+ #define UART_MCR_OUT2             _BIT(3)
+ /* Bit for Inverse control for the out1_n output */
+ #define UART_MCR_OUT1             _BIT(2)
+ /* Bit for inverse control for the rts_n output */
+ #define UART_MCR_RTS              _BIT(1)
+ /* Bit for Inverse control for the Data Terminal Ready output */
+ #define UART_MCR_DTS              _BIT(0)
+ 
+ /**********************************************************************
+ * lsr register definitions
+ **********************************************************************/
+ /* FIFO RX error status */
+ #define UART_LSR_FIFORX_ERR        _BIT(7)
+ /* transmitter empty status */
+ #define UART_LSR_TEMT              _BIT(6)
+ /* transmitter Holding Register empty status */
+ #define UART_LSR_THRE              _BIT(5)
+ /* break interrupt status */
+ #define UART_LSR_BI                _BIT(4)
+ /* framing error status */
+ #define UART_LSR_FR                _BIT(3)
+ /* parity error status */
+ #define UART_LSR_PE                _BIT(2)
+ /* RX FIFO overrun error status */
+ #define UART_LSR_OE                _BIT(1)
+ /* RX FIFO empty status */
+ #define UART_LSR_RDR               _BIT(0)
+ 
+ /**********************************************************************
+ * FDR register definitions
+ **********************************************************************/
+ /* Macro for loading most and least significant halfs of divisors */
+ #define UART_FDR_MUL_GET(div)          (((div) >> 4) & 0xF)
+ #define UART_FDR_DIVADD_GET(div)       ((div) & 0xF)
+ #define UART_FDR_MUL_SET(div)          _SBF(4, ((div) & 0xF))
+ #define UART_FDR_DIVADD_SET(div)       ((div) & 0xF)
+ 
+ /**********************************************************************
+ * Macro to access UART registers
+ **********************************************************************/
+ #define UART    ((UART_REGS_T*)UART_BASE)
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_UART_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc_arm922t_cp15_driver.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc_arm922t_cp15_driver.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc_arm922t_cp15_driver.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc_arm922t_cp15_driver.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,1409 ----
+ /***********************************************************************
+  * $Id:: lpc_arm922t_cp15_driver.c 1009 2008-08-06 18:15:56Z wellsk    $
+  *
+  * Project: ARM922T Coprocessor 15 driver
+  *
+  * Description:
+  *     This file contains driver support for the MMU and cache
+  *     coprocessor (15) of the ARM922T.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  **********************************************************************/
+ 
+ #include "lpc_arm922t_cp15_driver.h"
+ 
+ #ifdef __ICCARM__
+ #include "intrinsics.h"
+ #endif
+ 
+ /***********************************************************************
+  * CP15 driver private data
+  **********************************************************************/
+ 
+ /* The address translation functions of this driver require a saved
+    pointer to the virtual base address of the MMU table. */
+ ulong *virtual_tlb_addr;
+ 
+ /***********************************************************************
+  * CP15 driver private functions and macros
+  **********************************************************************/
+ 
+ #ifdef __ghs__
+ /* Simple GHS function returning the TTB register */
+ asm ulong getttb(void)
+ {
+   % reg ttb
+   MRC     p15, 0, r0, c2, c0, 0
+ }
+ 
+ /* Simple GHS function returning the MMU control register */
+ asm ulong getstatus(void)
+ {
+   % reg status
+   MRC     p15, 0, r0, c1, c0, 0
+ }
+ 
+ /* Simple GHS function used to support cache invalidation */
+ asm void invalcache(ulong *adr)
+ {
+   % reg adr
+   MCR     p15, 0, adr, c7, c14, 1
+   MCR     p15, 0, adr, c7, c5, 1
+   % con adr
+   MOV     r0, adr
+   MCR     p15, 0, r0, c7, c14, 1
+   MCR     p15, 0, r0, c7, c5, 1
+ }
+ 
+ /* Simple GHS function used to support cache invalidation */
+ asm void inval_all_cache(void)
+ {
+   MOV     r0, 0
+   MCR     p15, 0, r0, c7, c7, 0
+ }
+ 
+ /* Simple GHS function used to support translation table base
+    register invalidation */
+ asm void invaltlb(ulong *adr)
+ {
+   % reg adr
+   MCR     p15, 0, adr, c8, c5, 1
+   NOP
+   NOP
+   % con adr
+   MOV     r0, adr
+   MCR     p15, 0, r0, c8, c5, 1
+   NOP
+   NOP
+ }
+ 
+ /* Simple GHS function used to invalidate all TLB entries */
+ asm void inval_all_tlb(void)
+ {
+   MOV     r0, 0
+   MCR     p15, 0, r0, c8, c7, 0
+ }
+ 
+ /* Simple GHS function used to enable/disable MMU */
+ asm void set_mmu(ulong val)
+ {
+   % reg val
+   MCR     p15, 0, val, c1, c0, 0
+ }
+ 
+ /* Simple GHS function used to set TTB address */
+ asm void set_ttb(ulong addr)
+ {
+   % reg addr
+   MCR     p15, 0, addr, c2, c0, 0
+ }
+ 
+ /* Simple GHS function used to set domain access control */
+ asm void set_dac(ulong reg_val)
+ {
+   % reg reg_val
+   MCR     p15, 0, reg_val, c3, c0, 0
+ }
+ #endif
+ 
+ /***********************************************************************
+  * CP15 driver public functions
+  **********************************************************************/
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_decode_level2
+  *
+  * Purpose:
+  *     Given a level2 descriptor and a physical address, return
+  *     the virtual address if the level2 descriptor can map the
+  *     physical address.
+  *
+  * Processing:
+  *     Translate and return the level 2 virtual address for
+  *     the given physical address.
+  *
+  * Parameters:
+  *     level2: MMU level 2 table value
+  *     addr:   Physical address to be converted
+  *
+  * Outputs: None
+  *
+  * Returns:
+  *      The virtual address or 0 if the address does not translate.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ static ulong cp15_decode_level2(ulong level2,
+                                  ulong addr)
+ {
+   ulong dcd = 0;
+ 
+   switch (level2 & ARM922T_L2D_TYPE_PAGE_MASK)
+   {
+     case ARM922T_L2D_TYPE_LARGE_PAGE:
+       /* Large page table */
+       if ((level2 & ARM922T_L2D_LPAGE_MASK) ==
+           (addr & ARM922T_L2D_LPAGE_MASK))
+       {
+         dcd = (level2 & ARM922T_L2D_LPAGE_MASK) |
+               (addr & (~ARM922T_L2D_LPAGE_MASK));
+       }
+       break;
+ 
+     case ARM922T_L2D_TYPE_SMALL_PAGE:
+       /* Small page table */
+       if ((level2 & ARM922T_L2D_SPAGE_MASK) ==
+           (addr & ARM922T_L2D_SPAGE_MASK))
+       {
+         dcd = (level2 & ARM922T_L2D_SPAGE_MASK) |
+               (addr & (~ARM922T_L2D_SPAGE_MASK));
+       }
+       break;
+ 
+     case ARM922T_L2D_TYPE_TINY_PAGE:
+       /* Tiny page table */
+       if ((level2 & ARM922T_L2D_TPAGE_MASK) ==
+           (addr & ARM922T_L2D_TPAGE_MASK))
+       {
+         dcd = (level2 & ARM922T_L2D_TPAGE_MASK) |
+               (addr & (~ARM922T_L2D_TPAGE_MASK));
+       }
+ 
+     default:
+       break;
+   }
+ 
+   return dcd;
+ }
+ 
+ /***********************************************************************
+  * CP15 driver public functions
+  **********************************************************************/
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_map_virtual_to_physical
+  *
+  * Purpose: Return a physical address for a passed virtual address
+  *
+  * Processing:
+  *      Return (ulong)addr if MMU is turned off. Otherwise, read the
+  *      address of the translation table from the translation table base
+  *      address register. Use the upper 12 bits of the addr to index the
+  *      translation table and read out the descriptor. If the descriptor
+  *      is invalid, return 0. If the descriptor is for a 1 Meg section,
+  *      read back the upper 12 bits of the physical address. The lower
+  *      20 bits of the physical address is the lower 20 bits of the
+  *      virtual address. If the descriptor is for a coarse page table,
+  *      read the coarse page table descriptor and use the most
+  *      significant 22 bits as the base address of the page table. If
+  *      the descriptor is for a fine page table, read the fine page
+  *      table descriptor and use the most significant 20 bits as the
+  *      base address of the page table.
+  *
+  *      If not a section base, read the level 2 page descriptor from the
+  *      page table.  If bits 1..0 of the level2 descriptor are 01, then
+  *      it is a large page table descriptor. The most significant 16
+  *      bits of the descriptor are the most significant 16 bits of the
+  *      physical address; the least significant 16-bits of the virtual
+  *      address are the least significant 16-bits of the address. If
+  *      bits 1..0 of the level2 descriptor are 10, then it is a small
+  *      page table descriptor. The most significant 20 bits of the
+  *      level2 descriptor are the most significant 20 bits of the
+  *      physical address; the least significant 12 bits are the least
+  *      significant 12 bits of the physical address. If bits 1..0 of
+  *      the level2 descriptor are 11, then it is a tiny page table
+  *      descriptor.  The most significant 22 bits of the level2
+  *      descriptor are the most significant 22 bits of the physical
+  *      address; the least significant 10 bits are the least
+  *      significant 10 bits of the physical address.  If bits 1..0
+  *      of the level2 descriptor are 0, return 0 (invalid).
+  *
+  * Parameters:
+  *     addr: The virtual address to be converted
+  *
+  * Outputs: None
+  *
+  * Returns:
+  *      The physical address or 0 if the address does not translate.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ ulong cp15_map_virtual_to_physical(void *addr)
+ {
+   register ulong status;
+   ulong *tlb, tlb_entry, index, virtual_addr;
+   ulong *page_table, level2;
+ 
+   virtual_addr = (ulong) addr;
+ 
+   /* Read the MMU control register */
+ #ifdef __GNUC__
+ asm("MRC p15, 0, %0, c1, c0, 0" : "=r"(status));
+ #endif
+ #ifdef __ghs__
+   status = getstatus();
+ #endif
+ #ifdef __arm
+   __asm
+   {
+     MRC p15, 0, status, c1, c0, 0;
+   }
+ #endif
+ #ifdef __ICCARM__
+   /* IAR CC includes some "intrinsic" functions to access ARM CP regs */
+   status = __MRC(15, 0, 1, 0, 0);
+ #endif
+ 
+   /* Is MMU enabled? */
+   if ((status & ARM922T_MMU_CONTROL_M) == 0)
+   {
+     /* MMU is off; virtual address is physical address */
+     return virtual_addr;
+   }
+ 
+   /* Get TLB base address */
+   tlb = virtual_tlb_addr;
+ 
+   /*******************************************************************
+    * Get the level 1 translation table entry
+    * indexed by bits 31:20 of the address
+    ******************************************************************/
+   index = virtual_addr;
+   index >>= 20;
+   tlb_entry = tlb[index];
+   /* Perform function based on level 1 page type or section */
+   switch (tlb_entry & ARM922T_L1D_TYPE_PG_SN_MASK)
+   {
+     case ARM922T_L1D_TYPE_FAULT:
+       /* Invalid section or page, fault */
+       return 0;
+ 
+     case ARM922T_L1D_TYPE_CPAGE:
+       /* Coarse page tables */
+       index = (virtual_addr >> 12) & ARM922T_CPT_INDEX_MASK;
+       page_table = (ulong *)(tlb_entry &
+                               ARM922T_L2D_CP_BASE_MASK);
+       level2 = page_table[index];
+       break;
+ 
+     case ARM922T_L1D_TYPE_SECTION:
+       /* Section type */
+       /***********************************************************
+        * Section base -- upper 12 bits of entry is physical
+        * memory base lower 20 bits of virtual address is offset
+        * rom that base
+        **********************************************************/
+       return ((tlb_entry & ARM922T_L2D_SN_BASE_MASK) |
+               (virtual_addr & ~(ARM922T_L2D_SN_BASE_MASK)));
+ 
+     case ARM922T_L1D_TYPE_FPAGE:
+       /* Fine page tables */
+       index = (virtual_addr >> 10) & ARM922T_FPT_INDEX_MASK;
+       page_table = (ulong *)(tlb_entry &
+                               ARM922T_L2D_FP_BASE_MASK);
+       level2 = page_table[index];
+       break;
+ 
+     default:
+       /* This should never happen */
+       return 0;
+   }
+ 
+   switch (level2 & ARM922T_L2D_TYPE_PAGE_MASK)
+   {
+     case ARM922T_L2D_TYPE_LARGE_PAGE:
+       /* Large page table */
+       return ((level2 & ARM922T_L2D_LPAGE_MASK) |
+               (virtual_addr & ~(ARM922T_L2D_LPAGE_MASK)));
+ 
+     case ARM922T_L2D_TYPE_SMALL_PAGE:
+       /* Small page table */
+       return ((level2 & ARM922T_L2D_SPAGE_MASK) |
+               (virtual_addr & ~(ARM922T_L2D_SPAGE_MASK)));
+ 
+     case ARM922T_L2D_TYPE_TINY_PAGE:
+       /* Tiny page table */
+       return ((level2 & ARM922T_L2D_TPAGE_MASK) |
+               (virtual_addr & ~(ARM922T_L2D_TPAGE_MASK)));
+ 
+     default:
+       break;
+   }
+ 
+   return 0;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_map_physical_to_virtual
+  *
+  * Purpose: Return a virtual address for a passed physical address
+  *
+  * Processing:
+  *     Test if MMU is on, return if not.  Search for the virtual
+  *     address of the provided physical address. If found, return a
+  *     void pointer to virtual address.
+  *
+  * Parameters:
+  *     addr: The physical address to be converted
+  *
+  * Outputs: None
+  *
+  * Returns:
+  *      The virtual address or 0 if the address does not translate.
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void * cp15_map_physical_to_virtual(ulong addr)
+ {
+   register ulong status;
+   ulong *tlb, tlb_entry, index;
+   ulong *page_table, level2, index2;
+   void *virtual_addr;
+ 
+   /*******************************************************************
+    * Do a linear search of the translation table until the level 1
+    * descriptor corresponding to the physical address is found
+    ******************************************************************/
+ 
+   /* Read the control register */
+ #ifdef __GNUC__
+ asm("MRC p15, 0, %0, c1, c0, 0" : "=r"(status));
+ #endif
+ #ifdef __ghs__
+   status = getstatus();
+ #endif
+ #ifdef __arm
+   __asm
+   {
+     MRC p15, 0, status, c1, c0, 0;
+   }
+ #endif
+ #ifdef __ICCARM__
+   /* IAR CC includes some "intrinsic" functions to access ARM CP regs */
+   status = __MRC(15, 0, 1, 0, 0);
+ #endif
+ 
+   /* Is MMU enabled? */
+   if ((status & ARM922T_MMU_CONTROL_M) == 0)
+   {
+     /* MMU is off; physical address is virtual address */
+     return (void *)addr;
+   }
+ 
+   /* Get TLB base address */
+   tlb = virtual_tlb_addr;
+ 
+   /*******************************************************************
+    * Search until found or all 4096 translation
+    * table entries are examined.
+    ******************************************************************/
+   for (index = 0; index < ARM922T_TT_ENTRIES; index ++)
+   {
+     tlb_entry = tlb[index];
+     switch (tlb_entry & ARM922T_L1D_TYPE_PG_SN_MASK)
+     {
+       case ARM922T_L1D_TYPE_FAULT:
+         /* Invalid section or page, fault */
+         break;
+ 
+       case ARM922T_L1D_TYPE_CPAGE:
+         /* Course page tables, loop through all entries */
+         page_table = (ulong *)(tlb_entry &
+                                 ARM922T_L2D_CP_BASE_MASK);
+         for (index2 = 0; index2 < ARM922T_CPT_ENTRIES; index2++)
+         {
+           level2 = page_table[index2];
+           if (level2)
+           {
+             virtual_addr = (void *)
+                            cp15_decode_level2(level2, addr);
+ 
+             if (virtual_addr)
+             {
+               return virtual_addr;
+             }
+           }
+           break;
+         }
+         break;
+ 
+       case ARM922T_L1D_TYPE_SECTION:
+         /* Section type */
+         /*******************************************************
+          * Section base -- upper 12 bits of entry is physical
+          * memory base lower 20 bits of virtual address is
+          * offset from that base
+          ******************************************************/
+         if ((tlb_entry & ARM922T_L2D_SN_BASE_MASK)
+             == (addr & ARM922T_L2D_SN_BASE_MASK))
+         {
+           return (void *)((index << 20) |
+                           (addr & ~(ARM922T_L2D_SN_BASE_MASK)));
+         }
+         break;
+ 
+       case ARM922T_L1D_TYPE_FPAGE:
+         /* Fine page tables, loop through entries */
+         page_table = (ulong *)(tlb_entry &
+                                 ARM922T_L2D_FP_BASE_MASK);
+         for (index2 = 0; index2 < ARM922T_FPT_ENTRIES; index2++)
+         {
+           level2 = page_table[index2];
+           if (level2)
+           {
+             virtual_addr = (void *)
+                            cp15_decode_level2(level2, addr);
+ 
+             if (virtual_addr)
+             {
+               return virtual_addr;
+             }
+           }
+         }
+         break;
+ 
+       default:
+         break;
+     }
+   }
+ 
+   return 0;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_force_cache_coherence
+  *
+  * Purpose:
+  *     Force the CPU to recognize the block of code that was just
+  *     written to memory between start_adr and end_adr even if caching
+  *     and write buffering is on.
+  *
+  * Processing:
+  *     Cache lines are 32-bytes (8 words); clean and invalidate each
+  *     line of D-cache and invalidate each line of I-cache within the
+  *     address range.
+  *
+  *     Invalidate the I-TLB within the the address range. The I-TLB has
+  *     256 word granularity.
+  *
+  * Parameters:
+  *     start_adr:  The first address in the code block
+  *     end_adr:    The last address in the code block
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void cp15_force_cache_coherence(ulong *start_adr,
+                                 ulong *end_adr)
+ {
+   register ulong * addr;
+ 
+   /*******************************************************************
+    * Cache lines are 32-bytes (8 words); clean and invalidate each
+    * line of D-cache and invalidate each line of I-cache within the
+    * address range. Make sure addresses are 32-bit aligned.
+    ******************************************************************/
+   for (addr = (ulong *)((ulong)start_adr & 0xFFFFFFE0);
+        addr < end_adr;
+        addr += 8)
+   {
+     /* p15 is MMU coprocessor, Cache OPS is c7, TLB OPS is c8 */
+ #ifdef __GNUC__
+ asm("MOV r0, %0" : : "r"(addr));
+     /* Clean and Invalidate D-Cache single entry using MVA format */
+     asm("MCR p15, 0, r0, c7, c14, 1");
+     /* Invalidate I-Cache single entry using MVA format */
+     asm("MCR p15, 0, r0, c7, c5, 1");
+ #endif
+ #ifdef __ghs__
+     invalcache(addr);
+ #endif
+ #ifdef __arm
+     ulong trx;
+     __asm
+     {
+       MOV     trx, addr
+       /* Clean and Invalidate D-Cache single entry using MVA
+          format */
+       MCR     p15, 0, trx, c7, c14, 1
+       /* Invalidate I-Cache single entry using MVA format */
+       MCR     p15, 0, trx, c7, c5, 1
+     }
+ #endif
+ #ifdef __ICCARM__
+ 
+     /* Use IAR intrinsic functions */
+     __MCR(15, 0, (ulong)addr, 7, 14, 1);
+     __MCR(15, 0, (ulong)addr, 7, 5, 1);
+ #endif
+ 
+   }
+   /*******************************************************************
+    * Invalidate the I-TLB within the the address range. The I-TLB has
+    * 256 word granularity. Make sure addresses are '256 word' aligned.
+    ******************************************************************/
+   for (addr = (ulong *)((ulong)start_adr & 0xFFFFFC00);
+        addr < end_adr;
+        addr += 256)
+   {
+ #ifdef __GNUC__
+ asm("MOV r0, %0" : : "r"(addr));
+     /* Invalidate I-TLB using MVA format */
+     asm("MCR p15, 0, r0, c8, c5, 1");
+     asm("NOP");
+     asm("NOP");
+ #endif
+ #ifdef __ghs__
+     invaltlb(addr);
+ #endif
+ #ifdef __arm
+     ulong trx;
+     __asm
+     {
+       MOV     trx, addr
+       /* Invalidate I-TLB using MVA format */
+       MCR      p15, 0, trx, c8, c5, 1
+       NOP
+       NOP
+     }
+ #endif
+ #ifdef __ICCARM__
+ 
+     /* Invalidate I-TLB using MVA format */
+     /* Use IAR intrinsic functions */
+     __MCR(15, 0, (ulong)addr, 8, 5, 1);
+     __no_operation();
+     __no_operation();
+ #endif
+   }
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_init_mmu_trans_table
+  *
+  * Purpose: Initializes the MMU page table
+  *
+  * Processing:
+  *     Return error if MMU is enabled. Return error if target
+  *     Translation Table address is not 16K aligned. Clear the
+  *     Translation Table area. Build the Translation Table from the
+  *     initialization data in the Section Block array. Return no error.
+  *
+  * Parameters:
+  *      tt:    address of Translation Table in RAM.
+  *      ttsbp: address of the beginning of the initialization array
+  *
+  * Outputs: None.
+  *
+  * Returns:
+  *     This function returns _ERROR when the MMU is enabled, or the
+  *     target address is not 16K aligned. Otherwise, it returns
+  *     _NO_ERROR.
+  *
+  * Notes:
+  *     This function is not intended to be used when the MMU is
+  *     enabled.
+  *
+  **********************************************************************/
+ BOOL_32 cp15_init_mmu_trans_table(TRANSTABLE_T *tt,
+                                   TT_SECTION_BLOCK_T *ttsbp)
+ {
+   register ulong control;
+   ulong idx;
+   ulong va_idx;
+   ulong pa_addr;
+   ulong *uiptr;
+   ulong ret = _NO_ERROR;
+ 
+   /*******************************************************************
+    * The following check returns an error if the MMU is enabled.
+    * This condition is not necessarily an error, but an existing
+    * Translation Table for an enabled MMU should not be overwritten
+    * while the MMU is enabled.
+    ******************************************************************/
+ 
+   /* Read the control register */
+ #ifdef __GNUC__
+ asm("MRC p15, 0, %0, c1, c0, 0" : "=r"(control));
+ #endif
+ #ifdef __ghs__
+   control = getstatus();
+ #endif
+ #ifdef __arm
+   __asm
+   {
+     MRC p15, 0, control, c1, c0, 0;
+   }
+ #endif
+ #ifdef __ICCARM__
+   /* Use IAR intrinsic functions */
+   control = __MRC(15, 0, 1, 0, 0);
+ #endif
+ 
+   /* Exit if MMU is already enabeld */
+   if ((control & ARM922T_MMU_CONTROL_M) != 0)
+   {
+     return (_ERROR);
+   }
+ 
+   /* Make sure table address is on a 16K boundary */
+   if (((INT_32) tt & ~(ARM922T_TT_ADDR_MASK)) != 0)
+   {
+     return (_ERROR);
+   }
+ 
+   /*******************************************************************
+    * Clear the entire Translation Table.
+    * This results in L1D_TYPE_FAULT being the default for any
+    * uninitialized entries.
+    ******************************************************************/
+   uiptr = (ulong *) tt;
+   for (idx = 0; idx < ARM922T_TT_ENTRIES; idx++)
+     *uiptr++ = ARM922T_L1D_TYPE_FAULT;
+ 
+   /* Build the translation table from user provided
+      TT_SECTION_BLOCK_TYPE array */
+   while (ttsbp->num_sections != 0)
+   {
+     switch ((ttsbp->entry) & ARM922T_L1D_TYPE_PG_SN_MASK)
+     {
+       case ARM922T_L1D_TYPE_SECTION:
+         va_idx = ttsbp->virt_addr >> 20;
+         pa_addr = ttsbp->phys_addr & ARM922T_L2D_SN_BASE_MASK;
+         for (idx = 0; idx < ttsbp->num_sections; idx++)
+         {
+           tt->vidx[va_idx] = (pa_addr | ttsbp->entry | 0x10);
+           va_idx++;
+           pa_addr += 0x100000;
+         }
+         break;
+ 
+       case(ARM922T_L1D_TYPE_CPAGE):
+         va_idx = ttsbp->virt_addr >> 20;
+         pa_addr = ttsbp->phys_addr & ARM922T_L2D_CP_BASE_MASK;
+         for (idx = 0; idx < ttsbp->num_sections; idx++)
+         {
+           tt->vidx[va_idx] = pa_addr | ttsbp->entry;
+           va_idx++;
+           pa_addr += 0x100000;
+         }
+         break;
+ 
+       case ARM922T_L1D_TYPE_FAULT:
+       default:
+         break;
+     }
+ 
+     ttsbp++;
+   }
+ 
+   return ret;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_set_vmmu_addr
+  *
+  * Purpose: Set the virtual address of the MMU table
+  *
+  * Processing:
+  *     Set the saved virtual MMU table address to the passed value.
+  *
+  * Parameters:
+  *      addr: Virtual address of start of MMU table
+  *
+  * Outputs: None.
+  *
+  * Returns: Nothing
+  *
+  * Notes:
+  *     This function must be called if the driver MMU functions are
+  *     being used. This should be set after the call to the
+  *     cp15_init_mmu_trans_table() function.
+  *
+  **********************************************************************/
+ void cp15_set_vmmu_addr(ulong *addr)
+ {
+   virtual_tlb_addr = addr;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_get_ttb
+  *
+  * Purpose: Return the physical address of the MMU translation table
+  *
+  * Processing:
+  *     Read the TTB register from coprocessor 15 and return it to the
+  *     caller.
+  *
+  * Parameters: None
+  *
+  * Outputs: None.
+  *
+  * Returns: The base address of the MMU translation table
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ ulong *cp15_get_ttb(void)
+ {
+   register ulong ttb;
+ 
+ #ifdef __GNUC__
+ asm("MRC p15, 0, %0, c2, c0, 0" : "=r"(ttb));
+ #endif
+ #ifdef __ghs__
+   ttb = getttb();
+ #endif
+ #ifdef __arm
+   __asm
+   {
+     MRC p15, 0, ttb, c2, c0, 0;
+   }
+ #endif
+ #ifdef __ICCARM__
+   /* use IAR CC intrinsic function to read CP15 reg */
+   ttb = __MRC(15, 0, 2, 0, 0);
+ #endif
+ 
+   return (ulong *) ttb;
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_dcache_flush
+  *
+  * Purpose: Force an data cache flush
+  *
+  * Processing:
+  *     Flush each data cache entry using the segment/index method.
+  *
+  * Parameters: None
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void cp15_dcache_flush(void)
+ {
+ #ifdef __GNUC__
+ 
+ #endif
+ #ifdef __ghs__
+ 
+ #endif
+ #ifdef __arm
+   INT_32 segment, index, comp, cache_sz, total_seg;
+ 
+   __asm
+   {
+     MRC p15, 0, cache_sz, c0, c0, 1
+   }
+ 
+   /* For 8KB cache the size field is 4 and for 16 it is 5.
+   */
+   total_seg = (1 << (ARM922T_MMU_DC_SIZE(cache_sz) - 2));
+ 
+   for (segment = 0; segment < total_seg; segment++)
+   {
+     for (index = 0; index < 64; index++)
+     {
+       /* For each segment and index, flush the data cache */
+       comp = (segment << 5) | (index << 26);
+       __asm
+       {
+         MCR p15, 0, comp, c8, c5, 1
+       }
+     }
+   }
+ #endif
+ #ifdef __ICCARM__
+ 
+ #endif
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_write_buffer_flush
+  *
+  * Purpose: Force an write buffer flush
+  *
+  * Processing:
+  *     Flush the write buffer and wait for completion of the flush.
+  *
+  * Parameters: None
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void cp15_write_buffer_flush(void)
+ {
+ #ifdef __GNUC__
+ 
+ #endif
+ #ifdef __ghs__
+ 
+ #endif
+ #ifdef __arm
+   ulong trx;
+   __asm
+   {
+     MOV trx, #0
+     MCR p15, 0, trx, c7, c10, 4
+   }
+ #endif
+ #ifdef __ICCARM__
+ 
+ #endif
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_mmu_enabled
+  *
+  * Purpose:
+  *  Checks to see if the MMU is enabled
+  *
+  * Processing:
+  *  Read the MMU control register and check if the MMU enable bit
+  *  (bit 0) is set.
+  *
+  * Parameters: None
+  *
+  * Outputs: None
+  *
+  * Returns:
+  *  TRUE if the MMU is enabled
+  *  FALSE if the MMU is disabled
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ BOOL_32 cp15_mmu_enabled(void)
+ {
+   ulong mmu_reg;
+ 
+ #ifdef __GNUC__
+ asm("MRC p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
+ #endif
+ 
+ #ifdef __ghs__
+   mmu_reg = getstatus();
+ #endif
+ 
+ #ifdef __arm
+   __asm
+   {
+     MRC     p15, 0, mmu_reg, ARM922T_MMU_REG_CONTROL, c0, 0;
+   }
+ #endif
+ 
+ #ifdef __ICCARM__
+   /* use IAR CC intrinsic function to read CP15 reg */
+   mmu_reg = __MRC(15, 0, 1, 0, 0);
+ #endif
+ 
+ 
+   return ((mmu_reg & _BIT(0)) == _BIT(0));
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_get_mmu_control_reg
+  *
+  * Purpose:
+  *  To return the current value of  the MMU Coprocessor (CP15) Control
+  *  register.
+  *
+  * Processing:
+  *  Fetch the MMU control register to a variable and return it
+  *
+  * Parameters: None
+  *
+  * Outputs: None
+  *
+  * Returns:
+  *  The current value of the MMU Control register (cp15) as an ulong
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ ulong cp15_get_mmu_control_reg(void)
+ {
+   register ulong mmu_reg;
+ 
+ #ifdef __GNUC__
+ asm("MRC p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
+ #endif
+ 
+ #ifdef __ghs__
+   mmu_reg = getstatus();
+ 
+ #endif
+ #ifdef __arm
+   __asm
+   {
+     MRC     p15, 0, mmu_reg, ARM922T_MMU_REG_CONTROL, c0, 0;
+   }
+ #endif
+ #ifdef __ICCARM__
+   /* use IAR CC intrinsic function to read CP15 reg */
+   mmu_reg = __MRC(15, 0, 1, 0, 0);
+ #endif
+ 
+   return (mmu_reg);
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_set_mmu_control_reg
+  *
+  * Purpose:
+  *  To set MMU Coprocessor (CP15) Control register.
+  *
+  * Processing:
+  *  Set the MMU control register to a value passed as parameter.
+  *
+  * Parameters:
+  *  mmu_reg - The value to be set in the MMU Control register (cp15).
+  *
+  * Outputs: None
+  *
+  * Returns: None
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void cp15_set_mmu_control_reg(ulong mmu_reg)
+ {
+ #ifdef __GNUC__
+ asm("MCR p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
+ #endif
+ 
+ #ifdef __ghs__
+   set_mmu(mmu_reg);
+ #endif
+ 
+ #ifdef __arm
+   __asm
+   {
+     MCR     p15, 0, mmu_reg, ARM922T_MMU_REG_CONTROL, c0, 0
+   }
+ #endif
+ #ifdef __ICCARM__
+ 
+   /* Use IAR intrinsic functions */
+   __MCR(15, 0, (ulong)mmu_reg, 1, 0, 0);
+ #endif
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_set_mmu
+  *
+  * Purpose:
+  *  To enable or disable the MMU as specified.
+  *
+  * Processing:
+  *  Fetch the MMU control register to a variable. If the argument passed
+  *  is true, set the MMU enable bit, otherwise, clear it. Write the
+  *  resultant value back to the control register.
+  *
+  * Parameters:
+  *  enable - TRUE if the MMU must be enabled
+  *           FALSE if the MMU must be disabled
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void cp15_set_mmu(BOOL_32 enable)
+ {
+   register ulong mmu_reg;
+ 
+   /* Read-Modify-Write the MMU register */
+   mmu_reg = cp15_get_mmu_control_reg();
+ 
+   if (enable)
+   {
+     mmu_reg |= ARM922T_MMU_CONTROL_M;
+   }
+   else
+   {
+     mmu_reg &= ~ARM922T_MMU_CONTROL_M;
+   }
+ 
+ #ifdef __GNUC__
+ asm("MCR p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
+ #endif
+ 
+ #ifdef __ghs__
+   set_mmu(mmu_reg);
+ #endif
+ 
+ #ifdef __arm
+   __asm
+   {
+     MCR     p15, 0, mmu_reg, ARM922T_MMU_REG_CONTROL, c0, 0
+   }
+ #endif
+ #ifdef __ICCARM__
+ 
+   /* Use IAR intrinsic functions */
+   __MCR(15, 0, (ulong)mmu_reg, 1, 0, 0);
+ #endif
+ 
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_invalidate_cache
+  *
+  * Purpose:
+  *  Invalidates the Instruction and Data caches
+  *
+  * Processing:
+  *  Use the ARM instruction to unconditionally invalidate the entire
+  *  cache.
+  *
+  * Parameters: None
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes:
+  *  This function invalidates all cache data including dirty data (data
+  *  that has been modified in cache but not yet written to main memory).
+  *  Use with caution. See ARM922T TRM.
+  *
+  **********************************************************************/
+ void cp15_invalidate_cache(void)
+ {
+ #ifdef __GNUC__
+   // Invalidate both I- and D-cache completely
+   asm("MOV r0, #0");
+   asm("MCR p15, 0, r0, c7, c7, 0");
+ #endif
+ #ifdef __ghs__
+   inval_all_cache();
+ #endif
+ 
+ #ifdef __arm
+   ulong trx;
+   __asm
+   {
+     MOV     trx, 0
+     MCR     p15, 0, trx, c7, c7, 0
+   }
+ #endif
+ #ifdef __ICCARM__
+   {
+     register ulong temp = 0;
+ 
+     /* Use IAR intrinsic functions */
+     __MCR(15, 0, (ulong)temp, 7, 7, 0);
+   }
+ #endif
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_invalidate_tlb
+  *
+  * Purpose:
+  *  Invalidates the Translation Lookaside Buffers
+  *
+  * Processing:
+  *  Use the ARM instruction to unconditionally invalidate the I- and D-
+  *  TLBs.
+  *
+  * Parameters: None
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes:
+  *  See the ARM922T TRM.
+  *
+  **********************************************************************/
+ void cp15_invalidate_tlb(void)
+ {
+ #ifdef __GNUC__
+   asm("MOV r0, #0");
+   asm("MCR p15, 0, r0, c8, c7, 0");
+   asm("NOP");
+   asm("NOP");
+   asm("NOP");
+ #endif
+ #ifdef __ghs__
+   inval_all_tlb();
+ #endif
+ 
+ #ifdef __arm
+   ulong trx;
+   __asm
+   {
+     MOV     trx, 0
+     // Invalidate TLBs
+     MCR      p15, 0, trx, ARM922T_MMU_REG_TLB_OPS, c7, 0
+     NOP
+     NOP
+     NOP
+   }
+ #endif
+ #ifdef __ICCARM__
+   {
+     register ulong temp = 0;
+ 
+     /* Use IAR intrinsic functions */
+     __MCR(15, 0, (ulong)temp, 8, 7, 0);
+     __no_operation();
+     __no_operation();
+     __no_operation();
+   }
+ #endif
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_set_transtable_base
+  *
+  * Purpose:
+  *  Sets the first-level translation table base address
+  *
+  * Processing:
+  *  Masks out the lower 12 bits of the address passed. Writes register
+  *  2 of CP15 with the base address passed as parameter.
+  *
+  * Parameters:
+  *  addr - Translation table base address
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes:
+  *  The address must be aligned on a 16K boundary. See ARM922T TRM.
+  *
+  **********************************************************************/
+ void cp15_set_transtable_base(ulong addr)
+ {
+   addr &= 0xFFFFC000;
+ 
+ #ifdef __GNUC__
+ asm("MCR p15, 0, %0, c2, c0, 0": "=r"(addr));
+ #endif
+ 
+ #ifdef __ghs__
+   set_ttb(addr);
+ #endif
+ 
+ #ifdef __arm
+   __asm
+   {
+     MCR     p15, 0, addr, ARM922T_MMU_REG_TTB, c0, 0
+   }
+ #endif
+ 
+ #ifdef __ICCARM__
+   /* Use IAR intrinsic functions */
+   __MCR(15, 0, (ulong)addr, 2, 0, 0);
+ #endif
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_set_icache
+  *
+  * Purpose:
+  *  Enables or disables the instruction cache
+  *
+  * Processing:
+  *  Fetch the MMU control register to a variable. If the argument passed
+  *  is true, set the I-cache enable bit, otherwise, clear it. Write the
+  *  resultant value back to the control register.
+  *
+  * Parameters:
+  *  enable - TRUE if the I-cache must be enabled
+  *           FALSE if the I-cache must be disabled
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void cp15_set_icache(BOOL_32 enable)
+ {
+   ulong mmu_reg;
+ 
+   mmu_reg = cp15_get_mmu_control_reg();
+ 
+   if (enable)
+     mmu_reg |= ARM922T_MMU_CONTROL_I;
+   else
+     mmu_reg &= ~ARM922T_MMU_CONTROL_I;
+ 
+ #ifdef __GNUC__
+ asm("MCR p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
+ #endif
+ 
+ #ifdef __ghs__
+   set_mmu(mmu_reg);
+ #endif
+ 
+ #ifdef __arm
+   __asm
+   {
+     MCR     p15, 0, mmu_reg, ARM922T_MMU_REG_CONTROL, c0, 0
+   }
+ #endif
+ #ifdef __ICCARM__
+   /* Use IAR intrinsic functions */
+   __MCR(15, 0, (ulong)mmu_reg, 1, 0, 0);
+ #endif
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_set_dcache
+  *
+  * Purpose:
+  *  Enables or disables the data cache
+  *
+  * Processing:
+  *  Fetch the MMU control register to a variable. If the argument passed
+  *  is true, set the D-cache enable bit, otherwise, clear it. Write the
+  *  resultant value back to the control register.
+  *
+  * Parameters:
+  *  enable - TRUE if the D-cache must be enabled
+  *           FALSE if the D-cache must be disabled
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes: None
+  *
+  **********************************************************************/
+ void cp15_set_dcache(BOOL_32 enable)
+ {
+   ulong mmu_reg;
+ 
+   mmu_reg = cp15_get_mmu_control_reg();
+ 
+   if (enable)
+     mmu_reg |= ARM922T_MMU_CONTROL_C;
+   else
+     mmu_reg &= ~ARM922T_MMU_CONTROL_C;
+ 
+ #ifdef __GNUC__
+ asm("MCR p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
+ #endif
+ 
+ #ifdef __ghs__
+   set_mmu(mmu_reg);
+ #endif
+ 
+ #ifdef __arm
+   __asm
+   {
+     MCR     p15, 0, mmu_reg, ARM922T_MMU_REG_CONTROL, c0, 0
+   }
+ #endif
+ #ifdef __ICCARM__
+   /* Use IAR intrinsic functions */
+   __MCR(15, 0, (ulong)mmu_reg, 1, 0, 0);
+ #endif
+ }
+ 
+ /***********************************************************************
+  *
+  * Function: cp15_set_domain_access
+  *
+  * Purpose:
+  *  Define the access permissions for the 16 MMU domains.
+  *
+  * Processing:
+  *  Use the ARM instruction to write the value passed as argument to
+  *  the domain access control regsiter.
+  *
+  * Parameters:
+  *  dac - 32-bit value encoded as follows:
+  *
+  *   31  29  27  25  23  21  19  17  15  13  11  9 8 7 6 5 4 3 2 1 0
+  *   ---------------------------------------------------------------
+  *  |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+  *   ---------------------------------------------------------------
+  *   For each domain (2 bits),
+  *     00 - No access
+  *     01 - Client
+  *     10 - Reserved (same as no access)
+  *     11 - Manager
+  *
+  * Outputs: None
+  *
+  * Returns: Nothing
+  *
+  * Notes:
+  *  See the ARM922T TRM.
+  *
+  **********************************************************************/
+ void cp15_set_domain_access(ulong dac)
+ {
+ #ifdef __GNUC__
+ asm("MCR p15, 0, %0, c3, c0, 0" : "=r"(dac));
+ #endif
+ #ifdef __ghs__
+   set_dac(dac);
+ #endif
+ 
+ #ifdef __arm
+   __asm
+   {
+     MCR     p15, 0, dac, ARM922T_MMU_REG_DAC, c0, 0
+   }
+ #endif
+ #ifdef __ICCARM__
+   /* Use IAR intrinsic functions */
+   __MCR(15, 0, (ulong)dac, 3, 0, 0);
+ #endif
+ }
+ 
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc_arm922t_cp15_driver.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc_arm922t_cp15_driver.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc_arm922t_cp15_driver.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc_arm922t_cp15_driver.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,144 ----
+ /***********************************************************************
+  * $Id:: lpc_arm922t_cp15_driver.h 745 2008-05-13 19:59:29Z pdurgesh   $
+  *
+  * Project: ARM922T Coprocessor 15 driver
+  *
+  * Description:
+  *     This file contains driver support for the MMU and cache
+  *     coprocessor (15) of the ARM922T.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  **********************************************************************/
+ 
+ #ifndef LPC_ARM922T_CP15_DRIVER_H
+ #define LPC_ARM922T_CP15_DRIVER_H
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ 
+ #if defined (__cplusplus)
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+  * ARM 922T MMU Initialization typedefs
+  **********************************************************************/
+ 
+ /* ARM 922T MMU Translation table structure */
+ typedef struct
+ {
+   ulong vidx[ARM922T_TT_ENTRIES];
+ } TRANSTABLE_T;
+ 
+ /* ARM 922T MMU Coarse page table type */
+ typedef struct
+ {
+   ulong vidx[ARM922T_CPT_ENTRIES];
+ } CPAGETABLE_T;
+ 
+ /* ARM 922T MMU Fine page table type */
+ typedef struct
+ {
+   ulong vidx[ARM922T_FPT_ENTRIES];
+ } FPAGETABLE_T;
+ 
+ /***********************************************************************
+  * ulong num_sections: number of 1MByte sections >=1 for all blocks
+  *     except last; last = 0
+  * ulong virt_addr: as required, base Virtual address for block
+  * ulong phys_addr: as required, PT address or Section address
+  * ulong entry is composed of the following 'or'd' together:
+  *     access_perm:  ARM922T_L1D_AP_x (x = SVC_ONLY, USR_RO, ALL)
+  *     domain:   ARM922T_L1D_DOMAIN(n) as applicable
+  *     cacheable:  ARM922T_L1D_CACHEABLE if applicable
+  *     write_buffered:  ARM922T_L1D_BUFFERABLE if applicable
+  *     descriptor_type: ARM922T_L1D_TYPE_x (x = FAULT, PAGE, SECTION)
+  **********************************************************************/
+ typedef const struct
+ {
+   ulong num_sections; /* Number of 1MByte sections */
+   ulong virt_addr;    /* Virtual address of section */
+   ulong phys_addr;    /* Physical address of section */
+   /* Section attributes - an 'OR'ed combination of ARM922T_L1D_AP_x,
+      ARM922T_L1D_DOMAIN, ARM922T_L1D_CACHEABLE,
+      ARM922T_L1D_BUFFERABLE, and ARM922T_L1D_TYPE_x */
+   ulong entry;
+ } TT_SECTION_BLOCK_T;
+ 
+ /***********************************************************************
+  * ARM 922T CP15 driver functions
+  **********************************************************************/
+ 
+ /* Return a physical address for a passed virtual address */
+ ulong cp15_map_virtual_to_physical(void *addr);
+ 
+ /* Get a virtual address from a passed physical address */
+ void * cp15_map_physical_to_virtual(ulong addr);
+ 
+ /* Force cache coherence between memory and cache for the selected
+    address range */
+ void cp15_force_cache_coherence(ulong *start_adr,
+                                 ulong *end_adr);
+ 
+ /* Setup MMU page tables */
+ BOOL_32 cp15_init_mmu_trans_table(TRANSTABLE_T *tt,
+                                   TT_SECTION_BLOCK_T *ttsbp);
+ 
+ /* Set the virtual address of the MMU table */
+ void cp15_set_vmmu_addr(ulong *addr);
+ 
+ /* Return the physical address of the MMU translation table */
+ ulong *cp15_get_ttb(void);
+ 
+ /* Force an data cache flush */
+ void cp15_dcache_flush(void);
+ 
+ /* Force an write buffer flush */
+ void cp15_write_buffer_flush(void);
+ 
+ /* Checks to see if the MMU is enabled */
+ BOOL_32 cp15_mmu_enabled(void);
+ 
+ /* Return the current value of MMU Coprocessor(CP15) Control register*/
+ ulong cp15_get_mmu_control_reg(void);
+ 
+ /* Set MMU Coprocessor(CP15) Control register*/
+ void cp15_set_mmu_control_reg(ulong mmu_reg);
+ 
+ /* Enable/Disable MMU */
+ void cp15_set_mmu(BOOL_32 enable);
+ 
+ /* Invalidates the Instruction and Data caches */
+ void cp15_invalidate_cache(void);
+ 
+ /* Invalidates the Translation Lookaside Buffers */
+ void cp15_invalidate_tlb(void);
+ 
+ /* Sets the first-level translation table base address */
+ void cp15_set_transtable_base(ulong addr);
+ 
+ /* Enables or disables the instruction cache */
+ void cp15_set_icache(BOOL_32 enable);
+ 
+ /* Enables or disables the data cache */
+ void cp15_set_dcache(BOOL_32 enable);
+ 
+ /* Define the access permissions for the 16 MMU domains. */
+ void cp15_set_domain_access(ulong dac);
+ 
+ #if defined (__cplusplus)
+ }
+ #endif /*__cplusplus */
+ 
+ #endif /* LPC_ARM922T_CP15_DRIVER_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc_params.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc_params.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc_params.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc_params.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,59 ----
+ /***********************************************************************
+  * $Id:: lpc_params.h 745 2008-05-13 19:59:29Z pdurgesh                $
+  *
+  * Project: Common structures used in various drivers
+  *
+  * Description:
+  *     This file contains structures used in various drivers. These
+  *     structures are common amond drivers of different designs and
+  *     tend to control generic aspects of the driver.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  **********************************************************************/
+ 
+ #ifndef LPC_PARAMS_H
+ #define LPC_PARAMS_H
+ 
+ #include <common.h>
+ 
+ #if defined (__cplusplus)
+ extern "C"
+ {
+ #endif
+ 
+ /***********************************************************************
+  * Common UART control typedefs
+  **********************************************************************/
+ 
+ /* Parity settings */
+ typedef enum
+ {
+   UART_PAR_NONE,
+   UART_PAR_EVEN,
+   UART_PAR_ODD
+ } UART_PAR_T;
+ 
+ /* UART control */
+ typedef struct
+ {
+   ulong baud_rate;     /* Device baud rate */
+   UART_PAR_T parity;    /* Parity selection */
+   ulong databits;      /* Number of data bits */
+   ulong stopbits;      /* Number of stop bits */
+ } UART_CONTROL_T;
+ 
+ #if defined (__cplusplus)
+ }
+ #endif /*__cplusplus */
+ 
+ #endif /* LPC_PARAMS_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc_sdmmc.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc_sdmmc.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/lpc_sdmmc.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/lpc_sdmmc.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,321 ----
+ /***********************************************************************
+  * $Id:: lpc_sdmmc.h 1311 2008-11-04 19:34:54Z pdurgesh                $
+  *
+  * Project: SD/MMC definitions
+  *
+  * Description:
+  *     This file contains the structure definitions and manifest
+  *     constants for the following component:
+  *         SD/MMC storage cards
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  **********************************************************************/
+ 
+ #ifndef LPC_SDMMC_H
+ #define LPC_SDMMC_H
+ 
+ 
+ #if defined (__cplusplus)
+ extern "C"
+ {
+ #endif
+ 
+ /* SD/MMC commands - this matrix shows the command, response types, and
+    supported card type for that command.
+    Command                 Number Resp  SD  MMC
+    ----------------------- ------ ----- --- ---
+    Reset (go idle)         CMD0   NA    x   x
+    Send op condition       CMD1   R3        x
+    All send CID            CMD2   R2    x   x
+    Send relative address   CMD3   R1        x
+    Send relative address   CMD3   R6    x
+    Program DSR             CMD4   NA        x
+    Select/deselect card    CMD7   R1b       x
+    Select/deselect card    CMD7   R1    x
+    Send CSD                CMD9   R2    x   x
+    Send CID                CMD10  R2    x   x
+    Read data until stop    CMD11  R1    x   x
+    Stop transmission       CMD12  R1/b  x   x
+    Send status             CMD13  R1    x   x
+    Go inactive state       CMD15  NA    x   x
+    Set block length        CMD16  R1    x   x
+    Read single block       CMD17  R1    x   x
+    Read multiple blocks    CMD18  R1    x   x
+    Write data until stop   CMD20  R1        x
+    Setblock count          CMD23  R1        x
+    Write single block      CMD24  R1    x   x
+    Write multiple blocks   CMD25  R1    x   x
+    Program CID             CMD26  R1        x
+    Program CSD             CMD27  R1    x   x
+    Set write protection    CMD28  R1b   x   x
+    Clear write protection  CMD29  R1b   x   x
+    Send write protection   CMD30  R1    x   x
+    Erase block start       CMD32  R1    x
+    Erase block end         CMD33  R1    x
+    Erase block start       CMD35  R1        x
+    Erase block end         CMD36  R1        x
+    Erase blocks            CMD38  R1b       x
+    Fast IO                 CMD39  R4        x
+    Go IRQ state            CMD40  R5        x
+    Lock/unlock             CMD42  R1b       x
+    Application command     CMD55  R1        x
+    General command         CMD56  R1b       x
+ 
+    *** SD card application commands - these must be preceded with ***
+    *** MMC CMD55 application specific command first               ***
+    Set bus width           ACMD6  R1    x
+    Send SD status          ACMD13 R1    x
+    Send number WR blocks   ACMD22 R1    x
+    Set WR block erase cnt  ACMD23 R1    x
+    Send op condition       ACMD41 R3    x
+    Set clear card detect   ACMD42 R1    x
+    Send CSR                ACMD51 R1    x */
+ typedef enum
+ {
+   SDMMC_IDLE,              /* Put card in idle mode */
+   MMC_SENDOP_COND,         /* Send operating condition */
+   SDMMC_ALL_SEND_CID,      /* All cards send CID */
+   SDMMC_SRA,               /* Set relative address */
+   MMC_PROGRAM_DSR,         /* Program DSR */
+   SDMMC_SELECT_CARD,       /* Select card */
+   SDMMC_SEND_CSD,          /* Send CSD data */
+   SDMMC_SEND_CID,          /* Send CID register data (with rel.
+                                 addr) */
+   SDMMC_READ_UNTIL_STOP,   /* Read data until stop */
+   SDMMC_STOP_XFER,         /* Stop current transmission */
+   SDMMC_SSTAT,             /* Send status */
+   SDMMC_INACTIVE,          /* Put card in inactive state */
+   SDMMC_SET_BLEN,          /* Set block transfer length */
+   SDMMC_READ_SINGLE,       /* Read single block */
+   SDMMC_READ_MULTIPLE,     /* Read multiple blocks */
+   SDMMC_WRITE_UNTIL_STOP,  /* Write data until stop */
+   SDMMC_SET_BLOCK_COUNT,   /* Set block count */
+   SDMMC_WRITE_SINGLE,      /* Write single block */
+   SDMMC_WRITE_MULTIPLE,    /* Write multiple blocks */
+   MMC_PROGRAM_CID,         /* Program CID */
+   SDMMC_PROGRAM_CSD,       /* Program CSD */
+   SDMMC_SET_WR_PROT,       /* Set write protection */
+   SDMMC_CLEAR_WR_PROT,     /* Clear write protection */
+   SDMMC_SEND_WR_PROT,      /* Send write protection */
+   SD_ERASE_BLOCK_START,    /* Set starting erase block */
+   SD_ERASE_BLOCK_END,      /* Set ending erase block */
+   MMC_ERASE_BLOCK_START,   /* Set starting erase block */
+   MMC_ERASE_BLOCK_END,     /* Set ending erase block */
+   MMC_ERASE_BLOCKS,        /* Erase blocks */
+   MMC_FAST_IO,             /* Fast IO */
+   MMC_GO_IRQ_STATE,        /* Go into IRQ state */
+   MMC_LOCK_UNLOCK,         /* Lock/unlock */
+   SDMMC_APP_CMD,           /* Application specific command */
+   SDMMC_GEN_CMD,           /* General purpose command */
+   SDMMC_INVALID_CMD        /* Invalid SDMMC command */
+ } SDMMC_COMMAND_T;
+ 
+ /* SDMMC application specific commands for SD cards only - these must
+    be preceded by the SDMMC CMD55 to work correctly */
+ typedef enum
+ {
+   SD_SET_BUS_WIDTH,        /* Set the SD bus width */
+   SD_SEND_STATUS,          /* Send the SD card status */
+   SD_SEND_WR_BLOCKS,       /* Send the number of written clocks */
+   SD_SET_ERASE_COUNT,      /* Set the number of blocks to pre-erase */
+   SD_SENDOP_COND,          /* Send the OCR register (init) */
+   SD_CLEAR_CARD_DET,       /* Set or clear the 50K detect pullup */
+   SD_SEND_SCR,             /* Send the SD configuration register */
+   SD_INVALID_APP_CMD       /* Invalid SD application command */
+ } SD_APP_CMD_T;
+ 
+ /* Possible SDMMC response types */
+ typedef enum
+ {
+   SDMMC_RESPONSE_R1,       /* Typical status */
+   SDMMC_RESPONSE_R1B,      /* Typical status with busy */
+   SDMMC_RESPONSE_R2,       /* CID/CSD registers (CMD2 and CMD10) */
+   SDMMC_RESPONSE_R3,       /* OCR register (CMD1, ACMD41) */
+   SDMMC_RESPONSE_R4,       /* Fast IO response word */
+   SDMMC_RESPONSE_R5,       /* Go IRQ state response word */
+   SDMMC_RESPONSE_R6,       /* Published RCA response */
+   SDMMC_RESPONSE_NONE      /* No response expected */
+ } SDMMC_RESPONSE_T;
+ 
+ /* Possible SDMMC card state types */
+ typedef enum
+ {
+   SDMMC_IDLE_ST = 0,   /* Idle state */
+   SDMMC_READY_ST,      /* Ready state */
+   SDMMC_IDENT_ST,      /* Identification State */
+   SDMMC_STBY_ST,       /* standby state */
+   SDMMC_TRAN_ST,       /* transfer state */
+   SDMMC_DATA_ST,       /* Sending-data State */
+   SDMMC_RCV_ST,        /* Receive-data State */
+   SDMMC_PRG_ST,        /* Programming State */
+   SDMMC_DIS_ST         /* Disconnect State */
+ } SDMMC_STATE_T;
+ 
+ #if defined (__cplusplus)
+ }
+ #endif /*__cplusplus */
+ 
+ /* Standard MMC commands (3.1)           type  argument     response */
+ /* class 1 */
+ #define MMC_GO_IDLE_STATE         0   /* bc                          */
+ #define MMC_SEND_OP_COND          1   /* bcr  [31:0]  OCR        R3  */
+ #define MMC_ALL_SEND_CID          2   /* bcr                     R2  */
+ #define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
+ #define MMC_SET_DSR               4   /* bc   [31:16] RCA            */
+ #define MMC_SELECT_CARD           7   /* ac   [31:16] RCA        R1  */
+ #define MMC_SEND_EXT_CSD          8   /* bc                      R1  */
+ #define MMC_SEND_CSD              9   /* ac   [31:16] RCA        R2  */
+ #define MMC_SEND_CID             10   /* ac   [31:16] RCA        R2  */
+ #define MMC_STOP_TRANSMISSION    12   /* ac                      R1b */
+ #define MMC_SEND_STATUS          13   /* ac   [31:16] RCA        R1  */
+ #define MMC_GO_INACTIVE_STATE    15   /* ac   [31:16] RCA            */
+ 
+ /* class 2 */
+ #define MMC_SET_BLOCKLEN         16   /* ac   [31:0]  block len  R1  */
+ #define MMC_READ_SINGLE_BLOCK    17   /* adtc [31:0]  data addr  R1  */
+ #define MMC_READ_MULTIPLE_BLOCK  18   /* adtc [31:0]  data addr  R1  */
+ 
+ /* class 3 */
+ #define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0]  data addr  R1  */
+ 
+ /* class 4 */
+ #define MMC_SET_BLOCK_COUNT      23   /* adtc [31:0]  data addr  R1  */
+ #define MMC_WRITE_BLOCK          24   /* adtc [31:0]  data addr  R1  */
+ #define MMC_WRITE_MULTIPLE_BLOCK 25   /* adtc                    R1  */
+ #define MMC_PROGRAM_CID          26   /* adtc                    R1  */
+ #define MMC_PROGRAM_CSD          27   /* adtc                    R1  */
+ 
+ /* class 6 */
+ #define MMC_SET_WRITE_PROT       28   /* ac   [31:0]  data addr  R1b */
+ #define MMC_CLR_WRITE_PROT       29   /* ac   [31:0]  data addr  R1b */
+ #define MMC_SEND_WRITE_PROT      30   /* adtc [31:0]  wpdata addr R1  */
+ 
+ /* class 5 */
+ #define MMC_ERASE_GROUP_START    35   /* ac   [31:0]  data addr  R1  */
+ #define MMC_ERASE_GROUP_END      36   /* ac   [31:0]  data addr  R1  */
+ #define MMC_ERASE                37   /* ac                      R1b */
+ 
+ /* class 9 */
+ #define MMC_FAST_IO              39   /* ac   <Complex>          R4  */
+ #define MMC_GO_IRQ_STATE         40   /* bcr                     R5  */
+ 
+ /* class 7 */
+ #define MMC_LOCK_UNLOCK          42   /* adtc                    R1b */
+ 
+ /* class 8 */
+ #define MMC_APP_CMD              55   /* ac   [31:16] RCA        R1  */
+ #define MMC_GEN_CMD              56   /* adtc [0]     RD/WR      R1b */
+ 
+ /* SD commands                           type  argument     response */
+ /* class 8 */
+ /* This is basically the same command as for MMC with some quirks. */
+ #define SD_SEND_RELATIVE_ADDR     3   /* ac                      R6  */
+ #define SD_CMD8                   8   /* bcr  [31:0]  OCR        R3  */
+ 
+ /* Application commands */
+ #define SD_APP_SET_BUS_WIDTH      6   /* ac   [1:0]   bus width  R1   */
+ #define SD_APP_OP_COND           41   /* bcr  [31:0]  OCR        R1 (R4)  */
+ #define SD_APP_SEND_SCR          51   /* adtc                    R1   */
+ 
+ /*
+   MMC status in R1
+   Type
+     e : error bit
+     s : status bit
+     r : detected and set for the actual command response
+     x : detected and set during command execution. the host must poll
+         the card by sending status command in order to read these bits.
+   Clear condition
+     a : according to the card state
+     b : always related to the previous command. Reception of
+         a valid command will clear it (with a delay of one command)
+     c : clear by read
+  */
+ 
+ #define R1_OUT_OF_RANGE         _BIT(31)    /* er, c */
+ #define R1_ADDRESS_ERROR        _BIT(30)    /* erx, c */
+ #define R1_BLOCK_LEN_ERROR      _BIT(29)    /* er, c */
+ #define R1_ERASE_SEQ_ERROR      _BIT(28)    /* er, c */
+ #define R1_ERASE_PARAM          _BIT(27)    /* ex, c */
+ #define R1_WP_VIOLATION         _BIT(26)    /* erx, c */
+ #define R1_CARD_IS_LOCKED       _BIT(25)    /* sx, a */
+ #define R1_LOCK_UNLOCK_FAILED   _BIT(24)    /* erx, c */
+ #define R1_COM_CRC_ERROR        _BIT(23)    /* er, b */
+ #define R1_ILLEGAL_COMMAND      _BIT(22)    /* er, b */
+ #define R1_CARD_ECC_FAILED      _BIT(21)    /* ex, c */
+ #define R1_CC_ERROR             _BIT(20)    /* erx, c */
+ #define R1_ERROR                _BIT(19)    /* erx, c */
+ #define R1_UNDERRUN             _BIT(18)    /* ex, c */
+ #define R1_OVERRUN              _BIT(17)    /* ex, c */
+ #define R1_CID_CSD_OVERWRITE    _BIT(16)    /* erx, c, CID/CSD overwrite */
+ #define R1_WP_ERASE_SKIP        _BIT(15)    /* sx, c */
+ #define R1_CARD_ECC_DISABLED    _BIT(14)    /* sx, a */
+ #define R1_ERASE_RESET          _BIT(13)    /* sr, c */
+ #define R1_STATUS(x)            (x & 0xFFFFE000)
+ #define R1_CURRENT_STATE(x)     ((x & 0x00001E00) >> 9) /* sx, b (4 bits) */
+ #define R1_READY_FOR_DATA       _BIT(8) /* sx, a */
+ #define R1_APP_CMD              _BIT(5) /* sr, c */
+ 
+ #define OCR_ALL_READY           _BIT(31)    /* Card Power up status bit */
+ #define OCR_HC_CCS              _BIT(30)  /* High capacity card */
+ #define OCR_VOLTAGE_RANGE_MSK   0x00ff8000
+ 
+ #define SD_SEND_IF_ARG          0x000001AA
+ #define SD_SEND_IF_ECHO_MSK     0x000000FF
+ #define SD_SEND_IF_RESP         0x000000AA
+ 
+ 
+ #define CMD_MASK_RESP       _SBF(28, 0x3)
+ #define CMD_RESP(r)         _SBF(28, ((r) & 0x3))
+ #define CMD_RESP_R0         _SBF(28, 0)
+ #define CMD_RESP_R1         _SBF(28, 1)
+ #define CMD_RESP_R2         _SBF(28, 2)
+ #define CMD_RESP_R3         _SBF(28, 3)
+ #define CMD_BIT_AUTO_STOP   _BIT(24)
+ #define CMD_BIT_APP         _BIT(23)
+ #define CMD_BIT_INIT        _BIT(22)
+ #define CMD_BIT_BUSY        _BIT(21)
+ #define CMD_BIT_LS          _BIT(20) /* Low speed, used during acquire */
+ #define CMD_BIT_DATA        _BIT(19)
+ #define CMD_BIT_WRITE       _BIT(18)
+ #define CMD_BIT_STREAM      _BIT(17)
+ #define CMD_MASK_CMD        (0xff)
+ #define CMD_SHIFT_CMD       (0)
+ 
+ #define CMD(c,r)        ( ((c) &  CMD_MASK_CMD) | CMD_RESP((r)) )
+ 
+ #define CMD_IDLE            CMD(MMC_GO_IDLE_STATE,0) | CMD_BIT_LS    | CMD_BIT_INIT
+ #define CMD_SD_OP_COND      CMD(SD_APP_OP_COND,1)      | CMD_BIT_LS | CMD_BIT_APP
+ #define CMD_SD_SEND_IF_COND CMD(SD_CMD8,1)      | CMD_BIT_LS
+ #define CMD_MMC_OP_COND     CMD(MMC_SEND_OP_COND,3)    | CMD_BIT_LS | CMD_BIT_INIT
+ #define CMD_ALL_SEND_CID    CMD(MMC_ALL_SEND_CID,2)    | CMD_BIT_LS
+ #define CMD_MMC_SET_RCA     CMD(MMC_SET_RELATIVE_ADDR,1) | CMD_BIT_LS
+ #define CMD_SD_SEND_RCA     CMD(SD_SEND_RELATIVE_ADDR,1) | CMD_BIT_LS
+ #define CMD_SEND_CSD        CMD(MMC_SEND_CSD,2) | CMD_BIT_LS
+ #define CMD_SEND_EXT_CSD    CMD(MMC_SEND_EXT_CSD,1) | CMD_BIT_LS | CMD_BIT_DATA
+ #define CMD_DESELECT_CARD   CMD(MMC_SELECT_CARD,0)
+ #define CMD_SELECT_CARD     CMD(MMC_SELECT_CARD,1)
+ #define CMD_SET_BLOCKLEN    CMD(MMC_SET_BLOCKLEN,1)
+ #define CMD_SEND_STATUS     CMD(MMC_SEND_STATUS,1)
+ #define CMD_READ_SINGLE     CMD(MMC_READ_SINGLE_BLOCK,1) | CMD_BIT_DATA
+ #define CMD_READ_MULTIPLE   CMD(MMC_READ_MULTIPLE_BLOCK,1) | CMD_BIT_DATA | CMD_BIT_AUTO_STOP
+ #define CMD_SD_SET_WIDTH    CMD(SD_APP_SET_BUS_WIDTH,1)| CMD_BIT_APP
+ #define CMD_STOP            CMD(MMC_STOP_TRANSMISSION,1) | CMD_BIT_BUSY
+ #define CMD_WRITE_SINGLE    CMD(MMC_WRITE_BLOCK,1) | CMD_BIT_DATA | CMD_BIT_WRITE
+ #define CMD_WRITE_MULTIPLE  CMD(MMC_WRITE_BLOCK,1) | CMD_BIT_DATA | CMD_BIT_WRITE | CMD_BIT_AUTO_STOP
+ 
+ #define MMC_SECTOR_SIZE     512
+ 
+ 
+ 
+ #endif /* LPC_SDMMC_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/Makefile u-boot-1.3.4/cpu/arm926ejs/lpc313x/Makefile
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/Makefile	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/Makefile	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,55 ----
+ #
+ # (C) Copyright 2000-2008
+ # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ #
+ # See file CREDITS for list of people who contributed to this
+ # project.
+ #
+ # This program is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU General Public License as
+ # published by the Free Software Foundation; either version 2 of
+ # the License, or (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ # GNU General Public License for more details.
+ #
+ # You should have received a copy of the GNU General Public License
+ # along with this program; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ # MA 02111-1307 USA
+ #
+ 
+ include $(TOPDIR)/config.mk
+ 
+ LIB	= $(obj)lib$(SOC).a
+ 
+ COBJS-y	+= lowlevelinit.o
+ COBJS-y	+= timer.o
+ COBJS-y += serial.o
+ COBJS-y	+= lpc313x_cgu_default.o
+ COBJS-y	+= lpc313x_cgu_driver.o
+ COBJS-y	+= lpc313x_timer_driver.o
+ COBJS-y	+= lpc313x_uart_driver.o
+ COBJS-y	+= lpc313x_mci_driver.o
+ COBJS-y	+= lpc313x_spi_driver.o
+ COBJS-y	+= ea3131_spinor.o
+ COBJS-y	+= lpc313x_nand_driver.o
+ 
+ SRCS    := $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+ OBJS    := $(addprefix $(obj),$(SOBJS) $(COBJS-y))
+ 
+ all:	$(obj).depend $(LIB)
+ 
+ $(LIB):	$(OBJS)
+ 	$(AR) $(ARFLAGS) $@ $(OBJS)
+ 
+ #########################################################################
+ 
+ # defines $(obj).depend target
+ include $(SRCTREE)/rules.mk
+ 
+ sinclude $(obj).depend
+ 
+ #########################################################################
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/mmc.h u-boot-1.3.4/cpu/arm926ejs/lpc313x/mmc.h
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/mmc.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/mmc.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,114 ----
+ /***********************************************************************
+  * $Id:: lpc313x_mci_driver.h 1338 2008-11-20 23:03:38Z pdurgesh     $
+  *
+  * Project: LPC313x SD/MMC/SDIO controller driver
+  *
+  * Description:
+  *     This file contains driver support for the LPC313x SD/MMC/SDIO
+  *     controller.
+  *
+  ***********************************************************************
+  * Software that is described herein is for illustrative purposes only
+  * which provides customers with programming information regarding the
+  * products. This software is supplied "AS IS" without any warranties.
+  * NXP Semiconductors assumes no responsibility or liability for the
+  * use of the software, conveys no license or title under any patent,
+  * copyright, or mask work right to the product. NXP Semiconductors
+  * reserves the right to make changes in the software without
+  * notification. NXP Semiconductors also make no representation or
+  * warranty that such application will be suitable for the specified
+  * use without further testing or modification.
+  *********************************************************************/
+ 
+ #ifndef LPC313X_MCI_DRIVER_H
+ #define LPC313X_MCI_DRIVER_H
+ 
+ #include "lpc313x_mci.h"
+ #include "lpc_sdmmc.h"
+ 
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ /***********************************************************************
+  * MCI device structure and it defines
+  **********************************************************************/
+ typedef struct  _mci_card_struct MCI_CARD_INFO_T;
+ typedef ulong(*MCI_CMD_WAIT_FUNC_T)(MCI_CARD_INFO_T* , ulong);
+ struct  _mci_card_struct
+ {
+   ulong response[4];	/* Most recent response */
+   ulong cid[4];			/* CID of acquired card  */
+   ulong csd[4];			/* CSD of acquired card */
+   ulong card_type;
+   ulong rca;			    /* Relative address assigned to card */
+   ulong speed;
+   ulong block_len;
+   ulong device_size;
+   ulong blocknr;
+   MCI_CMD_WAIT_FUNC_T wait_func;
+ 
+ };
+ 
+ /* card type defines */
+ #define CARD_TYPE_SD    (1 << 0)
+ #define CARD_TYPE_4BIT  (1 << 1)
+ #define CARD_TYPE_8BIT  (1 << 2)
+ #define CARD_TYPE_HC    (OCR_HC_CCS) /* high capacity card > 2GB */
+ 
+ 
+ /***********************************************************************
+  * MCI device configuration commands (IOCTL commands and arguments)
+  **********************************************************************/
+ 
+ /* MCI device commands (IOCTL commands) */
+ typedef enum
+ {
+   MCI_GET_CSD,
+   MCI_GET_EXT_CSD
+ } MCI_IOCTL_CMD_T;
+ 
+ 
+ 
+ 
+ /***********************************************************************
+  * MCI driver API functions
+  **********************************************************************/
+ 
+ /* Open the MCI */
+ int mmc_init(int verbose);
+ 
+ /* Close the MCI */
+ STATUS mci_close(long devid);
+ 
+ /* MCI configuration block */
+ STATUS mci_ioctl(long devid,
+                  long cmd,
+                  long arg);
+ 
+ /* MCI read function - read all 16 data registers */
+ long mci_read_blocks(long devid,
+ 							long start_block,
+ 							long blkcnt,
+ 							void* buffer);
+ 
+ /* MCI write function - writes all 16 data registers */
+ long mci_write_blocks(long devid,
+ 							long start_block,
+ 							long blkcnt,
+ 							void* buffer);
+ 
+ /***********************************************************************
+  * Other SDMMC driver functions
+  **********************************************************************/
+ long mci_execute_command(MCI_CARD_INFO_T* pdev,
+                            ulong cmd,
+                            ulong arg,
+                            ulong wait_status);
+ 
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* LPC313X_MCI_DRIVER_H */
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/serial.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/serial.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/serial.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/serial.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,106 ----
+ /*
+  * (C) Copyright 2002-2004
+  * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+  *
+  * (C) Copyright 2002
+  * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+  * Marius Groeger <mgroeger@sysgo.de>
+  *
+  * (C) Copyright 2002
+  * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+  * Alex Zuepke <azu@sysgo.de>
+  *
+  * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl)
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  *
+  */
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ #include "lpc313x_uart_driver.h"
+ 
+ DECLARE_GLOBAL_DATA_PTR;
+ 
+ static long uartdev;
+ UART_CONTROL_T ucntl;
+ 
+ void serial_setbrg (void)
+ {
+ 
+ }
+ 
+ /*
+  * Initialise the serial port with the given baudrate. The settings
+  * are always 8 data bits, no parity, 1 stop bit, no start bits.
+  *
+  */
+ int serial_init (void)
+ {
+ 	ucntl.baud_rate = gd->baudrate;
+ 	ucntl.parity = UART_PAR_NONE;
+ 	ucntl.databits = 8;
+ 	ucntl.stopbits = 1;
+ 	uartdev = uart_open((void *) UART_BASE, (long) & ucntl);
+ 
+ 	return (0);
+ }
+ 
+ 
+ /*
+  * Output a single byte to the serial port.
+  */
+ void serial_putc (const char c)
+ {
+ 	if (c == '\n')
+ 	{
+ 	    uart_write(uartdev, "\r\n", 2);
+ 	}
+ 	else
+ 	{
+ 		uart_write(uartdev, (void *)&c, 1);
+ 	}
+ }
+ 
+ /*
+  * Read a single byte from the serial port. Returns 1 on success, 0
+  * otherwise. When the function is succesfull, the character read is
+  * written into its argument c.
+  */
+ int serial_tstc (void)
+ {
+ 	return (int) ((uart_ioctl(uartdev, UART_GET_STATUS, UART_GET_LINE_STATUS) & UART_LSR_RDR) != 0);
+ }
+ 
+ /*
+  * Read a single byte from the serial port. Returns 1 on success, 0
+  * otherwise. When the function is succesfull, the character read is
+  * written into its argument c.
+  */
+ int serial_getc (void)
+ {
+ 	char c = 0;
+ 	uart_read(uartdev, &c, 1);
+ 	return c;
+ }
+ 
+ void serial_puts (const char *s)
+ {
+ 	while (*s) {
+ 		serial_putc (*s++);
+ 	}
+ }
+ 
+ 
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/timer.c u-boot-1.3.4/cpu/arm926ejs/lpc313x/timer.c
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/timer.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/timer.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,76 ----
+ /*
+  * (C) Copyright 2007-2008
+  * Stelian Pop <stelian.pop@leadtechdesign.com>
+  * Lead Tech Design <www.leadtechdesign.com>
+  *
+  * See file CREDITS for list of people who contributed to this
+  * project.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  */
+ 
+ #include <common.h>
+ #include <asm/arch/hardware.h>
+ #include "lpc313x_timer_driver.h"
+ 
+ static long timer0dev = 0;
+ 
+ /* starts timer 0 running */
+ int timer_init(void)
+ {
+ 	if(timer0dev == 0)
+ 	{
+ 		/* Open timers - this will enable the clocks for the timers - approx 4ticks/usec*/
+ 		timer0dev = timer_open((void *)TIMER_CNTR0, 0);
+ 		timer_ioctl(timer0dev, TMR_SET_PERIODIC_MODE, 0);
+ 		timer_ioctl(timer0dev, TMR_ENABLE, 1);
+ 	}
+ 	return 0;
+ }
+ 
+ unsigned long get_timer(unsigned long base)
+ {
+ 	ulong now = timer_ioctl(timer0dev, TMR_GET_STATUS, TMR_GET_COUNT);
+ 	if (now >= base)
+ 		return now - base;
+ 	return (base - now) ;
+ }
+ 
+ void udelay(unsigned long usec)
+ {
+ 	timer_wait_us(TIMER_CNTR1,usec);
+ 
+ }
+ /*
+  * Reset the cpu by setting up the watchdog timer and let him time out.
+  */
+ void reset_cpu(ulong ignored)
+ {
+ 	/* this is the way Linux does it
+ 	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY |
+ 				     AT91_RSTC_PROCRST |
+ 				     AT91_RSTC_PERRST); */
+ 
+ 	while (1);
+ 	/* Never reached */
+ }
+ 
+ void reset_timer()
+ {
+ }
+ 
+ 
+ 
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/u-boot.lds u-boot-1.3.4/cpu/arm926ejs/lpc313x/u-boot.lds
*** u-boot-1.3.4.clean/cpu/arm926ejs/lpc313x/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/cpu/arm926ejs/lpc313x/u-boot.lds	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,60 ----
+ /*
+  * (C) Copyright 2002
+  * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+  *
+  * See file CREDITS for list of people who contributed to this
+  * project.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  */
+ 
+ OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+ /*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+ OUTPUT_ARCH(arm)
+ ENTRY(_start)
+ SECTIONS
+ {
+ 	. = 0x00000000;
+ 
+ 	. = ALIGN(4);
+ 	.text :
+ 	{
+ 	  cpu/arm926ejs/start.o	(.text)
+ 	  *(.text)
+ 	}
+ /* __IMAGE_START = ADDR(text);*/
+ 
+ 	. = ALIGN(4);
+ 	.rodata : { *(.rodata) }
+ 
+ 	. = ALIGN(4);
+ 	.data : { *(.data) }
+ 
+ 	. = ALIGN(4);
+ 	.got : { *(.got) }
+ 
+ 	. = .;
+ 	__u_boot_cmd_start = .;
+ 	.u_boot_cmd : { *(.u_boot_cmd) }
+ 	__u_boot_cmd_end = .;
+ __DATA_END      = .;
+ __image_size    = __DATA_END - 0x11029000;
+ 
+ 	. = ALIGN(4);
+ 	__bss_start = .;
+ 	.bss : { *(.bss) }
+ 	_end = .;
+ }
diff -crBN u-boot-1.3.4.clean/cpu/arm926ejs/start.S u-boot-1.3.4/cpu/arm926ejs/start.S
*** u-boot-1.3.4.clean/cpu/arm926ejs/start.S	2008-08-12 16:08:38.000000000 +0200
--- u-boot-1.3.4/cpu/arm926ejs/start.S	2009-05-15 19:12:59.000000000 +0200
***************
*** 48,57 ****
   *************************************************************************
   */
  
! 
  .globl _start
  _start:
! 	b	reset
  	ldr	pc, _undefined_instruction
  	ldr	pc, _software_interrupt
  	ldr	pc, _prefetch_abort
--- 48,74 ----
   *************************************************************************
   */
  
! .globl _fiq
  .globl _start
+ .global __image_size
+ 
  _start:
! 	b reset
! 
! /*** Valid boot image signature ***/ 
! 	.word	0x41676d69 		/* image magic number */
! 	.word	0,0,0,0,0
! image_type:
! 	.word	0x0000000A 		/*Plain text no CRC check*/
! 
! sizeOfPermanentCode:	
! 	.word 	(__image_size)	/* image length */
! 
! 	.word 	0,0 
! bootparameter:	
! 	.word 	0
! 	.word 	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
! 	
  	ldr	pc, _undefined_instruction
  	ldr	pc, _software_interrupt
  	ldr	pc, _prefetch_abort
***************
*** 164,170 ****
  
  	/* Set up the stack						    */
  stack_setup:
! 	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
  	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
  	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
  #ifdef CONFIG_USE_IRQ
--- 181,189 ----
  
  	/* Set up the stack						    */
  stack_setup:
! 	ldr	r0, _TEXT_BASE			
! 	add r0, r0, #0x0002F000		/* point to end of IRAM, 0x11058000 */
! 
  	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
  	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
  #ifdef CONFIG_USE_IRQ
***************
*** 177,189 ****
  	ldr	r1, _bss_end		/* stop here                        */
  	mov	r2, #0x00000000		/* clear                            */
  
! clbss_l:str	r2, [r0]		/* clear loop...                    */
  	add	r0, r0, #4
  	cmp	r0, r1
  	ble	clbss_l
  
! 	bl coloured_LED_init
! 	bl red_LED_on
  
  	ldr	pc, _start_armboot
  
--- 196,211 ----
  	ldr	r1, _bss_end		/* stop here                        */
  	mov	r2, #0x00000000		/* clear                            */
  
! clbss_l:
! 	str	r2, [r0]		/* clear loop...                    */
  	add	r0, r0, #4
  	cmp	r0, r1
  	ble	clbss_l
  
! 	/*
! 	 * Go setup Memory and board specific bits prior to relocation.
! 	 */
! 	bl	lowlevel_init	/* go setup pll,mux,memory */
  
  	ldr	pc, _start_armboot
  
***************
*** 220,231 ****
  	orr	r0, r0, #0x00001000	/* set bit 12 (I) I-Cache */
  	mcr	p15, 0, r0, c1, c0, 0
  
- 	/*
- 	 * Go setup Memory and board specific bits prior to relocation.
- 	 */
- 	mov	ip, lr		/* perserve link reg across call */
- 	bl	lowlevel_init	/* go setup pll,mux,memory */
- 	mov	lr, ip		/* restore link */
  	mov	pc, lr		/* back to my caller */
  #endif /* CONFIG_SKIP_LOWLEVEL_INIT */
  
--- 242,247 ----
diff -crBN u-boot-1.3.4.clean/fs/ext2/ext2fs.c u-boot-1.3.4/fs/ext2/ext2fs.c
*** u-boot-1.3.4.clean/fs/ext2/ext2fs.c	2008-08-12 16:08:38.000000000 +0200
--- u-boot-1.3.4/fs/ext2/ext2fs.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 184,197 ****
  
  static int ext2fs_blockgroup
  	(struct ext2_data *data, int group, struct ext2_block_group *blkgrp) {
  #ifdef DEBUG
! 	printf ("ext2fs read blockgroup\n");
  #endif
! 	return (ext2fs_devread
! 		(((__le32_to_cpu (data->sblock.first_data_block) +
! 		   1) << LOG2_EXT2_BLOCK_SIZE (data)),
! 		 group * sizeof (struct ext2_block_group),
! 		 sizeof (struct ext2_block_group), (char *) blkgrp));
  }
  
  
--- 184,206 ----
  
  static int ext2fs_blockgroup
  	(struct ext2_data *data, int group, struct ext2_block_group *blkgrp) {
+ 
+ 	unsigned int blkno;
+ 	unsigned int blkoff;
+ 	unsigned int desc_per_blk;
+ 
+ 	desc_per_blk = EXT2_BLOCK_SIZE(data) / sizeof(struct ext2_block_group);
+ 
+ 	blkno = __le32_to_cpu(data->sblock.first_data_block) + 1 +
+ 	group / desc_per_blk;
+ 	blkoff = (group % desc_per_blk) * sizeof(struct ext2_block_group); 
+ 
+ 
  #ifdef DEBUG
! 	printf ("ext2fs read group: %d blkno: %d blkoff: %d desc_per_blk %d\n", group, blkno, blkoff,desc_per_blk); 
  #endif
! 
! 	return (ext2fs_devread(blkno << LOG2_EXT2_BLOCK_SIZE(data), blkoff, sizeof(struct ext2_block_group), (char *)blkgrp)); 
  }
  
  
***************
*** 217,235 ****
  	if (status == 0) {
  		return (0);
  	}
! 	inodes_per_block = EXT2_BLOCK_SIZE (data) / 128;
  	blkno = (ino % __le32_to_cpu (sblock->inodes_per_group)) /
  		inodes_per_block;
! 	blkoff = (ino % __le32_to_cpu (sblock->inodes_per_group)) %
  		inodes_per_block;
  #ifdef DEBUG
  	printf ("ext2fs read inode blkno %d blkoff %d\n", blkno, blkoff);
  #endif
  	/* Read the inode.  */
! 	status = ext2fs_devread (((__le32_to_cpu (blkgrp.inode_table_id) +
! 				   blkno) << LOG2_EXT2_BLOCK_SIZE (data)),
! 				 sizeof (struct ext2_inode) * blkoff,
! 				 sizeof (struct ext2_inode), (char *) inode);
  	if (status == 0) {
  		return (0);
  	}
--- 226,247 ----
  	if (status == 0) {
  		return (0);
  	}
! 	/*Not all inodes are 128 bytes long (or so it seems to me)*/ 
! 	inodes_per_block = EXT2_BLOCK_SIZE (data) / __le32_to_cpu(sblock->inode_size); 
  	blkno = (ino % __le32_to_cpu (sblock->inodes_per_group)) /
  		inodes_per_block;
! 	blkoff = (ino % __le32_to_cpu (sblock->inodes_per_group)) %		
  		inodes_per_block;
  #ifdef DEBUG
  	printf ("ext2fs read inode blkno %d blkoff %d\n", blkno, blkoff);
  #endif
  	/* Read the inode.  */
! 	status = ext2fs_devread (((__le32_to_cpu (blkgrp.inode_table_id) + blkno) << LOG2_EXT2_BLOCK_SIZE (data)),
! 							 /*Not all inodes are 128 bytes long (or so it seems to me)*/ 
! 				 			 __le32_to_cpu(sblock->inode_size) * blkoff,
! 				 			 /*Need a fix for case when inode > 128*/ 
! 							 sizeof (struct ext2_inode), 
! 							 (char *) inode); 
  	if (status == 0) {
  		return (0);
  	}
diff -crBN u-boot-1.3.4.clean/fs/fat/fat.c u-boot-1.3.4/fs/fat/fat.c
*** u-boot-1.3.4.clean/fs/fat/fat.c	2008-08-12 16:08:38.000000000 +0200
--- u-boot-1.3.4/fs/fat/fat.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 30,35 ****
--- 30,36 ----
  #include <fat.h>
  #include <asm/byteorder.h>
  #include <part.h>
+ #include <malloc.h>
  
  #if defined(CONFIG_CMD_FAT)
  
***************
*** 435,441 ****
--- 436,447 ----
   * into 'retdent'
   * Return 0 on success, -1 otherwise.
   */
+ #ifndef CONFIG_LPC313X
  __u8	 get_vfatname_block[MAX_CLUSTSIZE];
+ #else
+ __u8* get_vfatname_block = NULL;
+ #endif
+ 
  static int
  get_vfatname(fsdata *mydata, int curclust, __u8 *cluster,
  	     dir_entry *retdent, char *l_name)
***************
*** 445,451 ****
  	__u8	  *nextclust = cluster + mydata->clust_size * SECTOR_SIZE;
  	__u8	   counter = (slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff;
  	int idx = 0;
! 
  	while ((__u8*)slotptr < nextclust) {
  		if (counter == 0) break;
  		if (((slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff) != counter)
--- 451,459 ----
  	__u8	  *nextclust = cluster + mydata->clust_size * SECTOR_SIZE;
  	__u8	   counter = (slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff;
  	int idx = 0;
! #ifdef CONFIG_LPC313X
! 	if(get_vfatname_block == NULL)get_vfatname_block = malloc(MAX_CLUSTSIZE);
! #endif
  	while ((__u8*)slotptr < nextclust) {
  		if (counter == 0) break;
  		if (((slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff) != counter)
***************
*** 521,527 ****
--- 529,539 ----
   * Get the directory entry associated with 'filename' from the directory
   * starting at 'startsect'
   */
+ #ifndef CONFIG_LPC313X
  __u8 get_dentfromdir_block[MAX_CLUSTSIZE];
+ #else
+ __u8* get_dentfromdir_block = NULL;
+ #endif
  static dir_entry *get_dentfromdir (fsdata * mydata, int startsect,
  				   char *filename, dir_entry * retdent,
  				   int dols)
***************
*** 529,534 ****
--- 541,549 ----
      __u16 prevcksum = 0xffff;
      __u32 curclust = START (retdent);
      int files = 0, dirs = 0;
+ #ifdef CONFIG_LPC313X
+ 	if(get_dentfromdir_block == NULL)get_dentfromdir_block = malloc(MAX_CLUSTSIZE);
+ #endif
  
      FAT_DPRINT ("get_dentfromdir: %s\n", filename);
      while (1) {
***************
*** 658,664 ****
  	    return NULL;
  	}
      }
! 
      return NULL;
  }
  
--- 673,679 ----
  	    return NULL;
  	}
      }
! 	
      return NULL;
  }
  
***************
*** 726,733 ****
  	return -1;
  }
  
! 
  __u8 do_fat_read_block[MAX_CLUSTSIZE];  /* Block buffer */
  long
  do_fat_read (const char *filename, void *buffer, unsigned long maxsize,
  	     int dols)
--- 741,751 ----
  	return -1;
  }
  
! #ifndef CONFIG_LPC313X
  __u8 do_fat_read_block[MAX_CLUSTSIZE];  /* Block buffer */
+ #else
+ __u8* do_fat_read_block = NULL;
+ #endif
  long
  do_fat_read (const char *filename, void *buffer, unsigned long maxsize,
  	     int dols)
***************
*** 749,754 ****
--- 767,777 ----
      long ret = 0;
      int firsttime;
  
+ #ifdef CONFIG_LPC313X
+ 	if(do_fat_read_block == NULL)do_fat_read_block = malloc(MAX_CLUSTSIZE);	/* Block buffer */
+ #endif
+ 
+ 
      if (read_bootsectandvi (&bs, &volinfo, &mydata->fatsize)) {
  	FAT_DPRINT ("Error: reading boot sector\n");
  	return -1;
diff -crBN u-boot-1.3.4.clean/include/asm-arm/arch-lpc313x/hardware.h u-boot-1.3.4/include/asm-arm/arch-lpc313x/hardware.h
*** u-boot-1.3.4.clean/include/asm-arm/arch-lpc313x/hardware.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/include/asm-arm/arch-lpc313x/hardware.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,30 ----
+ /*
+  * linux/include/asm-arm/arch-lpc313x/hardware.h
+  *
+  *  Copyright (C) 2009 DVM
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+ #ifndef __ASM_ARCH_HARDWARE_H
+ #define __ASM_ARCH_HARDWARE_H
+ 
+ #if defined(CONFIG_LPC313X)
+ #include <asm-arm/arch-lpc313x/lpc313x_registers.h>
+ #else
+ #error No hardware file defined for this configuration
+ #endif
+ 
+ 
+ #endif
diff -crBN u-boot-1.3.4.clean/include/asm-arm/arch-lpc313x/lpc313x_registers.h u-boot-1.3.4/include/asm-arm/arch-lpc313x/lpc313x_registers.h
*** u-boot-1.3.4.clean/include/asm-arm/arch-lpc313x/lpc313x_registers.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/include/asm-arm/arch-lpc313x/lpc313x_registers.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,264 ----
+ #ifndef __LPC313X_REGISTERS_H
+ #define __LPC313X_REGISTERS_H
+ 
+ #include <config.h>
+ 
+ /* Macros for reading/writing registers */
+ #define PUT8(reg, value) (*(volatile unsigned char*)(reg) = (value))
+ #define PUT16(reg, value) (*(volatile unsigned short*)(reg) = (value))
+ #define PUT32(reg, value) (*(volatile unsigned int*)(reg) = (value))
+ #define GET8(reg) (*(volatile unsigned char*)(reg))
+ #define GET16(reg) (*(volatile unsigned short*)(reg))
+ #define GET32(reg) (*(volatile unsigned int*)(reg))
+ 
+ 
+ 
+ #define INT_PRIORITYMASK_0			0x60000000
+ #define INT_PRIORITYMASK_1			0x60000004
+ #define INT_VECTOR_0				0x60000100
+ #define INT_VECTOR_1				0x60000104
+ #define INT_PENDING_1_31			0x60000200
+ #define INT_FEATURES				0x60000300
+ #define INT_REQUEST_1 				0x60000404
+ 
+ 
+ #define _BIT(n)	(((ulong)(1)) << (n))
+ 
+ #undef _SBF
+ /* Set bit field macro */
+ #define _SBF(f,v) (((ulong)(v)) << (f))
+ 
+ #define _BITMASK(field_width) ( _BIT(field_width) - 1)
+ 
+ typedef void (*PFV)(void);
+ 
+ 
+ typedef long STATUS;
+ 
+ /* NO_ERROR macro */
+ #define _NO_ERROR           (long)(0)
+ /* ERROR macro */
+ #define _ERROR              (long)(-1)
+ /* Device unknown macro */
+ #define LPC_DEV_UNKNOWN     (long)(-2)
+ /* Device not supported macro */
+ #define LPC_NOT_SUPPORTED   (long)(-3)
+ /* Device not open macro */
+ #define LPC_NOT_OPEN        (long)(-4)
+ /* Device in use macro */
+ #define LPC_IN_USE          (long)(-5)
+ /* Device oin conflict macro */
+ #define LPC_PIN_CONFLICT    (long)(-6)
+ /* Device bad paramaters macro */
+ #define LPC_BAD_PARAMS      (long)(-7)
+ /* Bad device handle macro */
+ #define LPC_BAD_HANDLE      (long)(-8)
+ /* Bad device clock macro */
+ #define LPC_BAD_CLK         (long)(-9)
+ /* Device can't start macro */
+ #define LPC_CANT_START      (long)(-10)
+ /* Device can't stop macro */
+ #define LPC_CANT_STOP       (long)(-11)
+ 
+ 
+ 
+ 
+ /* --------------------------------------------------------------------------
+ *  AHB0_SLAVE_PORT9 bus
+ *  -------------------------------------------------------------------------- */
+ #define ISRAM_BASE               0x11028000
+ #define ISRAM_LENGTH             0x00030000
+ 
+ /* --------------------------------------------------------------------------
+ *  isram subbase bus
+ *  -------------------------------------------------------------------------- */
+ #define ISRAM_ESRAM0_BASE        0x11028000
+ #define ISRAM_ESRAM0_LENGTH      0x00018000
+ #define ISRAM_ESRAM1_BASE        0x11040000
+ #define ISRAM_ESRAM1_LENGTH      0x00018000
+ 
+ 
+ /* --------------------------------------------------------------------------
+ *  AHB0_SLAVE_PORT11 bus
+ *  -------------------------------------------------------------------------- */
+ #define ISROM_BASE                0x12000000
+ #define ISROM_LENGTH              0x00020000
+ #define ISROM_MMU_TTB_BASE        0x1201C000
+ #define ISROM_CRC32_TABLE         0x12015CBC
+ 
+ /* --------------------------------------------------------------------------
+ *  AHB0_SLAVE_PORT0 bus
+ *  -------------------------------------------------------------------------- */
+ #define APB0_BASE                 0x13000000
+ #define APB0_LENGTH               0x00008000
+ 
+ /* --------------------------------------------------------------------------
+ *  APB0 bus
+ *  -------------------------------------------------------------------------- */
+ #define EVENT_ROUTER_BASE         0x13000000
+ #define EVENT_ROUTER_LENGTH       0x00002000
+ #define ADC_BASE                  0x13002000
+ #define ADC_LENGTH                0x00000400
+ #define WDOG_BASE                 0x13002400
+ #define WDOG_LENGTH               0x00000400
+ #define SYSCREG_BASE              0x13002800
+ #define SYSCREG_LENGTH            0x00000400
+ #define IOCONF_BASE               0x13003000
+ #define IOCONF_LENGTH             0x00001000
+ #define CGU_SWITCHBOX_BASE        0x13004000
+ #define CGU_SWITCHBOX_LENGTH      0x00000c00
+ #define CGU_BASE                  0x13004c00
+ #define CGU_LENGTH                0x00000400
+ 
+ 
+ /* --------------------------------------------------------------------------
+ *  APB0 bus
+ *  -------------------------------------------------------------------------- */
+ #define OTP_BASE                  0x13005000
+ #define OTP_LENGTH                0x00001000
+ #define CIC_RNG_BASE              0x13006000
+ #define CIC_RNG_LENGTH            0x00001000
+ 
+ /* --------------------------------------------------------------------------
+ *  AHB0_SLAVE_PORT1 bus
+ *  -------------------------------------------------------------------------- */
+ #define APB1_BASE                 0x13008000
+ #define APB1_LENGTH               0x00004000
+ 
+ /* --------------------------------------------------------------------------
+ *  APB1 bus
+ *  -------------------------------------------------------------------------- */
+ #define TIMER0_BASE               0x13008000
+ #define TIMER0_LENGTH             0x00000400
+ #define TIMER1_BASE               0x13008400
+ #define TIMER1_LENGTH             0x00000400
+ #define TIMER2_BASE               0x13008800
+ #define TIMER2_LENGTH             0x00000400
+ #define TIMER3_BASE               0x13008c00
+ #define TIMER3_LENGTH             0x00000400
+ #define PWM_BASE                  0x13009000
+ #define PWM_LENGTH                0x00001000
+ 
+ /* --------------------------------------------------------------------------
+ *  pwm subbase bus
+ *  -------------------------------------------------------------------------- */
+ #define PWM_0_BASE                0x13009000
+ #define PWM_0_LENGTH              0x00000008
+ 
+ /* --------------------------------------------------------------------------
+ *  APB1 bus
+ *  -------------------------------------------------------------------------- */
+ #define I2C0_BASE                 0x1300a000
+ #define I2C0_LENGTH               0x00000400
+ #define I2C1_BASE                 0x1300a400
+ #define I2C1_LENGTH               0x00000400
+ 
+ /* --------------------------------------------------------------------------
+ *  AHB0_SLAVE_PORT2 bus
+ *  -------------------------------------------------------------------------- */
+ #define APB2_BASE                 0x15000000
+ #define APB2_LENGTH               0x00004000
+ 
+ /* --------------------------------------------------------------------------
+ *  APB2 bus
+ *  -------------------------------------------------------------------------- */
+ #define IPINT_BASE                0x15000000
+ #define PINT_LENGTH               0x00000400
+ #define LCD_INTERFACE_BASE        0x15000400
+ #define LCD_INTERFACE_LENGTH      0x00000400
+ #define UART_BASE                 0x15001000
+ #define UART_LENGTH               0x00001000
+ #define SPI_BASE                  0x15002000
+ #define SPI_LENGTH                0x00001000
+ 
+ /* --------------------------------------------------------------------------
+ *  AHB0_SLAVE_PORT3 bus
+ *  -------------------------------------------------------------------------- */
+ #define APB3_BASE                 0x16000000
+ #define APB3_LENGTH               0x00000400
+ 
+ /* --------------------------------------------------------------------------
+ *  APB3 bus
+ *  -------------------------------------------------------------------------- */
+ //#define ADSS_CFG_BASE             0x16000000
+ //#define ADSS_CFG_LENGTH           0x00000400
+ 
+ /* --------------------------------------------------------------------------
+ *  adss_cfg subbase bus
+ *  -------------------------------------------------------------------------- */
+ #define ADSS_CFG_BASE             0x16000000
+ #define ADSS_CFG_LENGTH           0x00000080
+ #define SAO1_BASE                 0x16000080
+ #define SAO1_LENGTH               0x00000080
+ #define SAO2_BASE                 0x16000100
+ #define SAO2_LENGTH               0x00000080
+ #define SAI1_BASE                 0x16000180
+ #define SAI1_LENGTH               0x00000080
+ #define SAI2_BASE                 0x16000200
+ #define SAI2_LENGTH               0x00000080
+ #define SAO3_BASE                 0x16000280
+ #define SAO3_LENGTH               0x00000080
+ 
+ /* --------------------------------------------------------------------------
+ *  AHB0_SLAVE_PORT4 bus
+ *  -------------------------------------------------------------------------- */
+ #define APB4_BASE                 0x17000000
+ #define APB4_LENGTH               0x00001000
+ 
+ /* --------------------------------------------------------------------------
+ *  APB4 bus
+ *  -------------------------------------------------------------------------- */
+ #define DMA_BASE                  0x17000000
+ #define DMA_LENGTH                0x00000800
+ #define NANDFLASH_CTRL_CFG_BASE   0x17000800
+ #define NANDFLASH_CTRL_CFG_LENGTH 0x00000800
+ 
+ /* --------------------------------------------------------------------------
+ *  AHB0_SLAVE_PORT12 bus
+ *  -------------------------------------------------------------------------- */
+ #define MPMC_CFG_BASE             0x17008000
+ #define MPMC_CFG_LENGTH           0x00001000
+ 
+ /* --------------------------------------------------------------------------
+ *  AHB0_SLAVE_PORT7 bus
+ *  -------------------------------------------------------------------------- */
+ #define SD_MMC_BASE               0x18000000
+ #define SD_MMC_LENGTH             0x00000400
+ 
+ /* --------------------------------------------------------------------------
+ *  AHB0_SLAVE_PORT8 bus
+ *  -------------------------------------------------------------------------- */
+ #define USB2IP9028_BASE           0x19000000
+ #define USB2IP9028_LENGTH         0x00001000
+ 
+ /* --------------------------------------------------------------------------
+ *  ahb_mpmc_pl172_s0 subbase bus
+ *  -------------------------------------------------------------------------- */
+ #define EXT_SRAM0_0_BASE          0x20000000
+ #define EXT_SRAM0_0_LENGTH        0x00010000
+ #define EXT_SRAM0_1_BASE          0x20020000
+ #define EXT_SRAM0_1_LENGTH        0x00010000
+ #define EXT_SDRAM_BASE            0x30000000
+ #define EXT_SDRAM_LENGTH          0x10000000
+ 
+ /* --------------------------------------------------------------------------
+ *  AHB0_SLAVE_PORT5 bus
+ *  -------------------------------------------------------------------------- */
+ #define AHB2MMIO_BASE             0x60000000
+ #define AHB2MMIO_LENGTH           0x00001000
+ 
+ /* --------------------------------------------------------------------------
+ *  ahb2mmio bus
+ *  -------------------------------------------------------------------------- */
+ #define INTC_BASE                 0x60000000
+ #define INTC_LENGTH               0x00001000
+ 
+ /* --------------------------------------------------------------------------
+ *  AHB0_SLAVE_PORT6 bus
+ *  -------------------------------------------------------------------------- */
+ #define NANDFLASH_CTRL_S0_BASE    0x70000000
+ #define NANDFLASH_CTRL_S0_LENGTH  0x00000800
+ 
+ 
+ #endif
+ 
diff -crBN u-boot-1.3.4.clean/include/asm-arm/arch-lpc313x/mmc.h u-boot-1.3.4/include/asm-arm/arch-lpc313x/mmc.h
*** u-boot-1.3.4.clean/include/asm-arm/arch-lpc313x/mmc.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/include/asm-arm/arch-lpc313x/mmc.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,22 ----
+ /*
+  * A dummy header file for use with the LPC2292 port to keep the
+  * compiler happy.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  */
+ #ifndef _MMC_ARM_TDM_H_
+ #define _MMC_ARM_TDM_H_
+ #endif /* _MMC_ARM_TDM_H_ */
diff -crBN u-boot-1.3.4.clean/include/asm-arm/mach-types.h u-boot-1.3.4/include/asm-arm/mach-types.h
*** u-boot-1.3.4.clean/include/asm-arm/mach-types.h	2008-08-12 16:08:38.000000000 +0200
--- u-boot-1.3.4/include/asm-arm/mach-types.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 1597,1602 ****
--- 1597,1604 ----
  #define MACH_TYPE_DEXFLEX2             1604
  #define MACH_TYPE_SFFSDR               1657
  
+ #define MACH_TYPE_LPC313X		       2161
+ 
  #ifdef CONFIG_ARCH_EBSA110
  # ifdef machine_arch_type
  #  undef machine_arch_type
diff -crBN u-boot-1.3.4.clean/include/configs/lpc3131ea.h u-boot-1.3.4/include/configs/lpc3131ea.h
*** u-boot-1.3.4.clean/include/configs/lpc3131ea.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/include/configs/lpc3131ea.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,216 ----
+ /*
+  * (C) Copyright 2007
+  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+  *
+  * Configuation settings for the LPC2292SODIMM board from Embedded Artists.
+  *
+  * See file CREDITS for list of people who contributed to this
+  * project.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  */
+ 
+ #ifndef __CONFIG_H
+ #define __CONFIG_H
+ 
+ #define USE_NAND
+ 
+ /*
+  * If we are developing, we might want to start u-boot from ram
+  * so we MUST NOT initialize critical regs like mem-timing ...
+  */
+ #undef CONFIG_INIT_CRITICAL		/* undef for developing */
+ 
+ #undef CONFIG_SKIP_LOWLEVEL_INIT
+ #undef CONFIG_SKIP_RELOCATE_UBOOT
+ 
+ /*
+  * High Level Configuration Options
+  * (easy to change)
+  */
+ #define CONFIG_ARM926EJS	1	/* This is a ARM926EJS CPU	*/
+ #define CONFIG_ARM_THUMB	1	
+ #define CONFIG_LPC313X		1   /* this is an LPC313x */
+ 
+ #undef CONFIG_USE_IRQ			/* don't need them anymore */
+ 
+ /*
+  * Size of malloc() pool
+  */
+ #define CFG_MALLOC_LEN		0 /* No need for any malloc space, we steal from the end of the DRAM */
+ #define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+ 
+ /*
+  * Hardware drivers
+  */
+ 
+ /*
+  * select serial console configuration
+  */
+ #define CONFIG_SERIAL1		1	/* we use Serial line 1 */
+ 
+ /* allow to overwrite serial and ethaddr */
+ #define CONFIG_ENV_OVERWRITE
+ 
+ #define CONFIG_BAUDRATE		115200
+ 
+ /*
+  * Command line configuration.
+  */
+ #define CONFIG_CMD_AUTOSCRIPT	/* Autoscript Support		*/
+ #define CONFIG_CMD_BDI		/* bdinfo			*/
+ #define CONFIG_CMD_BOOTD	/* bootd			*/
+ #define CONFIG_CMD_CONSOLE	/* coninfo			*/
+ #define CONFIG_CMD_ECHO		/* echo arguments		*/
+ #define CONFIG_CMD_ENV		/* saveenv			*/
+ #define CONFIG_CMD_IMI		/* iminfo			*/
+ #define CONFIG_CMD_ITEST	/* Integer (and string) test	*/
+ #define CONFIG_CMD_MISC		/* Misc functions like sleep etc*/
+ #define CONFIG_CMD_RUN		/* run command in env variable	*/
+ #define CONFIG_CMD_SETGETDCR	/* DCR support on 4xx		*/
+ #define CONFIG_CMD_XIMG		/* Load part of Multi Image	*/
+ 
+ 
+ 
+ 
+ #define CFG_NO_FLASH
+ 
+ #undef CONFIG_CMD_FLASH
+ #undef CONFIG_CMD_NET
+ 
+ /* uncomment these lines if you want default UBoot environment vars */
+ /* #define CFG_ENV_IS_NOWHERE		1 */
+ /* uncomment these lines if you want to boot Linux from an SD card  - requires FAT and MMC support*/
+ /* #define CONFIG_BOOTARGS "console=ttyS0,115200" */
+ /* #define CONFIG_BOOTCOMMAND "mmcinit;fatload mmc 0 33000000 uImage;bootm	33000000" */
+ 
+ /* uncomment this line for command line NOR Flash tools */  
+ /* #define CONFIG_CMD_SPINOR 	1 */
+ /* uncomment these lines if you want your UBoot environment vars in SPI Flash */
+ /* #define CFG_ENV_IS_IN_SPINORFLASH 1 */
+ 
+ /* uncomment these lines if you want basic NAND support */
+ #define CONFIG_CMD_NAND   		1 
+ #define CFG_ENV_IS_IN_NAND 		1 
+ /* uncomment this line if you want large page support */
+ #define LPC313X_NAND_LP_SUPPORT	1
+ 
+ /* uncomment these lines if you want SD card support */
+ #define CONFIG_CMD_MMC 		 	1
+ #define CONFIG_MMC 			 	1
+ #define CONFIG_DOS_PARTITION 	1
+ 
+ /* uncomment these lines if you want ext2fs support */
+ /* #define CONFIG_CMD_EXT2		 	1 */
+ /* #define CONFIG_EXT2			 	1 */				
+ 
+ /* uncomment this line if you want M$ DOS FAT support */
+ #define CONFIG_CMD_FAT		 	1 
+ /* Uncomment this line if you want VFAT support */
+ /* #define CONFIG_SUPPORT_VFAT 		1 */
+ 
+ 
+ #ifdef CFG_ENV_IS_IN_NAND
+ #ifdef LPC313X_NAND_LP_SUPPORT
+ #define CFG_ENV_OFFSET			0x20000				/* Addr of Environment Sector	*/
+ #define CFG_ENV_SIZE			0x20000 			/* Total Size of Environment Sector	*/
+ #else
+ #define CFG_ENV_OFFSET			0x20000				/* Addr of Environment Sector	*/
+ #define CFG_ENV_SIZE			0x4000 				/* Total Size of Environment Sector	*/
+ #endif
+ #else
+ 
+ #ifdef CFG_ENV_IS_IN_SPINORFLASH
+ #define CFG_ENV_ADDR			0x20000				/* Addr of Environment Sector	*/
+ #define CFG_ENV_SIZE			0x800 				/* Total Size of Environment Sector	*/
+ #else
+ 
+ #define CFG_ENV_OFFSET			0x00				/* Addr of Environment Sector	*/
+ #define CFG_ENV_SIZE			0x800 				/* Total Size of Environment Sector	*/
+ 
+ #endif
+ #endif
+ 
+ #define CFG_NAND_BASE			0x00000000
+ #define CFG_MAX_NAND_DEVICE		1				/* Max number of NAND devices */
+ #define NAND_MAX_CHIPS			1
+ 
+ /* uncomment these lines if you want JFFS2 support */
+ /* #define CONFIG_JFFS2_NAND   	1
+ #define CONFIG_CMD_JFFS2		1
+ #define CONFIG_JFFS2_CMDLINE	1 */
+ 
+ /* uncomment these lines you want MTD partition support - requires JFFS2  */
+ /* #define MTDIDS_DEFAULT		"nand0=lpc313x_nand" */
+ /* #define MTDPARTS_DEFAULT	"mtdparts=lpc313x_nand:1M@1M(settings),-(images)" */
+ 
+ /* uncomment this line for a simple timer test - drives LED 2 */
+ /* #define CONFIG_CMD_TTEST 1 */
+ 
+ #define CONFIG_BOOTDELAY	5
+ 
+ /*
+  * Miscellaneous configurable options
+  */
+ #define	CFG_LONGHELP						/* undef to save memory		*/
+ #define	CFG_PROMPT			"LPC3131EA # " 	/* Monitor Command Prompt	*/
+ #define	CFG_CBSIZE			256				/* Console I/O Buffer Size	*/
+ #define	CFG_PBSIZE 			(CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+ #define	CFG_MAXARGS			16				/* max number of command args	*/
+ #define CFG_BARGSIZE		CFG_CBSIZE		/* Boot Argument Buffer Size	*/
+ 
+ #define CFG_MEMTEST_START	0x30000000 		/* memtest works on	*/
+ #define CFG_MEMTEST_END		0x33FFFFFF		/* 64MB of DRAM	*/
+ 
+ #undef	CFG_CLKS_IN_HZ						/* everything, incl board info, in Hz */
+ 
+ #define	CFG_LOAD_ADDR		11029000	
+ 
+ #define CFG_SYS_CLK_FREQ	180000000		/* Hz */
+ #define	CFG_HZ				2048			/* decrementer freq in Hz */
+ #define XTAL_IN				12000000
+ 
+ 											/* valid baudrates */
+ #define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+ 
+ /*-----------------------------------------------------------------------
+  * Stack sizes
+  *
+  * The stack sizes are set up in start.S using the settings below
+  */
+ #define CONFIG_STACKSIZE	(4*1024)	/* regular stack */
+ #ifdef CONFIG_USE_IRQ
+ #define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+ #define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+ #endif
+ 
+ /*-----------------------------------------------------------------------
+  * Physical Memory Map
+  */
+ #define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+ #define PHYS_SDRAM  		0x30000000 /* SDRAM Bank #1 */
+ #define PHYS_SDRAM_SIZE	    0x04000000 /* 64 MB SDRAM */
+ 
+ #define PHYS_FLASH_1		0x80000000 /* Flash Bank #1 */
+ #define PHYS_FLASH_SIZE		0x00200000 /* 2 MB */
+ 
+ #define CFG_FLASH_BASE		PHYS_FLASH_1
+ 
+ #define CONFIG_CMDLINE_TAG
+ #define CONFIG_SETUP_MEMORY_TAGS
+ #define CONFIG_INITRD_TAG
+ 
+ #endif	/* __CONFIG_H */
diff -crBN u-boot-1.3.4.clean/lib_arm/board.c u-boot-1.3.4/lib_arm/board.c
*** u-boot-1.3.4.clean/lib_arm/board.c	2008-08-12 16:08:38.000000000 +0200
--- u-boot-1.3.4/lib_arm/board.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 91,96 ****
--- 91,109 ----
  static ulong mem_malloc_end = 0;
  static ulong mem_malloc_brk = 0;
  
+ 
+ #ifdef CONFIG_LPC313X
+ static
+ void mem_malloc_init (ulong dest_addr, ulong length)
+ {
+ 	mem_malloc_start = dest_addr;
+ 	mem_malloc_end = dest_addr + length;
+ 	mem_malloc_brk = mem_malloc_start;
+ 
+ 	memset ((void *) mem_malloc_start, 0,
+ 			mem_malloc_end - mem_malloc_start);
+ }
+ #else
  static
  void mem_malloc_init (ulong dest_addr)
  {
***************
*** 101,107 ****
  	memset ((void *) mem_malloc_start, 0,
  			mem_malloc_end - mem_malloc_start);
  }
! 
  void *sbrk (ptrdiff_t increment)
  {
  	ulong old = mem_malloc_brk;
--- 114,120 ----
  	memset ((void *) mem_malloc_start, 0,
  			mem_malloc_end - mem_malloc_start);
  }
! #endif
  void *sbrk (ptrdiff_t increment)
  {
  	ulong old = mem_malloc_brk;
***************
*** 274,286 ****
  
  init_fnc_t *init_sequence[] = {
  	cpu_init,		/* basic cpu dependent setup */
! #if defined(CONFIG_SKIP_RELOCATE_UBOOT)
  	reloc_init,		/* Set the relocation done flag, must
  				   do this AFTER cpu_init(), but as soon
  				   as possible */
  #endif
  	board_init,		/* basic board dependent setup */
  	interrupt_init,		/* set up exceptions */
  	env_init,		/* initialize environment */
  	init_baudrate,		/* initialze baudrate settings */
  	serial_init,		/* serial communications setup */
--- 287,301 ----
  
  init_fnc_t *init_sequence[] = {
  	cpu_init,		/* basic cpu dependent setup */
! #if defined(CONFIG_SKIP_RELOCATE_UBOOT) 
  	reloc_init,		/* Set the relocation done flag, must
  				   do this AFTER cpu_init(), but as soon
  				   as possible */
  #endif
  	board_init,		/* basic board dependent setup */
+ #ifndef CONFIG_LPC313X
  	interrupt_init,		/* set up exceptions */
+ #endif
  	env_init,		/* initialize environment */
  	init_baudrate,		/* initialze baudrate settings */
  	serial_init,		/* serial communications setup */
***************
*** 312,318 ****
--- 327,337 ----
  #endif
  
  	/* Pointer is writable since we allocated a register for it */
+ #ifdef CONFIG_LPC313X
+ 	gd = (gd_t*)(_armboot_start + 0x2F000 - CFG_MALLOC_LEN - sizeof(gd_t));
+ #else
  	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
+ #endif
  	/* compiler optimization barrier needed for GCC >= 3.4 */
  	__asm__ __volatile__("": : :"memory");
  
***************
*** 364,371 ****
  #endif /* CONFIG_LCD */
  
  	/* armboot_start is defined in the board-specific linker script */
  	mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);
! 
  #if defined(CONFIG_CMD_NAND)
  	puts ("NAND:  ");
  	nand_init();		/* go init the NAND */
--- 383,393 ----
  #endif /* CONFIG_LCD */
  
  	/* armboot_start is defined in the board-specific linker script */
+ #ifdef CONFIG_LPC313X
+ 	mem_malloc_init (0x34000000 - 0x800000, 0x800000);
+ #else
  	mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);
! #endif
  #if defined(CONFIG_CMD_NAND)
  	puts ("NAND:  ");
  	nand_init();		/* go init the NAND */
diff -crBN u-boot-1.3.4.clean/MAKEALL u-boot-1.3.4/MAKEALL
*** u-boot-1.3.4.clean/MAKEALL	2008-08-12 16:08:38.000000000 +0200
--- u-boot-1.3.4/MAKEALL	2009-05-15 19:12:59.000000000 +0200
***************
*** 495,500 ****
--- 495,501 ----
  	davinci_schmoogie	\
  	davinci_sffsdr		\
  	davinci_sonata		\
+ 	lpc3131ea             \
  "
  
  #########################################################################
diff -crBN u-boot-1.3.4.clean/Makefile u-boot-1.3.4/Makefile
*** u-boot-1.3.4.clean/Makefile	2008-08-12 16:08:38.000000000 +0200
--- u-boot-1.3.4/Makefile	2009-05-15 19:12:59.000000000 +0200
***************
*** 2387,2392 ****
--- 2387,2395 ----
  at91sam9260ek_config	:	unconfig
  	@$(MKCONFIG) $(@:_config=) arm arm926ejs at91sam9260ek atmel at91sam9
  
+ lpc3131ea_config	:	unconfig
+ 	@$(MKCONFIG) $(@:_config=) arm arm926ejs lpc3131ea NULL lpc313x
+ 
  ########################################################################
  ## ARM Integrator boards - see doc/README-integrator for more info.
  integratorap_config	\
diff -crBN u-boot-1.3.4.clean/tools/crc32.c u-boot-1.3.4/tools/crc32.c
*** u-boot-1.3.4.clean/tools/crc32.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/tools/crc32.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,229 ----
+ /*
+  * This file is derived from crc32.c from the zlib-1.1.3 distribution
+  * by Jean-loup Gailly and Mark Adler.
+  */
+ 
+ /* crc32.c -- compute the CRC-32 of a data stream
+  * Copyright (C) 1995-1998 Mark Adler
+  * For conditions of distribution and use, see copyright notice in zlib.h
+  */
+ 
+ #ifndef USE_HOSTCC	/* Shut down "ANSI does not permit..." warnings */
+ #include <common.h>
+ #else
+ #include <stdint.h>
+ #endif
+ 
+ #if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+ #include <watchdog.h>
+ #endif
+ #include "zlib.h"
+ 
+ #define local static
+ #define ZEXPORT	/* empty */
+ 
+ #ifdef DYNAMIC_CRC_TABLE
+ 
+ local int crc_table_empty = 1;
+ local uint32_t crc_table[256];
+ local void make_crc_table OF((void));
+ 
+ /*
+   Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
+   x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
+ 
+   Polynomials over GF(2) are represented in binary, one bit per coefficient,
+   with the lowest powers in the most significant bit.  Then adding polynomials
+   is just exclusive-or, and multiplying a polynomial by x is a right shift by
+   one.  If we call the above polynomial p, and represent a byte as the
+   polynomial q, also with the lowest power in the most significant bit (so the
+   byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
+   where a mod b means the remainder after dividing a by b.
+ 
+   This calculation is done using the shift-register method of multiplying and
+   taking the remainder.  The register is initialized to zero, and for each
+   incoming bit, x^32 is added mod p to the register if the bit is a one (where
+   x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
+   x (which is shifting right by one and adding x^32 mod p if the bit shifted
+   out is a one).  We start with the highest power (least significant bit) of
+   q and repeat for all eight bits of q.
+ 
+   The table is simply the CRC of all possible eight bit values.  This is all
+   the information needed to generate CRC's on data a byte at a time for all
+   combinations of CRC register values and incoming bytes.
+ */
+ local void make_crc_table()
+ {
+   uint32_t c;
+   int n, k;
+   uLong poly;		/* polynomial exclusive-or pattern */
+   /* terms of polynomial defining this crc (except x^32): */
+   static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
+ 
+   /* make exclusive-or pattern from polynomial (0xedb88320L) */
+   poly = 0L;
+   for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
+     poly |= 1L << (31 - p[n]);
+ 
+   for (n = 0; n < 256; n++)
+   {
+     c = (uLong)n;
+     for (k = 0; k < 8; k++)
+       c = c & 1 ? poly ^ (c >> 1) : c >> 1;
+     crc_table[n] = c;
+   }
+   crc_table_empty = 0;
+ }
+ #else
+ /* ========================================================================
+  * Table of CRC-32's of all single-byte values (made by make_crc_table)
+  */
+ local const uint32_t crc_table[256] = {
+   0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+   0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+   0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+   0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+   0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+   0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+   0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+   0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+   0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+   0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+   0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+   0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+   0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+   0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+   0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+   0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+   0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+   0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+   0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+   0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+   0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+   0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+   0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+   0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+   0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+   0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+   0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+   0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+   0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+   0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+   0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+   0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+   0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+   0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+   0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+   0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+   0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+   0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+   0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+   0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+   0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+   0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+   0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+   0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+   0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+   0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+   0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+   0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+   0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+   0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+   0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+   0x2d02ef8dL
+ };
+ #endif
+ 
+ #if 0
+ /* =========================================================================
+  * This function can be used by asm versions of crc32()
+  */
+ const uint32_t * ZEXPORT get_crc_table()
+ {
+ #ifdef DYNAMIC_CRC_TABLE
+   if (crc_table_empty) make_crc_table();
+ #endif
+   return (const uint32_t *)crc_table;
+ }
+ #endif
+ 
+ /* ========================================================================= */
+ #define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+ #define DO2(buf)  DO1(buf); DO1(buf);
+ #define DO4(buf)  DO2(buf); DO2(buf);
+ #define DO8(buf)  DO4(buf); DO4(buf);
+ 
+ /* ========================================================================= */
+ uint32_t ZEXPORT crc32 (uint32_t crc, const Bytef *buf, uInt len)
+ {
+ #ifdef DYNAMIC_CRC_TABLE
+     if (crc_table_empty)
+       make_crc_table();
+ #endif
+     crc = crc ^ 0xffffffffL;
+     while (len >= 8)
+     {
+       DO8(buf);
+       len -= 8;
+     }
+     if (len) do {
+       DO1(buf);
+     } while (--len);
+     return crc ^ 0xffffffffL;
+ }
+ 
+ #if defined(CONFIG_CMD_JFFS2) || \
+ 	(defined(CONFIG_CMD_NAND) \
+ 	&& !defined(CFG_NAND_LEGACY))
+ 
+ /* No ones complement version. JFFS2 (and other things ?)
+  * don't use ones compliment in their CRC calculations.
+  */
+ uint32_t ZEXPORT crc32_no_comp(uint32_t crc, const Bytef *buf, uInt len)
+ {
+ #ifdef DYNAMIC_CRC_TABLE
+     if (crc_table_empty)
+       make_crc_table();
+ #endif
+     while (len >= 8)
+     {
+       DO8(buf);
+       len -= 8;
+     }
+     if (len) do {
+       DO1(buf);
+     } while (--len);
+ 
+     return crc;
+ }
+ 
+ #endif
+ 
+ /*
+  * Calculate the crc32 checksum triggering the watchdog every 'chunk_sz' bytes
+  * of input.
+  */
+ uint32_t ZEXPORT crc32_wd (uint32_t crc,
+ 			   const unsigned char *buf,
+ 			   uInt len, uInt chunk_sz)
+ {
+ #if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+ 	const unsigned char *end, *curr;
+ 	int chunk;
+ 
+ 	curr = buf;
+ 	end = buf + len;
+ 	while (curr < end) {
+ 		chunk = end - curr;
+ 		if (chunk > chunk_sz)
+ 			chunk = chunk_sz;
+ 		crc = crc32 (crc, curr, chunk);
+ 		curr += chunk;
+ 		WATCHDOG_RESET ();
+ 	}
+ #else
+ 	crc = crc32 (crc, buf, len);
+ #endif
+ 
+ 	return crc;
+ }
diff -crBN u-boot-1.3.4.clean/tools/environment.c u-boot-1.3.4/tools/environment.c
*** u-boot-1.3.4.clean/tools/environment.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/tools/environment.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,208 ----
+ /*
+  * (C) Copyright 2001
+  * Erik Theisen,  Wave 7 Optics, etheisen@mindspring.com.
+  *
+  * See file CREDITS for list of people who contributed to this
+  * project.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  */
+ 
+ #ifndef __ASSEMBLY__
+ #define	__ASSEMBLY__			/* Dirty trick to get only #defines	*/
+ #endif
+ #define	__ASM_STUB_PROCESSOR_H__	/* don't include asm/processor.		*/
+ #include <config.h>
+ #undef	__ASSEMBLY__
+ #include <environment.h>
+ 
+ /*
+  * Handle HOSTS that have prepended
+  * crap on symbol names, not TARGETS.
+  */
+ #if defined(__APPLE__)
+ /* Leading underscore on symbols */
+ #  define SYM_CHAR "_"
+ #else /* No leading character on symbols */
+ #  define SYM_CHAR
+ #endif
+ 
+ /*
+  * Generate embedded environment table
+  * inside U-Boot image, if needed.
+  */
+ #if defined(ENV_IS_EMBEDDED)
+ /*
+  * Only put the environment in it's own section when we are building
+  * U-Boot proper.  The host based program "tools/envcrc" does not need
+  * a seperate section.  Note that ENV_CRC is only defined when building
+  * U-Boot itself.
+  */
+ #if (defined(CFG_USE_PPCENV) || defined(CONFIG_NAND_U_BOOT)) && \
+      defined(ENV_CRC) /* Environment embedded in U-Boot .ppcenv section */
+ /* XXX - This only works with GNU C */
+ #  define __PPCENV__ __attribute__ ((section(".ppcenv")))
+ #  define __PPCTEXT__ __attribute__ ((section(".text")))
+ 
+ #elif defined(USE_HOSTCC) /* Native for 'tools/envcrc' */
+ #  define __PPCENV__ /*XXX DO_NOT_DEL_THIS_COMMENT*/
+ #  define __PPCTEXT__ /*XXX DO_NOT_DEL_THIS_COMMENT*/
+ 
+ #else /* Environment is embedded in U-Boot's .text section */
+ /* XXX - This only works with GNU C */
+ #  define __PPCENV__ __attribute__ ((section(".text")))
+ #  define __PPCTEXT__ __attribute__ ((section(".text")))
+ #endif
+ 
+ /*
+  * Macros to generate global absolutes.
+  */
+ #if defined(__bfin__)
+ # define GEN_SET_VALUE(name, value) asm (".set " GEN_SYMNAME(name) ", " GEN_VALUE(value))
+ #else
+ # define GEN_SET_VALUE(name, value) asm (GEN_SYMNAME(name) " = " GEN_VALUE(value))
+ #endif
+ #define GEN_SYMNAME(str) SYM_CHAR #str
+ #define GEN_VALUE(str) #str
+ #define GEN_ABS(name, value) \
+ 		asm (".globl " GEN_SYMNAME(name)); \
+ 		GEN_SET_VALUE(name, value)
+ 
+ /*
+  * Macros to transform values
+  * into environment strings.
+  */
+ #define XMK_STR(x)	#x
+ #define MK_STR(x)	XMK_STR(x)
+ 
+ /*
+  * Check to see if we are building with a
+  * computed CRC.  Otherwise define it as ~0.
+  */
+ #if !defined(ENV_CRC)
+ #  define ENV_CRC	~0
+ #endif
+ 
+ env_t environment __PPCENV__ = {
+ 	ENV_CRC,	/* CRC Sum */
+ #ifdef CFG_REDUNDAND_ENVIRONMENT
+ 	1,		/* Flags: valid */
+ #endif
+ 	{
+ #if defined(CONFIG_BOOTARGS)
+ 	"bootargs="	CONFIG_BOOTARGS			"\0"
+ #endif
+ #if defined(CONFIG_BOOTCOMMAND)
+ 	"bootcmd="	CONFIG_BOOTCOMMAND		"\0"
+ #endif
+ #if defined(CONFIG_RAMBOOTCOMMAND)
+ 	"ramboot="	CONFIG_RAMBOOTCOMMAND		"\0"
+ #endif
+ #if defined(CONFIG_NFSBOOTCOMMAND)
+ 	"nfsboot="	CONFIG_NFSBOOTCOMMAND		"\0"
+ #endif
+ #if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
+ 	"bootdelay="	MK_STR(CONFIG_BOOTDELAY)	"\0"
+ #endif
+ #if defined(CONFIG_BAUDRATE) && (CONFIG_BAUDRATE >= 0)
+ 	"baudrate="	MK_STR(CONFIG_BAUDRATE)		"\0"
+ #endif
+ #ifdef	CONFIG_LOADS_ECHO
+ 	"loads_echo="	MK_STR(CONFIG_LOADS_ECHO)	"\0"
+ #endif
+ #ifdef	CONFIG_ETHADDR
+ 	"ethaddr="	MK_STR(CONFIG_ETHADDR)		"\0"
+ #endif
+ #ifdef	CONFIG_ETH1ADDR
+ 	"eth1addr="	MK_STR(CONFIG_ETH1ADDR)		"\0"
+ #endif
+ #ifdef	CONFIG_ETH2ADDR
+ 	"eth2addr="	MK_STR(CONFIG_ETH2ADDR)		"\0"
+ #endif
+ #ifdef	CONFIG_ETH3ADDR
+ 	"eth3addr="	MK_STR(CONFIG_ETH3ADDR)		"\0"
+ #endif
+ #ifdef	CONFIG_ETHPRIME
+ 	"ethprime="	CONFIG_ETHPRIME			"\0"
+ #endif
+ #ifdef	CONFIG_IPADDR
+ 	"ipaddr="	MK_STR(CONFIG_IPADDR)		"\0"
+ #endif
+ #ifdef	CONFIG_SERVERIP
+ 	"serverip="	MK_STR(CONFIG_SERVERIP)		"\0"
+ #endif
+ #ifdef	CFG_AUTOLOAD
+ 	"autoload="	CFG_AUTOLOAD			"\0"
+ #endif
+ #ifdef	CONFIG_ROOTPATH
+ 	"rootpath="	MK_STR(CONFIG_ROOTPATH)		"\0"
+ #endif
+ #ifdef	CONFIG_GATEWAYIP
+ 	"gatewayip="	MK_STR(CONFIG_GATEWAYIP)	"\0"
+ #endif
+ #ifdef	CONFIG_NETMASK
+ 	"netmask="	MK_STR(CONFIG_NETMASK)		"\0"
+ #endif
+ #ifdef	CONFIG_HOSTNAME
+ 	"hostname="	MK_STR(CONFIG_HOSTNAME)		"\0"
+ #endif
+ #ifdef	CONFIG_BOOTFILE
+ 	"bootfile="	MK_STR(CONFIG_BOOTFILE)		"\0"
+ #endif
+ #ifdef	CONFIG_LOADADDR
+ 	"loadaddr="	MK_STR(CONFIG_LOADADDR)		"\0"
+ #endif
+ #ifdef	CONFIG_PREBOOT
+ 	"preboot="	CONFIG_PREBOOT			"\0"
+ #endif
+ #ifdef	CONFIG_CLOCKS_IN_MHZ
+ 	"clocks_in_mhz=" "1"				"\0"
+ #endif
+ #if defined(CONFIG_PCI_BOOTDELAY) && (CONFIG_PCI_BOOTDELAY > 0)
+ 	"pcidelay="	MK_STR(CONFIG_PCI_BOOTDELAY)	"\0"
+ #endif
+ #ifdef  CONFIG_EXTRA_ENV_SETTINGS
+ 	CONFIG_EXTRA_ENV_SETTINGS
+ #endif
+ 	"\0"		/* Term. env_t.data with 2 NULs */
+ 	}
+ };
+ #ifdef CFG_ENV_ADDR_REDUND
+ env_t redundand_environment __PPCENV__ = {
+ 	0,		/* CRC Sum: invalid */
+ 	0,		/* Flags:   invalid */
+ 	{
+ 	"\0"
+ 	}
+ };
+ #endif	/* CFG_ENV_ADDR_REDUND */
+ 
+ /*
+  * These will end up in the .text section
+  * if the environment strings are embedded
+  * in the image.  When this is used for
+  * tools/envcrc, they are placed in the
+  * .data/.sdata section.
+  *
+  */
+ unsigned long env_size __PPCTEXT__ = sizeof(env_t);
+ 
+ /*
+  * Add in absolutes.
+  */
+ GEN_ABS(env_offset, CFG_ENV_OFFSET);
+ 
+ #endif /* ENV_IS_EMBEDDED */
diff -crBN u-boot-1.3.4.clean/tools/fdt.c u-boot-1.3.4/tools/fdt.c
*** u-boot-1.3.4.clean/tools/fdt.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/tools/fdt.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,205 ----
+ /*
+  * libfdt - Flat Device Tree manipulation
+  * Copyright (C) 2006 David Gibson, IBM Corporation.
+  *
+  * libfdt is dual licensed: you can use it either under the terms of
+  * the GPL, or the BSD license, at your option.
+  *
+  *  a) This library is free software; you can redistribute it and/or
+  *     modify it under the terms of the GNU General Public License as
+  *     published by the Free Software Foundation; either version 2 of the
+  *     License, or (at your option) any later version.
+  *
+  *     This library is distributed in the hope that it will be useful,
+  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *     GNU General Public License for more details.
+  *
+  *     You should have received a copy of the GNU General Public
+  *     License along with this library; if not, write to the Free
+  *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+  *     MA 02110-1301 USA
+  *
+  * Alternatively,
+  *
+  *  b) Redistribution and use in source and binary forms, with or
+  *     without modification, are permitted provided that the following
+  *     conditions are met:
+  *
+  *     1. Redistributions of source code must retain the above
+  *        copyright notice, this list of conditions and the following
+  *        disclaimer.
+  *     2. Redistributions in binary form must reproduce the above
+  *        copyright notice, this list of conditions and the following
+  *        disclaimer in the documentation and/or other materials
+  *        provided with the distribution.
+  *
+  *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+  *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+  *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+  *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+  *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+  *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+  *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+  *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ #include "libfdt_env.h"
+ 
+ #ifndef USE_HOSTCC
+ #include <fdt.h>
+ #include <libfdt.h>
+ #else
+ #include "fdt_host.h"
+ #endif
+ 
+ #include "libfdt_internal.h"
+ 
+ int fdt_check_header(const void *fdt)
+ {
+ 	if (fdt_magic(fdt) == FDT_MAGIC) {
+ 		/* Complete tree */
+ 		if (fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)
+ 			return -FDT_ERR_BADVERSION;
+ 		if (fdt_last_comp_version(fdt) > FDT_LAST_SUPPORTED_VERSION)
+ 			return -FDT_ERR_BADVERSION;
+ 	} else if (fdt_magic(fdt) == SW_MAGIC) {
+ 		/* Unfinished sequential-write blob */
+ 		if (fdt_size_dt_struct(fdt) == 0)
+ 			return -FDT_ERR_BADSTATE;
+ 	} else {
+ 		return -FDT_ERR_BADMAGIC;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ const void *fdt_offset_ptr(const void *fdt, int offset, int len)
+ {
+ 	const void *p;
+ 
+ 	if (fdt_version(fdt) >= 0x11)
+ 		if (((offset + len) < offset)
+ 		    || ((offset + len) > fdt_size_dt_struct(fdt)))
+ 			return NULL;
+ 
+ 	p = _fdt_offset_ptr(fdt, offset);
+ 
+ 	if (p + len < p)
+ 		return NULL;
+ 	return p;
+ }
+ 
+ uint32_t fdt_next_tag(const void *fdt, int offset, int *nextoffset)
+ {
+ 	const uint32_t *tagp, *lenp;
+ 	uint32_t tag;
+ 	const char *p;
+ 
+ 	if (offset % FDT_TAGSIZE)
+ 		return -1;
+ 
+ 	tagp = fdt_offset_ptr(fdt, offset, FDT_TAGSIZE);
+ 	if (! tagp)
+ 		return FDT_END; /* premature end */
+ 	tag = fdt32_to_cpu(*tagp);
+ 	offset += FDT_TAGSIZE;
+ 
+ 	switch (tag) {
+ 	case FDT_BEGIN_NODE:
+ 		/* skip name */
+ 		do {
+ 			p = fdt_offset_ptr(fdt, offset++, 1);
+ 		} while (p && (*p != '\0'));
+ 		if (! p)
+ 			return FDT_END;
+ 		break;
+ 	case FDT_PROP:
+ 		lenp = fdt_offset_ptr(fdt, offset, sizeof(*lenp));
+ 		if (! lenp)
+ 			return FDT_END;
+ 		/* skip name offset, length and value */
+ 		offset += 2*FDT_TAGSIZE + fdt32_to_cpu(*lenp);
+ 		break;
+ 	}
+ 
+ 	if (nextoffset)
+ 		*nextoffset = ALIGN(offset, FDT_TAGSIZE);
+ 
+ 	return tag;
+ }
+ 
+ int _fdt_check_node_offset(const void *fdt, int offset)
+ {
+ 	if ((offset < 0) || (offset % FDT_TAGSIZE)
+ 	    || (fdt_next_tag(fdt, offset, &offset) != FDT_BEGIN_NODE))
+ 		return -FDT_ERR_BADOFFSET;
+ 
+ 	return offset;
+ }
+ 
+ int fdt_next_node(const void *fdt, int offset, int *depth)
+ {
+ 	int nextoffset = 0;
+ 	uint32_t tag;
+ 
+ 	if (offset >= 0)
+ 		if ((nextoffset = _fdt_check_node_offset(fdt, offset)) < 0)
+ 			return nextoffset;
+ 
+ 	do {
+ 		offset = nextoffset;
+ 		tag = fdt_next_tag(fdt, offset, &nextoffset);
+ 
+ 		switch (tag) {
+ 		case FDT_PROP:
+ 		case FDT_NOP:
+ 			break;
+ 
+ 		case FDT_BEGIN_NODE:
+ 			if (depth)
+ 				(*depth)++;
+ 			break;
+ 
+ 		case FDT_END_NODE:
+ 			if (depth)
+ 				(*depth)--;
+ 			break;
+ 
+ 		case FDT_END:
+ 			return -FDT_ERR_NOTFOUND;
+ 
+ 		default:
+ 			return -FDT_ERR_BADSTRUCTURE;
+ 		}
+ 	} while (tag != FDT_BEGIN_NODE);
+ 
+ 	return offset;
+ }
+ 
+ const char *_fdt_find_string(const char *strtab, int tabsize, const char *s)
+ {
+ 	int len = strlen(s) + 1;
+ 	const char *last = strtab + tabsize - len;
+ 	const char *p;
+ 
+ 	for (p = strtab; p <= last; p++)
+ 		if (memeq(p, s, len))
+ 			return p;
+ 	return NULL;
+ }
+ 
+ int fdt_move(const void *fdt, void *buf, int bufsize)
+ {
+ 	CHECK_HEADER(fdt);
+ 
+ 	if (fdt_totalsize(fdt) > bufsize)
+ 		return -FDT_ERR_NOSPACE;
+ 
+ 	memmove(buf, fdt, fdt_totalsize(fdt));
+ 	return 0;
+ }
diff -crBN u-boot-1.3.4.clean/tools/fdt_ro.c u-boot-1.3.4/tools/fdt_ro.c
*** u-boot-1.3.4.clean/tools/fdt_ro.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/tools/fdt_ro.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,470 ----
+ /*
+  * libfdt - Flat Device Tree manipulation
+  * Copyright (C) 2006 David Gibson, IBM Corporation.
+  *
+  * libfdt is dual licensed: you can use it either under the terms of
+  * the GPL, or the BSD license, at your option.
+  *
+  *  a) This library is free software; you can redistribute it and/or
+  *     modify it under the terms of the GNU General Public License as
+  *     published by the Free Software Foundation; either version 2 of the
+  *     License, or (at your option) any later version.
+  *
+  *     This library is distributed in the hope that it will be useful,
+  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *     GNU General Public License for more details.
+  *
+  *     You should have received a copy of the GNU General Public
+  *     License along with this library; if not, write to the Free
+  *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+  *     MA 02110-1301 USA
+  *
+  * Alternatively,
+  *
+  *  b) Redistribution and use in source and binary forms, with or
+  *     without modification, are permitted provided that the following
+  *     conditions are met:
+  *
+  *     1. Redistributions of source code must retain the above
+  *        copyright notice, this list of conditions and the following
+  *        disclaimer.
+  *     2. Redistributions in binary form must reproduce the above
+  *        copyright notice, this list of conditions and the following
+  *        disclaimer in the documentation and/or other materials
+  *        provided with the distribution.
+  *
+  *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+  *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+  *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+  *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+  *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+  *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+  *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+  *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ #include "libfdt_env.h"
+ 
+ #ifndef USE_HOSTCC
+ #include <fdt.h>
+ #include <libfdt.h>
+ #else
+ #include "fdt_host.h"
+ #endif
+ 
+ #include "libfdt_internal.h"
+ 
+ static int nodename_eq(const void *fdt, int offset,
+ 		       const char *s, int len)
+ {
+ 	const char *p = fdt_offset_ptr(fdt, offset + FDT_TAGSIZE, len+1);
+ 
+ 	if (! p)
+ 		/* short match */
+ 		return 0;
+ 
+ 	if (memcmp(p, s, len) != 0)
+ 		return 0;
+ 
+ 	if (p[len] == '\0')
+ 		return 1;
+ 	else if (!memchr(s, '@', len) && (p[len] == '@'))
+ 		return 1;
+ 	else
+ 		return 0;
+ }
+ 
+ const char *fdt_string(const void *fdt, int stroffset)
+ {
+ 	return (char *)fdt + fdt_off_dt_strings(fdt) + stroffset;
+ }
+ 
+ int fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size)
+ {
+ 	CHECK_HEADER(fdt);
+ 	*address = fdt64_to_cpu(_fdt_mem_rsv(fdt, n)->address);
+ 	*size = fdt64_to_cpu(_fdt_mem_rsv(fdt, n)->size);
+ 	return 0;
+ }
+ 
+ int fdt_num_mem_rsv(const void *fdt)
+ {
+ 	int i = 0;
+ 
+ 	while (fdt64_to_cpu(_fdt_mem_rsv(fdt, i)->size) != 0)
+ 		i++;
+ 	return i;
+ }
+ 
+ int fdt_subnode_offset_namelen(const void *fdt, int offset,
+ 			       const char *name, int namelen)
+ {
+ 	int depth;
+ 
+ 	CHECK_HEADER(fdt);
+ 
+ 	for (depth = 0;
+ 	     offset >= 0;
+ 	     offset = fdt_next_node(fdt, offset, &depth)) {
+ 		if (depth < 0)
+ 			return -FDT_ERR_NOTFOUND;
+ 		else if ((depth == 1)
+ 			 && nodename_eq(fdt, offset, name, namelen))
+ 			return offset;
+ 	}
+ 
+ 	return offset; /* error */
+ }
+ 
+ int fdt_subnode_offset(const void *fdt, int parentoffset,
+ 		       const char *name)
+ {
+ 	return fdt_subnode_offset_namelen(fdt, parentoffset, name, strlen(name));
+ }
+ 
+ int fdt_path_offset(const void *fdt, const char *path)
+ {
+ 	const char *end = path + strlen(path);
+ 	const char *p = path;
+ 	int offset = 0;
+ 
+ 	CHECK_HEADER(fdt);
+ 
+ 	if (*path != '/')
+ 		return -FDT_ERR_BADPATH;
+ 
+ 	while (*p) {
+ 		const char *q;
+ 
+ 		while (*p == '/')
+ 			p++;
+ 		if (! *p)
+ 			return offset;
+ 		q = strchr(p, '/');
+ 		if (! q)
+ 			q = end;
+ 
+ 		offset = fdt_subnode_offset_namelen(fdt, offset, p, q-p);
+ 		if (offset < 0)
+ 			return offset;
+ 
+ 		p = q;
+ 	}
+ 
+ 	return offset;
+ }
+ 
+ const char *fdt_get_name(const void *fdt, int nodeoffset, int *len)
+ {
+ 	const struct fdt_node_header *nh = _fdt_offset_ptr(fdt, nodeoffset);
+ 	int err;
+ 
+ 	if (((err = fdt_check_header(fdt)) != 0)
+ 	    || ((err = _fdt_check_node_offset(fdt, nodeoffset)) < 0))
+ 			goto fail;
+ 
+ 	if (len)
+ 		*len = strlen(nh->name);
+ 
+ 	return nh->name;
+ 
+  fail:
+ 	if (len)
+ 		*len = err;
+ 	return NULL;
+ }
+ 
+ const struct fdt_property *fdt_get_property(const void *fdt,
+ 					    int nodeoffset,
+ 					    const char *name, int *lenp)
+ {
+ 	uint32_t tag;
+ 	const struct fdt_property *prop;
+ 	int namestroff;
+ 	int offset, nextoffset;
+ 	int err;
+ 
+ 	if (((err = fdt_check_header(fdt)) != 0)
+ 	    || ((err = _fdt_check_node_offset(fdt, nodeoffset)) < 0))
+ 			goto fail;
+ 
+ 	nextoffset = err;
+ 	do {
+ 		offset = nextoffset;
+ 
+ 		tag = fdt_next_tag(fdt, offset, &nextoffset);
+ 		switch (tag) {
+ 		case FDT_END:
+ 			err = -FDT_ERR_TRUNCATED;
+ 			goto fail;
+ 
+ 		case FDT_BEGIN_NODE:
+ 		case FDT_END_NODE:
+ 		case FDT_NOP:
+ 			break;
+ 
+ 		case FDT_PROP:
+ 			err = -FDT_ERR_BADSTRUCTURE;
+ 			prop = fdt_offset_ptr(fdt, offset, sizeof(*prop));
+ 			if (! prop)
+ 				goto fail;
+ 			namestroff = fdt32_to_cpu(prop->nameoff);
+ 			if (streq(fdt_string(fdt, namestroff), name)) {
+ 				/* Found it! */
+ 				int len = fdt32_to_cpu(prop->len);
+ 				prop = fdt_offset_ptr(fdt, offset,
+ 						      sizeof(*prop)+len);
+ 				if (! prop)
+ 					goto fail;
+ 
+ 				if (lenp)
+ 					*lenp = len;
+ 
+ 				return prop;
+ 			}
+ 			break;
+ 
+ 		default:
+ 			err = -FDT_ERR_BADSTRUCTURE;
+ 			goto fail;
+ 		}
+ 	} while ((tag != FDT_BEGIN_NODE) && (tag != FDT_END_NODE));
+ 
+ 	err = -FDT_ERR_NOTFOUND;
+  fail:
+ 	if (lenp)
+ 		*lenp = err;
+ 	return NULL;
+ }
+ 
+ const void *fdt_getprop(const void *fdt, int nodeoffset,
+ 		  const char *name, int *lenp)
+ {
+ 	const struct fdt_property *prop;
+ 
+ 	prop = fdt_get_property(fdt, nodeoffset, name, lenp);
+ 	if (! prop)
+ 		return NULL;
+ 
+ 	return prop->data;
+ }
+ 
+ uint32_t fdt_get_phandle(const void *fdt, int nodeoffset)
+ {
+ 	const uint32_t *php;
+ 	int len;
+ 
+ 	php = fdt_getprop(fdt, nodeoffset, "linux,phandle", &len);
+ 	if (!php || (len != sizeof(*php)))
+ 		return 0;
+ 
+ 	return fdt32_to_cpu(*php);
+ }
+ 
+ int fdt_get_path(const void *fdt, int nodeoffset, char *buf, int buflen)
+ {
+ 	int pdepth = 0, p = 0;
+ 	int offset, depth, namelen;
+ 	const char *name;
+ 
+ 	CHECK_HEADER(fdt);
+ 
+ 	if (buflen < 2)
+ 		return -FDT_ERR_NOSPACE;
+ 
+ 	for (offset = 0, depth = 0;
+ 	     (offset >= 0) && (offset <= nodeoffset);
+ 	     offset = fdt_next_node(fdt, offset, &depth)) {
+ 		if (pdepth < depth)
+ 			continue; /* overflowed buffer */
+ 
+ 		while (pdepth > depth) {
+ 			do {
+ 				p--;
+ 			} while (buf[p-1] != '/');
+ 			pdepth--;
+ 		}
+ 
+ 		name = fdt_get_name(fdt, offset, &namelen);
+ 		if (!name)
+ 			return namelen;
+ 		if ((p + namelen + 1) <= buflen) {
+ 			memcpy(buf + p, name, namelen);
+ 			p += namelen;
+ 			buf[p++] = '/';
+ 			pdepth++;
+ 		}
+ 
+ 		if (offset == nodeoffset) {
+ 			if (pdepth < (depth + 1))
+ 				return -FDT_ERR_NOSPACE;
+ 
+ 			if (p > 1) /* special case so that root path is "/", not "" */
+ 				p--;
+ 			buf[p] = '\0';
+ 			return p;
+ 		}
+ 	}
+ 
+ 	if ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))
+ 		return -FDT_ERR_BADOFFSET;
+ 	else if (offset == -FDT_ERR_BADOFFSET)
+ 		return -FDT_ERR_BADSTRUCTURE;
+ 
+ 	return offset; /* error from fdt_next_node() */
+ }
+ 
+ int fdt_supernode_atdepth_offset(const void *fdt, int nodeoffset,
+ 				 int supernodedepth, int *nodedepth)
+ {
+ 	int offset, depth;
+ 	int supernodeoffset = -FDT_ERR_INTERNAL;
+ 
+ 	CHECK_HEADER(fdt);
+ 
+ 	if (supernodedepth < 0)
+ 		return -FDT_ERR_NOTFOUND;
+ 
+ 	for (offset = 0, depth = 0;
+ 	     (offset >= 0) && (offset <= nodeoffset);
+ 	     offset = fdt_next_node(fdt, offset, &depth)) {
+ 		if (depth == supernodedepth)
+ 			supernodeoffset = offset;
+ 
+ 		if (offset == nodeoffset) {
+ 			if (nodedepth)
+ 				*nodedepth = depth;
+ 
+ 			if (supernodedepth > depth)
+ 				return -FDT_ERR_NOTFOUND;
+ 			else
+ 				return supernodeoffset;
+ 		}
+ 	}
+ 
+ 	if ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))
+ 		return -FDT_ERR_BADOFFSET;
+ 	else if (offset == -FDT_ERR_BADOFFSET)
+ 		return -FDT_ERR_BADSTRUCTURE;
+ 
+ 	return offset; /* error from fdt_next_node() */
+ }
+ 
+ int fdt_node_depth(const void *fdt, int nodeoffset)
+ {
+ 	int nodedepth;
+ 	int err;
+ 
+ 	err = fdt_supernode_atdepth_offset(fdt, nodeoffset, 0, &nodedepth);
+ 	if (err)
+ 		return (err < 0) ? err : -FDT_ERR_INTERNAL;
+ 	return nodedepth;
+ }
+ 
+ int fdt_parent_offset(const void *fdt, int nodeoffset)
+ {
+ 	int nodedepth = fdt_node_depth(fdt, nodeoffset);
+ 
+ 	if (nodedepth < 0)
+ 		return nodedepth;
+ 	return fdt_supernode_atdepth_offset(fdt, nodeoffset,
+ 					    nodedepth - 1, NULL);
+ }
+ 
+ int fdt_node_offset_by_prop_value(const void *fdt, int startoffset,
+ 				  const char *propname,
+ 				  const void *propval, int proplen)
+ {
+ 	int offset;
+ 	const void *val;
+ 	int len;
+ 
+ 	CHECK_HEADER(fdt);
+ 
+ 	/* FIXME: The algorithm here is pretty horrible: we scan each
+ 	 * property of a node in fdt_getprop(), then if that didn't
+ 	 * find what we want, we scan over them again making our way
+ 	 * to the next node.  Still it's the easiest to implement
+ 	 * approach; performance can come later. */
+ 	for (offset = fdt_next_node(fdt, startoffset, NULL);
+ 	     offset >= 0;
+ 	     offset = fdt_next_node(fdt, offset, NULL)) {
+ 		val = fdt_getprop(fdt, offset, propname, &len);
+ 		if (val && (len == proplen)
+ 		    && (memcmp(val, propval, len) == 0))
+ 			return offset;
+ 	}
+ 
+ 	return offset; /* error from fdt_next_node() */
+ }
+ 
+ int fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle)
+ {
+ 	if ((phandle == 0) || (phandle == -1))
+ 		return -FDT_ERR_BADPHANDLE;
+ 	phandle = cpu_to_fdt32(phandle);
+ 	return fdt_node_offset_by_prop_value(fdt, -1, "linux,phandle",
+ 					     &phandle, sizeof(phandle));
+ }
+ 
+ int _stringlist_contains(const void *strlist, int listlen, const char *str)
+ {
+ 	int len = strlen(str);
+ 	const void *p;
+ 
+ 	while (listlen >= len) {
+ 		if (memcmp(str, strlist, len+1) == 0)
+ 			return 1;
+ 		p = memchr(strlist, '\0', listlen);
+ 		if (!p)
+ 			return 0; /* malformed strlist.. */
+ 		listlen -= (p-strlist) + 1;
+ 		strlist = p + 1;
+ 	}
+ 	return 0;
+ }
+ 
+ int fdt_node_check_compatible(const void *fdt, int nodeoffset,
+ 			      const char *compatible)
+ {
+ 	const void *prop;
+ 	int len;
+ 
+ 	prop = fdt_getprop(fdt, nodeoffset, "compatible", &len);
+ 	if (!prop)
+ 		return len;
+ 	if (_stringlist_contains(prop, len, compatible))
+ 		return 0;
+ 	else
+ 		return 1;
+ }
+ 
+ int fdt_node_offset_by_compatible(const void *fdt, int startoffset,
+ 				  const char *compatible)
+ {
+ 	int offset, err;
+ 
+ 	CHECK_HEADER(fdt);
+ 
+ 	/* FIXME: The algorithm here is pretty horrible: we scan each
+ 	 * property of a node in fdt_node_check_compatible(), then if
+ 	 * that didn't find what we want, we scan over them again
+ 	 * making our way to the next node.  Still it's the easiest to
+ 	 * implement approach; performance can come later. */
+ 	for (offset = fdt_next_node(fdt, startoffset, NULL);
+ 	     offset >= 0;
+ 	     offset = fdt_next_node(fdt, offset, NULL)) {
+ 		err = fdt_node_check_compatible(fdt, offset, compatible);
+ 		if ((err < 0) && (err != -FDT_ERR_NOTFOUND))
+ 			return err;
+ 		else if (err == 0)
+ 			return offset;
+ 	}
+ 
+ 	return offset; /* error from fdt_next_node() */
+ }
diff -crBN u-boot-1.3.4.clean/tools/fdt_rw.c u-boot-1.3.4/tools/fdt_rw.c
*** u-boot-1.3.4.clean/tools/fdt_rw.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/tools/fdt_rw.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,463 ----
+ /*
+  * libfdt - Flat Device Tree manipulation
+  * Copyright (C) 2006 David Gibson, IBM Corporation.
+  *
+  * libfdt is dual licensed: you can use it either under the terms of
+  * the GPL, or the BSD license, at your option.
+  *
+  *  a) This library is free software; you can redistribute it and/or
+  *     modify it under the terms of the GNU General Public License as
+  *     published by the Free Software Foundation; either version 2 of the
+  *     License, or (at your option) any later version.
+  *
+  *     This library is distributed in the hope that it will be useful,
+  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *     GNU General Public License for more details.
+  *
+  *     You should have received a copy of the GNU General Public
+  *     License along with this library; if not, write to the Free
+  *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+  *     MA 02110-1301 USA
+  *
+  * Alternatively,
+  *
+  *  b) Redistribution and use in source and binary forms, with or
+  *     without modification, are permitted provided that the following
+  *     conditions are met:
+  *
+  *     1. Redistributions of source code must retain the above
+  *        copyright notice, this list of conditions and the following
+  *        disclaimer.
+  *     2. Redistributions in binary form must reproduce the above
+  *        copyright notice, this list of conditions and the following
+  *        disclaimer in the documentation and/or other materials
+  *        provided with the distribution.
+  *
+  *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+  *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+  *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+  *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+  *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+  *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+  *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+  *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ #include "libfdt_env.h"
+ 
+ #ifndef USE_HOSTCC
+ #include <fdt.h>
+ #include <libfdt.h>
+ #else
+ #include "fdt_host.h"
+ #endif
+ 
+ #include "libfdt_internal.h"
+ 
+ static int _blocks_misordered(const void *fdt,
+ 			      int mem_rsv_size, int struct_size)
+ {
+ 	return (fdt_off_mem_rsvmap(fdt) < ALIGN(sizeof(struct fdt_header), 8))
+ 		|| (fdt_off_dt_struct(fdt) <
+ 		    (fdt_off_mem_rsvmap(fdt) + mem_rsv_size))
+ 		|| (fdt_off_dt_strings(fdt) <
+ 		    (fdt_off_dt_struct(fdt) + struct_size))
+ 		|| (fdt_totalsize(fdt) <
+ 		    (fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt)));
+ }
+ 
+ static int rw_check_header(void *fdt)
+ {
+ 	CHECK_HEADER(fdt);
+ 
+ 	if (fdt_version(fdt) < 17)
+ 		return -FDT_ERR_BADVERSION;
+ 	if (_blocks_misordered(fdt, sizeof(struct fdt_reserve_entry),
+ 			       fdt_size_dt_struct(fdt)))
+ 		return -FDT_ERR_BADLAYOUT;
+ 	if (fdt_version(fdt) > 17)
+ 		fdt_set_version(fdt, 17);
+ 
+ 	return 0;
+ }
+ 
+ #define RW_CHECK_HEADER(fdt) \
+ 	{ \
+ 		int err; \
+ 		if ((err = rw_check_header(fdt)) != 0) \
+ 			return err; \
+ 	}
+ 
+ static inline int _blob_data_size(void *fdt)
+ {
+ 	return fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
+ }
+ 
+ static int _blob_splice(void *fdt, void *p, int oldlen, int newlen)
+ {
+ 	void *end = fdt + _blob_data_size(fdt);
+ 
+ 	if (((p + oldlen) < p) || ((p + oldlen) > end))
+ 		return -FDT_ERR_BADOFFSET;
+ 	if ((end - oldlen + newlen) > (fdt + fdt_totalsize(fdt)))
+ 		return -FDT_ERR_NOSPACE;
+ 	memmove(p + newlen, p + oldlen, end - p - oldlen);
+ 	return 0;
+ }
+ 
+ static int _blob_splice_mem_rsv(void *fdt, struct fdt_reserve_entry *p,
+ 				int oldn, int newn)
+ {
+ 	int delta = (newn - oldn) * sizeof(*p);
+ 	int err;
+ 	err = _blob_splice(fdt, p, oldn * sizeof(*p), newn * sizeof(*p));
+ 	if (err)
+ 		return err;
+ 	fdt_set_off_dt_struct(fdt, fdt_off_dt_struct(fdt) + delta);
+ 	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
+ 	return 0;
+ }
+ 
+ static int _blob_splice_struct(void *fdt, void *p,
+ 			       int oldlen, int newlen)
+ {
+ 	int delta = newlen - oldlen;
+ 	int err;
+ 
+ 	if ((err = _blob_splice(fdt, p, oldlen, newlen)))
+ 		return err;
+ 
+ 	fdt_set_size_dt_struct(fdt, fdt_size_dt_struct(fdt) + delta);
+ 	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
+ 	return 0;
+ }
+ 
+ static int _blob_splice_string(void *fdt, int newlen)
+ {
+ 	void *p = fdt + fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
+ 	int err;
+ 
+ 	if ((err = _blob_splice(fdt, p, 0, newlen)))
+ 		return err;
+ 
+ 	fdt_set_size_dt_strings(fdt, fdt_size_dt_strings(fdt) + newlen);
+ 	return 0;
+ }
+ 
+ static int _find_add_string(void *fdt, const char *s)
+ {
+ 	char *strtab = (char *)fdt + fdt_off_dt_strings(fdt);
+ 	const char *p;
+ 	char *new;
+ 	int len = strlen(s) + 1;
+ 	int err;
+ 
+ 	p = _fdt_find_string(strtab, fdt_size_dt_strings(fdt), s);
+ 	if (p)
+ 		/* found it */
+ 		return (p - strtab);
+ 
+ 	new = strtab + fdt_size_dt_strings(fdt);
+ 	err = _blob_splice_string(fdt, len);
+ 	if (err)
+ 		return err;
+ 
+ 	memcpy(new, s, len);
+ 	return (new - strtab);
+ }
+ 
+ int fdt_add_mem_rsv(void *fdt, uint64_t address, uint64_t size)
+ {
+ 	struct fdt_reserve_entry *re;
+ 	int err;
+ 
+ 	RW_CHECK_HEADER(fdt);
+ 
+ 	re = _fdt_mem_rsv_w(fdt, fdt_num_mem_rsv(fdt));
+ 	err = _blob_splice_mem_rsv(fdt, re, 0, 1);
+ 	if (err)
+ 		return err;
+ 
+ 	re->address = cpu_to_fdt64(address);
+ 	re->size = cpu_to_fdt64(size);
+ 	return 0;
+ }
+ 
+ int fdt_del_mem_rsv(void *fdt, int n)
+ {
+ 	struct fdt_reserve_entry *re = _fdt_mem_rsv_w(fdt, n);
+ 	int err;
+ 
+ 	RW_CHECK_HEADER(fdt);
+ 
+ 	if (n >= fdt_num_mem_rsv(fdt))
+ 		return -FDT_ERR_NOTFOUND;
+ 
+ 	err = _blob_splice_mem_rsv(fdt, re, 1, 0);
+ 	if (err)
+ 		return err;
+ 	return 0;
+ }
+ 
+ static int _resize_property(void *fdt, int nodeoffset, const char *name, int len,
+ 			    struct fdt_property **prop)
+ {
+ 	int oldlen;
+ 	int err;
+ 
+ 	*prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);
+ 	if (! (*prop))
+ 		return oldlen;
+ 
+ 	if ((err = _blob_splice_struct(fdt, (*prop)->data,
+ 				       ALIGN(oldlen, FDT_TAGSIZE),
+ 				       ALIGN(len, FDT_TAGSIZE))))
+ 		return err;
+ 
+ 	(*prop)->len = cpu_to_fdt32(len);
+ 	return 0;
+ }
+ 
+ static int _add_property(void *fdt, int nodeoffset, const char *name, int len,
+ 			 struct fdt_property **prop)
+ {
+ 	int proplen;
+ 	int nextoffset;
+ 	int namestroff;
+ 	int err;
+ 
+ 	if ((nextoffset = _fdt_check_node_offset(fdt, nodeoffset)) < 0)
+ 		return nextoffset;
+ 
+ 	namestroff = _find_add_string(fdt, name);
+ 	if (namestroff < 0)
+ 		return namestroff;
+ 
+ 	*prop = _fdt_offset_ptr_w(fdt, nextoffset);
+ 	proplen = sizeof(**prop) + ALIGN(len, FDT_TAGSIZE);
+ 
+ 	err = _blob_splice_struct(fdt, *prop, 0, proplen);
+ 	if (err)
+ 		return err;
+ 
+ 	(*prop)->tag = cpu_to_fdt32(FDT_PROP);
+ 	(*prop)->nameoff = cpu_to_fdt32(namestroff);
+ 	(*prop)->len = cpu_to_fdt32(len);
+ 	return 0;
+ }
+ 
+ int fdt_set_name(void *fdt, int nodeoffset, const char *name)
+ {
+ 	char *namep;
+ 	int oldlen, newlen;
+ 	int err;
+ 
+ 	RW_CHECK_HEADER(fdt);
+ 
+ 	namep = (char *)fdt_get_name(fdt, nodeoffset, &oldlen);
+ 	if (!namep)
+ 		return oldlen;
+ 
+ 	newlen = strlen(name);
+ 
+ 	err = _blob_splice_struct(fdt, namep, ALIGN(oldlen+1, FDT_TAGSIZE),
+ 				  ALIGN(newlen+1, FDT_TAGSIZE));
+ 	if (err)
+ 		return err;
+ 
+ 	memcpy(namep, name, newlen+1);
+ 	return 0;
+ }
+ 
+ int fdt_setprop(void *fdt, int nodeoffset, const char *name,
+ 		const void *val, int len)
+ {
+ 	struct fdt_property *prop;
+ 	int err;
+ 
+ 	RW_CHECK_HEADER(fdt);
+ 
+ 	err = _resize_property(fdt, nodeoffset, name, len, &prop);
+ 	if (err == -FDT_ERR_NOTFOUND)
+ 		err = _add_property(fdt, nodeoffset, name, len, &prop);
+ 	if (err)
+ 		return err;
+ 
+ 	memcpy(prop->data, val, len);
+ 	return 0;
+ }
+ 
+ int fdt_delprop(void *fdt, int nodeoffset, const char *name)
+ {
+ 	struct fdt_property *prop;
+ 	int len, proplen;
+ 
+ 	RW_CHECK_HEADER(fdt);
+ 
+ 	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
+ 	if (! prop)
+ 		return len;
+ 
+ 	proplen = sizeof(*prop) + ALIGN(len, FDT_TAGSIZE);
+ 	return _blob_splice_struct(fdt, prop, proplen, 0);
+ }
+ 
+ int fdt_add_subnode_namelen(void *fdt, int parentoffset,
+ 			    const char *name, int namelen)
+ {
+ 	struct fdt_node_header *nh;
+ 	int offset, nextoffset;
+ 	int nodelen;
+ 	int err;
+ 	uint32_t tag;
+ 	uint32_t *endtag;
+ 
+ 	RW_CHECK_HEADER(fdt);
+ 
+ 	offset = fdt_subnode_offset_namelen(fdt, parentoffset, name, namelen);
+ 	if (offset >= 0)
+ 		return -FDT_ERR_EXISTS;
+ 	else if (offset != -FDT_ERR_NOTFOUND)
+ 		return offset;
+ 
+ 	/* Try to place the new node after the parent's properties */
+ 	fdt_next_tag(fdt, parentoffset, &nextoffset); /* skip the BEGIN_NODE */
+ 	do {
+ 		offset = nextoffset;
+ 		tag = fdt_next_tag(fdt, offset, &nextoffset);
+ 	} while ((tag == FDT_PROP) || (tag == FDT_NOP));
+ 
+ 	nh = _fdt_offset_ptr_w(fdt, offset);
+ 	nodelen = sizeof(*nh) + ALIGN(namelen+1, FDT_TAGSIZE) + FDT_TAGSIZE;
+ 
+ 	err = _blob_splice_struct(fdt, nh, 0, nodelen);
+ 	if (err)
+ 		return err;
+ 
+ 	nh->tag = cpu_to_fdt32(FDT_BEGIN_NODE);
+ 	memset(nh->name, 0, ALIGN(namelen+1, FDT_TAGSIZE));
+ 	memcpy(nh->name, name, namelen);
+ 	endtag = (uint32_t *)((void *)nh + nodelen - FDT_TAGSIZE);
+ 	*endtag = cpu_to_fdt32(FDT_END_NODE);
+ 
+ 	return offset;
+ }
+ 
+ int fdt_add_subnode(void *fdt, int parentoffset, const char *name)
+ {
+ 	return fdt_add_subnode_namelen(fdt, parentoffset, name, strlen(name));
+ }
+ 
+ int fdt_del_node(void *fdt, int nodeoffset)
+ {
+ 	int endoffset;
+ 
+ 	RW_CHECK_HEADER(fdt);
+ 
+ 	endoffset = _fdt_node_end_offset(fdt, nodeoffset);
+ 	if (endoffset < 0)
+ 		return endoffset;
+ 
+ 	return _blob_splice_struct(fdt, _fdt_offset_ptr_w(fdt, nodeoffset),
+ 				   endoffset - nodeoffset, 0);
+ }
+ 
+ static void _packblocks(const void *fdt, void *buf,
+ 		       int mem_rsv_size, int struct_size)
+ {
+ 	int mem_rsv_off, struct_off, strings_off;
+ 
+ 	mem_rsv_off = ALIGN(sizeof(struct fdt_header), 8);
+ 	struct_off = mem_rsv_off + mem_rsv_size;
+ 	strings_off = struct_off + struct_size;
+ 
+ 	memmove(buf + mem_rsv_off, fdt + fdt_off_mem_rsvmap(fdt), mem_rsv_size);
+ 	fdt_set_off_mem_rsvmap(buf, mem_rsv_off);
+ 
+ 	memmove(buf + struct_off, fdt + fdt_off_dt_struct(fdt), struct_size);
+ 	fdt_set_off_dt_struct(buf, struct_off);
+ 	fdt_set_size_dt_struct(buf, struct_size);
+ 
+ 	memmove(buf + strings_off, fdt + fdt_off_dt_strings(fdt),
+ 		fdt_size_dt_strings(fdt));
+ 	fdt_set_off_dt_strings(buf, strings_off);
+ 	fdt_set_size_dt_strings(buf, fdt_size_dt_strings(fdt));
+ }
+ 
+ int fdt_open_into(const void *fdt, void *buf, int bufsize)
+ {
+ 	int err;
+ 	int mem_rsv_size, struct_size;
+ 	int newsize;
+ 	void *tmp;
+ 
+ 	CHECK_HEADER(fdt);
+ 
+ 	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
+ 		* sizeof(struct fdt_reserve_entry);
+ 
+ 	if (fdt_version(fdt) >= 17) {
+ 		struct_size = fdt_size_dt_struct(fdt);
+ 	} else {
+ 		struct_size = 0;
+ 		while (fdt_next_tag(fdt, struct_size, &struct_size) != FDT_END)
+ 			;
+ 	}
+ 
+ 	if (!_blocks_misordered(fdt, mem_rsv_size, struct_size)) {
+ 		/* no further work necessary */
+ 		err = fdt_move(fdt, buf, bufsize);
+ 		if (err)
+ 			return err;
+ 		fdt_set_version(buf, 17);
+ 		fdt_set_size_dt_struct(buf, struct_size);
+ 		fdt_set_totalsize(buf, bufsize);
+ 		return 0;
+ 	}
+ 
+ 	/* Need to reorder */
+ 	newsize = ALIGN(sizeof(struct fdt_header), 8) + mem_rsv_size
+ 		+ struct_size + fdt_size_dt_strings(fdt);
+ 
+ 	if (bufsize < newsize)
+ 		return -FDT_ERR_NOSPACE;
+ 
+ 	if (((buf + newsize) <= fdt)
+ 	    || (buf >= (fdt + fdt_totalsize(fdt)))) {
+ 		tmp = buf;
+ 	} else {
+ 		tmp = (void *)fdt + fdt_totalsize(fdt);
+ 		if ((tmp + newsize) > (buf + bufsize))
+ 			return -FDT_ERR_NOSPACE;
+ 	}
+ 
+ 	_packblocks(fdt, tmp, mem_rsv_size, struct_size);
+ 	memmove(buf, tmp, newsize);
+ 
+ 	fdt_set_magic(buf, FDT_MAGIC);
+ 	fdt_set_totalsize(buf, bufsize);
+ 	fdt_set_version(buf, 17);
+ 	fdt_set_last_comp_version(buf, 16);
+ 	fdt_set_boot_cpuid_phys(buf, fdt_boot_cpuid_phys(fdt));
+ 
+ 	return 0;
+ }
+ 
+ int fdt_pack(void *fdt)
+ {
+ 	int mem_rsv_size;
+ 
+ 	RW_CHECK_HEADER(fdt);
+ 
+ 	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
+ 		* sizeof(struct fdt_reserve_entry);
+ 	_packblocks(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt));
+ 	fdt_set_totalsize(fdt, _blob_data_size(fdt));
+ 
+ 	return 0;
+ }
diff -crBN u-boot-1.3.4.clean/tools/fdt_strerror.c u-boot-1.3.4/tools/fdt_strerror.c
*** u-boot-1.3.4.clean/tools/fdt_strerror.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/tools/fdt_strerror.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,100 ----
+ /*
+  * libfdt - Flat Device Tree manipulation
+  * Copyright (C) 2006 David Gibson, IBM Corporation.
+  *
+  * libfdt is dual licensed: you can use it either under the terms of
+  * the GPL, or the BSD license, at your option.
+  *
+  *  a) This library is free software; you can redistribute it and/or
+  *     modify it under the terms of the GNU General Public License as
+  *     published by the Free Software Foundation; either version 2 of the
+  *     License, or (at your option) any later version.
+  *
+  *     This library is distributed in the hope that it will be useful,
+  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *     GNU General Public License for more details.
+  *
+  *     You should have received a copy of the GNU General Public
+  *     License along with this library; if not, write to the Free
+  *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+  *     MA 02110-1301 USA
+  *
+  * Alternatively,
+  *
+  *  b) Redistribution and use in source and binary forms, with or
+  *     without modification, are permitted provided that the following
+  *     conditions are met:
+  *
+  *     1. Redistributions of source code must retain the above
+  *        copyright notice, this list of conditions and the following
+  *        disclaimer.
+  *     2. Redistributions in binary form must reproduce the above
+  *        copyright notice, this list of conditions and the following
+  *        disclaimer in the documentation and/or other materials
+  *        provided with the distribution.
+  *
+  *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+  *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+  *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+  *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+  *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+  *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+  *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+  *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ #include "libfdt_env.h"
+ 
+ #ifndef USE_HOSTCC
+ #include <fdt.h>
+ #include <libfdt.h>
+ #else
+ #include "fdt_host.h"
+ #endif
+ 
+ #include "libfdt_internal.h"
+ 
+ struct errtabent {
+ 	const char *str;
+ };
+ 
+ #define ERRTABENT(val) \
+ 	[(val)] = { .str = #val, }
+ 
+ static struct errtabent errtable[] = {
+ 	ERRTABENT(FDT_ERR_NOTFOUND),
+ 	ERRTABENT(FDT_ERR_EXISTS),
+ 	ERRTABENT(FDT_ERR_NOSPACE),
+ 
+ 	ERRTABENT(FDT_ERR_BADOFFSET),
+ 	ERRTABENT(FDT_ERR_BADPATH),
+ 	ERRTABENT(FDT_ERR_BADSTATE),
+ 
+ 	ERRTABENT(FDT_ERR_TRUNCATED),
+ 	ERRTABENT(FDT_ERR_BADMAGIC),
+ 	ERRTABENT(FDT_ERR_BADVERSION),
+ 	ERRTABENT(FDT_ERR_BADSTRUCTURE),
+ 	ERRTABENT(FDT_ERR_BADLAYOUT),
+ };
+ #define ERRTABSIZE	(sizeof(errtable) / sizeof(errtable[0]))
+ 
+ const char *fdt_strerror(int errval)
+ {
+ 	if (errval > 0)
+ 		return "<valid offset/length>";
+ 	else if (errval == 0)
+ 		return "<no error>";
+ 	else if (errval > -ERRTABSIZE) {
+ 		const char *s = errtable[-errval].str;
+ 
+ 		if (s)
+ 			return s;
+ 	}
+ 
+ 	return "<unknown error>";
+ }
diff -crBN u-boot-1.3.4.clean/tools/fdt_wip.c u-boot-1.3.4/tools/fdt_wip.c
*** u-boot-1.3.4.clean/tools/fdt_wip.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/tools/fdt_wip.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,148 ----
+ /*
+  * libfdt - Flat Device Tree manipulation
+  * Copyright (C) 2006 David Gibson, IBM Corporation.
+  *
+  * libfdt is dual licensed: you can use it either under the terms of
+  * the GPL, or the BSD license, at your option.
+  *
+  *  a) This library is free software; you can redistribute it and/or
+  *     modify it under the terms of the GNU General Public License as
+  *     published by the Free Software Foundation; either version 2 of the
+  *     License, or (at your option) any later version.
+  *
+  *     This library is distributed in the hope that it will be useful,
+  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *     GNU General Public License for more details.
+  *
+  *     You should have received a copy of the GNU General Public
+  *     License along with this library; if not, write to the Free
+  *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+  *     MA 02110-1301 USA
+  *
+  * Alternatively,
+  *
+  *  b) Redistribution and use in source and binary forms, with or
+  *     without modification, are permitted provided that the following
+  *     conditions are met:
+  *
+  *     1. Redistributions of source code must retain the above
+  *        copyright notice, this list of conditions and the following
+  *        disclaimer.
+  *     2. Redistributions in binary form must reproduce the above
+  *        copyright notice, this list of conditions and the following
+  *        disclaimer in the documentation and/or other materials
+  *        provided with the distribution.
+  *
+  *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+  *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+  *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+  *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+  *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+  *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+  *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+  *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ #include "libfdt_env.h"
+ 
+ #ifndef USE_HOSTCC
+ #include <fdt.h>
+ #include <libfdt.h>
+ #else
+ #include "fdt_host.h"
+ #endif
+ 
+ #include "libfdt_internal.h"
+ 
+ int fdt_setprop_inplace(void *fdt, int nodeoffset, const char *name,
+ 			const void *val, int len)
+ {
+ 	void *propval;
+ 	int proplen;
+ 
+ 	propval = fdt_getprop_w(fdt, nodeoffset, name, &proplen);
+ 	if (! propval)
+ 		return proplen;
+ 
+ 	if (proplen != len)
+ 		return -FDT_ERR_NOSPACE;
+ 
+ 	memcpy(propval, val, len);
+ 	return 0;
+ }
+ 
+ static void nop_region(void *start, int len)
+ {
+ 	uint32_t *p;
+ 
+ 	for (p = start; (void *)p < (start + len); p++)
+ 		*p = cpu_to_fdt32(FDT_NOP);
+ }
+ 
+ int fdt_nop_property(void *fdt, int nodeoffset, const char *name)
+ {
+ 	struct fdt_property *prop;
+ 	int len;
+ 
+ 	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
+ 	if (! prop)
+ 		return len;
+ 
+ 	nop_region(prop, len + sizeof(*prop));
+ 
+ 	return 0;
+ }
+ 
+ int _fdt_node_end_offset(void *fdt, int nodeoffset)
+ {
+ 	int level = 0;
+ 	uint32_t tag;
+ 	int offset, nextoffset;
+ 
+ 	tag = fdt_next_tag(fdt, nodeoffset, &nextoffset);
+ 	if (tag != FDT_BEGIN_NODE)
+ 		return -FDT_ERR_BADOFFSET;
+ 	do {
+ 		offset = nextoffset;
+ 		tag = fdt_next_tag(fdt, offset, &nextoffset);
+ 
+ 		switch (tag) {
+ 		case FDT_END:
+ 			return offset;
+ 
+ 		case FDT_BEGIN_NODE:
+ 			level++;
+ 			break;
+ 
+ 		case FDT_END_NODE:
+ 			level--;
+ 			break;
+ 
+ 		case FDT_PROP:
+ 		case FDT_NOP:
+ 			break;
+ 
+ 		default:
+ 			return -FDT_ERR_BADSTRUCTURE;
+ 		}
+ 	} while (level >= 0);
+ 
+ 	return nextoffset;
+ }
+ 
+ int fdt_nop_node(void *fdt, int nodeoffset)
+ {
+ 	int endoffset;
+ 
+ 	endoffset = _fdt_node_end_offset(fdt, nodeoffset);
+ 	if (endoffset < 0)
+ 		return endoffset;
+ 
+ 	nop_region(fdt_offset_ptr_w(fdt, nodeoffset, 0), endoffset - nodeoffset);
+ 	return 0;
+ }
diff -crBN u-boot-1.3.4.clean/tools/image.c u-boot-1.3.4/tools/image.c
*** u-boot-1.3.4.clean/tools/image.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/tools/image.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,2511 ----
+ /*
+  * (C) Copyright 2008 Semihalf
+  *
+  * (C) Copyright 2000-2006
+  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+  *
+  * See file CREDITS for list of people who contributed to this
+  * project.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  */
+ 
+ #ifndef USE_HOSTCC
+ #include <common.h>
+ #include <watchdog.h>
+ 
+ #ifdef CONFIG_SHOW_BOOT_PROGRESS
+ #include <status_led.h>
+ #endif
+ 
+ #ifdef CONFIG_HAS_DATAFLASH
+ #include <dataflash.h>
+ #endif
+ 
+ #ifdef CONFIG_LOGBUFFER
+ #include <logbuff.h>
+ #endif
+ 
+ #if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE)
+ #include <rtc.h>
+ #endif
+ 
+ #include <image.h>
+ 
+ #if defined(CONFIG_FIT) || defined (CONFIG_OF_LIBFDT)
+ #include <fdt.h>
+ #include <libfdt.h>
+ #include <fdt_support.h>
+ #endif
+ 
+ #if defined(CONFIG_FIT)
+ #include <u-boot/md5.h>
+ #include <sha1.h>
+ 
+ static int fit_check_ramdisk (const void *fit, int os_noffset,
+ 		uint8_t arch, int verify);
+ #endif
+ 
+ #ifdef CONFIG_CMD_BDI
+ extern int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+ #endif
+ 
+ DECLARE_GLOBAL_DATA_PTR;
+ 
+ static image_header_t* image_get_ramdisk (ulong rd_addr, uint8_t arch,
+ 						int verify);
+ #else
+ #include "mkimage.h"
+ #include <u-boot/md5.h>
+ #include <time.h>
+ #include <image.h>
+ #endif /* !USE_HOSTCC*/
+ 
+ typedef struct table_entry {
+ 	int	id;		/* as defined in image.h	*/
+ 	char	*sname;		/* short (input) name		*/
+ 	char	*lname;		/* long (output) name		*/
+ } table_entry_t;
+ 
+ static table_entry_t uimage_arch[] = {
+ 	{	IH_ARCH_INVALID,	NULL,		"Invalid ARCH",	},
+ 	{	IH_ARCH_ALPHA,		"alpha",	"Alpha",	},
+ 	{	IH_ARCH_ARM,		"arm",		"ARM",		},
+ 	{	IH_ARCH_I386,		"x86",		"Intel x86",	},
+ 	{	IH_ARCH_IA64,		"ia64",		"IA64",		},
+ 	{	IH_ARCH_M68K,		"m68k",		"M68K",		},
+ 	{	IH_ARCH_MICROBLAZE,	"microblaze",	"MicroBlaze",	},
+ 	{	IH_ARCH_MIPS,		"mips",		"MIPS",		},
+ 	{	IH_ARCH_MIPS64,		"mips64",	"MIPS 64 Bit",	},
+ 	{	IH_ARCH_NIOS,		"nios",		"NIOS",		},
+ 	{	IH_ARCH_NIOS2,		"nios2",	"NIOS II",	},
+ 	{	IH_ARCH_PPC,		"powerpc",	"PowerPC",	},
+ 	{	IH_ARCH_PPC,		"ppc",		"PowerPC",	},
+ 	{	IH_ARCH_S390,		"s390",		"IBM S390",	},
+ 	{	IH_ARCH_SH,		"sh",		"SuperH",	},
+ 	{	IH_ARCH_SPARC,		"sparc",	"SPARC",	},
+ 	{	IH_ARCH_SPARC64,	"sparc64",	"SPARC 64 Bit",	},
+ 	{	IH_ARCH_BLACKFIN,	"blackfin",	"Blackfin",	},
+ 	{	IH_ARCH_AVR32,		"avr32",	"AVR32",	},
+ 	{	-1,			"",		"",		},
+ };
+ 
+ static table_entry_t uimage_os[] = {
+ 	{	IH_OS_INVALID,	NULL,		"Invalid OS",		},
+ #if defined(CONFIG_ARTOS) || defined(USE_HOSTCC)
+ 	{	IH_OS_ARTOS,	"artos",	"ARTOS",		},
+ #endif
+ 	{	IH_OS_LINUX,	"linux",	"Linux",		},
+ #if defined(CONFIG_LYNXKDI) || defined(USE_HOSTCC)
+ 	{	IH_OS_LYNXOS,	"lynxos",	"LynxOS",		},
+ #endif
+ 	{	IH_OS_NETBSD,	"netbsd",	"NetBSD",		},
+ 	{	IH_OS_RTEMS,	"rtems",	"RTEMS",		},
+ 	{	IH_OS_U_BOOT,	"u-boot",	"U-Boot",		},
+ #if defined(CONFIG_CMD_ELF) || defined(USE_HOSTCC)
+ 	{	IH_OS_QNX,	"qnx",		"QNX",			},
+ 	{	IH_OS_VXWORKS,	"vxworks",	"VxWorks",		},
+ #endif
+ #ifdef USE_HOSTCC
+ 	{	IH_OS_4_4BSD,	"4_4bsd",	"4_4BSD",		},
+ 	{	IH_OS_DELL,	"dell",		"Dell",			},
+ 	{	IH_OS_ESIX,	"esix",		"Esix",			},
+ 	{	IH_OS_FREEBSD,	"freebsd",	"FreeBSD",		},
+ 	{	IH_OS_IRIX,	"irix",		"Irix",			},
+ 	{	IH_OS_NCR,	"ncr",		"NCR",			},
+ 	{	IH_OS_OPENBSD,	"openbsd",	"OpenBSD",		},
+ 	{	IH_OS_PSOS,	"psos",		"pSOS",			},
+ 	{	IH_OS_SCO,	"sco",		"SCO",			},
+ 	{	IH_OS_SOLARIS,	"solaris",	"Solaris",		},
+ 	{	IH_OS_SVR4,	"svr4",		"SVR4",			},
+ #endif
+ 	{	-1,		"",		"",			},
+ };
+ 
+ static table_entry_t uimage_type[] = {
+ 	{	IH_TYPE_INVALID,    NULL,	  "Invalid Image",	},
+ 	{	IH_TYPE_FILESYSTEM, "filesystem", "Filesystem Image",	},
+ 	{	IH_TYPE_FIRMWARE,   "firmware",	  "Firmware",		},
+ 	{	IH_TYPE_KERNEL,	    "kernel",	  "Kernel Image",	},
+ 	{	IH_TYPE_MULTI,	    "multi",	  "Multi-File Image",	},
+ 	{	IH_TYPE_RAMDISK,    "ramdisk",	  "RAMDisk Image",	},
+ 	{	IH_TYPE_SCRIPT,     "script",	  "Script",		},
+ 	{	IH_TYPE_STANDALONE, "standalone", "Standalone Program", },
+ 	{	IH_TYPE_FLATDT,     "flat_dt",    "Flat Device Tree",	},
+ 	{	-1,		    "",		  "",			},
+ };
+ 
+ static table_entry_t uimage_comp[] = {
+ 	{	IH_COMP_NONE,	"none",		"uncompressed",		},
+ 	{	IH_COMP_BZIP2,	"bzip2",	"bzip2 compressed",	},
+ 	{	IH_COMP_GZIP,	"gzip",		"gzip compressed",	},
+ 	{	-1,		"",		"",			},
+ };
+ 
+ uint32_t crc32 (uint32_t, const unsigned char *, uint);
+ uint32_t crc32_wd (uint32_t, const unsigned char *, uint, uint);
+ static void genimg_print_size (uint32_t size);
+ #if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
+ static void genimg_print_time (time_t timestamp);
+ #endif
+ 
+ /*****************************************************************************/
+ /* Legacy format routines */
+ /*****************************************************************************/
+ int image_check_hcrc (image_header_t *hdr)
+ {
+ 	ulong hcrc;
+ 	ulong len = image_get_header_size ();
+ 	image_header_t header;
+ 
+ 	/* Copy header so we can blank CRC field for re-calculation */
+ 	memmove (&header, (char *)hdr, image_get_header_size ());
+ 	image_set_hcrc (&header, 0);
+ 
+ 	hcrc = crc32 (0, (unsigned char *)&header, len);
+ 
+ 	return (hcrc == image_get_hcrc (hdr));
+ }
+ 
+ int image_check_dcrc (image_header_t *hdr)
+ {
+ 	ulong data = image_get_data (hdr);
+ 	ulong len = image_get_data_size (hdr);
+ 	ulong dcrc = crc32_wd (0, (unsigned char *)data, len, CHUNKSZ_CRC32);
+ 
+ 	return (dcrc == image_get_dcrc (hdr));
+ }
+ 
+ /**
+  * image_multi_count - get component (sub-image) count
+  * @hdr: pointer to the header of the multi component image
+  *
+  * image_multi_count() returns number of components in a multi
+  * component image.
+  *
+  * Note: no checking of the image type is done, caller must pass
+  * a valid multi component image.
+  *
+  * returns:
+  *     number of components
+  */
+ ulong image_multi_count (image_header_t *hdr)
+ {
+ 	ulong i, count = 0;
+ 	uint32_t *size;
+ 
+ 	/* get start of the image payload, which in case of multi
+ 	 * component images that points to a table of component sizes */
+ 	size = (uint32_t *)image_get_data (hdr);
+ 
+ 	/* count non empty slots */
+ 	for (i = 0; size[i]; ++i)
+ 		count++;
+ 
+ 	return count;
+ }
+ 
+ /**
+  * image_multi_getimg - get component data address and size
+  * @hdr: pointer to the header of the multi component image
+  * @idx: index of the requested component
+  * @data: pointer to a ulong variable, will hold component data address
+  * @len: pointer to a ulong variable, will hold component size
+  *
+  * image_multi_getimg() returns size and data address for the requested
+  * component in a multi component image.
+  *
+  * Note: no checking of the image type is done, caller must pass
+  * a valid multi component image.
+  *
+  * returns:
+  *     data address and size of the component, if idx is valid
+  *     0 in data and len, if idx is out of range
+  */
+ void image_multi_getimg (image_header_t *hdr, ulong idx,
+ 			ulong *data, ulong *len)
+ {
+ 	int i;
+ 	uint32_t *size;
+ 	ulong offset, count, img_data;
+ 
+ 	/* get number of component */
+ 	count = image_multi_count (hdr);
+ 
+ 	/* get start of the image payload, which in case of multi
+ 	 * component images that points to a table of component sizes */
+ 	size = (uint32_t *)image_get_data (hdr);
+ 
+ 	/* get address of the proper component data start, which means
+ 	 * skipping sizes table (add 1 for last, null entry) */
+ 	img_data = image_get_data (hdr) + (count + 1) * sizeof (uint32_t);
+ 
+ 	if (idx < count) {
+ 		*len = uimage_to_cpu (size[idx]);
+ 		offset = 0;
+ 
+ 		/* go over all indices preceding requested component idx */
+ 		for (i = 0; i < idx; i++) {
+ 			/* add up i-th component size, rounding up to 4 bytes */
+ 			offset += (uimage_to_cpu (size[i]) + 3) & ~3 ;
+ 		}
+ 
+ 		/* calculate idx-th component data address */
+ 		*data = img_data + offset;
+ 	} else {
+ 		*len = 0;
+ 		*data = 0;
+ 	}
+ }
+ 
+ static void image_print_type (image_header_t *hdr)
+ {
+ 	const char *os, *arch, *type, *comp;
+ 
+ 	os = genimg_get_os_name (image_get_os (hdr));
+ 	arch = genimg_get_arch_name (image_get_arch (hdr));
+ 	type = genimg_get_type_name (image_get_type (hdr));
+ 	comp = genimg_get_comp_name (image_get_comp (hdr));
+ 
+ 	printf ("%s %s %s (%s)\n", arch, os, type, comp);
+ }
+ 
+ /**
+  * image_print_contents - prints out the contents of the legacy format image
+  * @hdr: pointer to the legacy format image header
+  * @p: pointer to prefix string
+  *
+  * image_print_contents() formats a multi line legacy image contents description.
+  * The routine prints out all header fields followed by the size/offset data
+  * for MULTI/SCRIPT images.
+  *
+  * returns:
+  *     no returned results
+  */
+ void image_print_contents (image_header_t *hdr)
+ {
+ 	const char *p;
+ 
+ #ifdef USE_HOSTCC
+ 	p = "";
+ #else
+ 	p = "   ";
+ #endif
+ 
+ 	printf ("%sImage Name:   %.*s\n", p, IH_NMLEN, image_get_name (hdr));
+ #if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
+ 	printf ("%sCreated:      ", p);
+ 	genimg_print_time ((time_t)image_get_time (hdr));
+ #endif
+ 	printf ("%sImage Type:   ", p);
+ 	image_print_type (hdr);
+ 	printf ("%sData Size:    ", p);
+ 	genimg_print_size (image_get_data_size (hdr));
+ 	printf ("%sLoad Address: %08x\n", p, image_get_load (hdr));
+ 	printf ("%sEntry Point:  %08x\n", p, image_get_ep (hdr));
+ 
+ 	if (image_check_type (hdr, IH_TYPE_MULTI) ||
+ 			image_check_type (hdr, IH_TYPE_SCRIPT)) {
+ 		int i;
+ 		ulong data, len;
+ 		ulong count = image_multi_count (hdr);
+ 
+ 		printf ("%sContents:\n", p);
+ 		for (i = 0; i < count; i++) {
+ 			image_multi_getimg (hdr, i, &data, &len);
+ 
+ 			printf ("%s   Image %d: ", p, i);
+ 			genimg_print_size (len);
+ 
+ 			if (image_check_type (hdr, IH_TYPE_SCRIPT) && i > 0) {
+ 				/*
+ 				 * the user may need to know offsets
+ 				 * if planning to do something with
+ 				 * multiple files
+ 				 */
+ 				printf ("%s    Offset = 0x%08lx\n", p, data);
+ 			}
+ 		}
+ 	}
+ }
+ 
+ 
+ #ifndef USE_HOSTCC
+ /**
+  * image_get_ramdisk - get and verify ramdisk image
+  * @rd_addr: ramdisk image start address
+  * @arch: expected ramdisk architecture
+  * @verify: checksum verification flag
+  *
+  * image_get_ramdisk() returns a pointer to the verified ramdisk image
+  * header. Routine receives image start address and expected architecture
+  * flag. Verification done covers data and header integrity and os/type/arch
+  * fields checking.
+  *
+  * If dataflash support is enabled routine checks for dataflash addresses
+  * and handles required dataflash reads.
+  *
+  * returns:
+  *     pointer to a ramdisk image header, if image was found and valid
+  *     otherwise, return NULL
+  */
+ static image_header_t* image_get_ramdisk (ulong rd_addr, uint8_t arch,
+ 						int verify)
+ {
+ 	image_header_t *rd_hdr = (image_header_t *)rd_addr;
+ 
+ 	if (!image_check_magic (rd_hdr)) {
+ 		puts ("Bad Magic Number\n");
+ 		show_boot_progress (-10);
+ 		return NULL;
+ 	}
+ 
+ 	if (!image_check_hcrc (rd_hdr)) {
+ 		puts ("Bad Header Checksum\n");
+ 		show_boot_progress (-11);
+ 		return NULL;
+ 	}
+ 
+ 	show_boot_progress (10);
+ 	image_print_contents (rd_hdr);
+ 
+ 	if (verify) {
+ 		puts("   Verifying Checksum ... ");
+ 		if (!image_check_dcrc (rd_hdr)) {
+ 			puts ("Bad Data CRC\n");
+ 			show_boot_progress (-12);
+ 			return NULL;
+ 		}
+ 		puts("OK\n");
+ 	}
+ 
+ 	show_boot_progress (11);
+ 
+ 	if (!image_check_os (rd_hdr, IH_OS_LINUX) ||
+ 	    !image_check_arch (rd_hdr, arch) ||
+ 	    !image_check_type (rd_hdr, IH_TYPE_RAMDISK)) {
+ 		printf ("No Linux %s Ramdisk Image\n",
+ 				genimg_get_arch_name(arch));
+ 		show_boot_progress (-13);
+ 		return NULL;
+ 	}
+ 
+ 	return rd_hdr;
+ }
+ #endif /* !USE_HOSTCC */
+ 
+ /*****************************************************************************/
+ /* Shared dual-format routines */
+ /*****************************************************************************/
+ #ifndef USE_HOSTCC
+ int getenv_yesno (char *var)
+ {
+ 	char *s = getenv (var);
+ 	return (s && (*s == 'n')) ? 0 : 1;
+ }
+ 
+ ulong getenv_bootm_low(void)
+ {
+ 	char *s = getenv ("bootm_low");
+ 	if (s) {
+ 		ulong tmp = simple_strtoul (s, NULL, 16);
+ 		return tmp;
+ 	}
+ 
+ #if defined(CFG_SDRAM_BASE)
+ 	return CFG_SDRAM_BASE;
+ #elif defined(CONFIG_ARM)
+ 	return gd->bd->bi_dram[0].start;
+ #else
+ 	return 0;
+ #endif
+ }
+ 
+ phys_size_t getenv_bootm_size(void)
+ {
+ 	char *s = getenv ("bootm_size");
+ 	if (s) {
+ 		phys_size_t tmp;
+ #ifdef CFG_64BIT_STRTOUL
+ 		tmp = (phys_size_t)simple_strtoull (s, NULL, 16);
+ #else
+ 		tmp = (phys_size_t)simple_strtoul (s, NULL, 16);
+ #endif
+ 		return tmp;
+ 	}
+ 
+ #if defined(CONFIG_ARM)
+ 	return gd->bd->bi_dram[0].size;
+ #else
+ 	return gd->bd->bi_memsize;
+ #endif
+ }
+ 
+ void memmove_wd (void *to, void *from, size_t len, ulong chunksz)
+ {
+ #if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+ 	while (len > 0) {
+ 		size_t tail = (len > chunksz) ? chunksz : len;
+ 		WATCHDOG_RESET ();
+ 		memmove (to, from, tail);
+ 		to += tail;
+ 		from += tail;
+ 		len -= tail;
+ 	}
+ #else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
+ 	memmove (to, from, len);
+ #endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
+ }
+ #endif /* !USE_HOSTCC */
+ 
+ static void genimg_print_size (uint32_t size)
+ {
+ #ifndef USE_HOSTCC
+ 	printf ("%d Bytes = ", size);
+ 	print_size (size, "\n");
+ #else
+ 	printf ("%d Bytes = %.2f kB = %.2f MB\n",
+ 			size, (double)size / 1.024e3,
+ 			(double)size / 1.048576e6);
+ #endif
+ }
+ 
+ #if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
+ static void genimg_print_time (time_t timestamp)
+ {
+ #ifndef USE_HOSTCC
+ 	struct rtc_time tm;
+ 
+ 	to_tm (timestamp, &tm);
+ 	printf ("%4d-%02d-%02d  %2d:%02d:%02d UTC\n",
+ 			tm.tm_year, tm.tm_mon, tm.tm_mday,
+ 			tm.tm_hour, tm.tm_min, tm.tm_sec);
+ #else
+ 	printf ("%s", ctime(&timestamp));
+ #endif
+ }
+ #endif /* CONFIG_TIMESTAMP || CONFIG_CMD_DATE || USE_HOSTCC */
+ 
+ /**
+  * get_table_entry_name - translate entry id to long name
+  * @table: pointer to a translation table for entries of a specific type
+  * @msg: message to be returned when translation fails
+  * @id: entry id to be translated
+  *
+  * get_table_entry_name() will go over translation table trying to find
+  * entry that matches given id. If matching entry is found, its long
+  * name is returned to the caller.
+  *
+  * returns:
+  *     long entry name if translation succeeds
+  *     msg otherwise
+  */
+ static char *get_table_entry_name (table_entry_t *table, char *msg, int id)
+ {
+ 	for (; table->id >= 0; ++table) {
+ 		if (table->id == id)
+ 			return (table->lname);
+ 	}
+ 	return (msg);
+ }
+ 
+ const char *genimg_get_os_name (uint8_t os)
+ {
+ 	return (get_table_entry_name (uimage_os, "Unknown OS", os));
+ }
+ 
+ const char *genimg_get_arch_name (uint8_t arch)
+ {
+ 	return (get_table_entry_name (uimage_arch, "Unknown Architecture", arch));
+ }
+ 
+ const char *genimg_get_type_name (uint8_t type)
+ {
+ 	return (get_table_entry_name (uimage_type, "Unknown Image", type));
+ }
+ 
+ const char *genimg_get_comp_name (uint8_t comp)
+ {
+ 	return (get_table_entry_name (uimage_comp, "Unknown Compression", comp));
+ }
+ 
+ /**
+  * get_table_entry_id - translate short entry name to id
+  * @table: pointer to a translation table for entries of a specific type
+  * @table_name: to be used in case of error
+  * @name: entry short name to be translated
+  *
+  * get_table_entry_id() will go over translation table trying to find
+  * entry that matches given short name. If matching entry is found,
+  * its id returned to the caller.
+  *
+  * returns:
+  *     entry id if translation succeeds
+  *     -1 otherwise
+  */
+ static int get_table_entry_id (table_entry_t *table,
+ 		const char *table_name, const char *name)
+ {
+ 	table_entry_t *t;
+ #ifdef USE_HOSTCC
+ 	int first = 1;
+ 
+ 	for (t = table; t->id >= 0; ++t) {
+ 		if (t->sname && strcasecmp(t->sname, name) == 0)
+ 			return (t->id);
+ 	}
+ 
+ 	fprintf (stderr, "\nInvalid %s Type - valid names are", table_name);
+ 	for (t = table; t->id >= 0; ++t) {
+ 		if (t->sname == NULL)
+ 			continue;
+ 		fprintf (stderr, "%c %s", (first) ? ':' : ',', t->sname);
+ 		first = 0;
+ 	}
+ 	fprintf (stderr, "\n");
+ #else
+ 	for (t = table; t->id >= 0; ++t) {
+ 		if (t->sname && strcmp(t->sname, name) == 0)
+ 			return (t->id);
+ 	}
+ 	debug ("Invalid %s Type: %s\n", table_name, name);
+ #endif /* USE_HOSTCC */
+ 	return (-1);
+ }
+ 
+ int genimg_get_os_id (const char *name)
+ {
+ 	return (get_table_entry_id (uimage_os, "OS", name));
+ }
+ 
+ int genimg_get_arch_id (const char *name)
+ {
+ 	return (get_table_entry_id (uimage_arch, "CPU", name));
+ }
+ 
+ int genimg_get_type_id (const char *name)
+ {
+ 	return (get_table_entry_id (uimage_type, "Image", name));
+ }
+ 
+ int genimg_get_comp_id (const char *name)
+ {
+ 	return (get_table_entry_id (uimage_comp, "Compression", name));
+ }
+ 
+ #ifndef USE_HOSTCC
+ /**
+  * genimg_get_format - get image format type
+  * @img_addr: image start address
+  *
+  * genimg_get_format() checks whether provided address points to a valid
+  * legacy or FIT image.
+  *
+  * New uImage format and FDT blob are based on a libfdt. FDT blob
+  * may be passed directly or embedded in a FIT image. In both situations
+  * genimg_get_format() must be able to dectect libfdt header.
+  *
+  * returns:
+  *     image format type or IMAGE_FORMAT_INVALID if no image is present
+  */
+ int genimg_get_format (void *img_addr)
+ {
+ 	ulong		format = IMAGE_FORMAT_INVALID;
+ 	image_header_t	*hdr;
+ #if defined(CONFIG_FIT) || defined(CONFIG_OF_LIBFDT)
+ 	char		*fit_hdr;
+ #endif
+ 
+ 	hdr = (image_header_t *)img_addr;
+ 	if (image_check_magic(hdr))
+ 		format = IMAGE_FORMAT_LEGACY;
+ #if defined(CONFIG_FIT) || defined(CONFIG_OF_LIBFDT)
+ 	else {
+ 		fit_hdr = (char *)img_addr;
+ 		if (fdt_check_header (fit_hdr) == 0)
+ 			format = IMAGE_FORMAT_FIT;
+ 	}
+ #endif
+ 
+ 	return format;
+ }
+ 
+ /**
+  * genimg_get_image - get image from special storage (if necessary)
+  * @img_addr: image start address
+  *
+  * genimg_get_image() checks if provided image start adddress is located
+  * in a dataflash storage. If so, image is moved to a system RAM memory.
+  *
+  * returns:
+  *     image start address after possible relocation from special storage
+  */
+ ulong genimg_get_image (ulong img_addr)
+ {
+ 	ulong ram_addr = img_addr;
+ 
+ #ifdef CONFIG_HAS_DATAFLASH
+ 	ulong h_size, d_size;
+ 
+ 	if (addr_dataflash (img_addr)){
+ 		/* ger RAM address */
+ 		ram_addr = CFG_LOAD_ADDR;
+ 
+ 		/* get header size */
+ 		h_size = image_get_header_size ();
+ #if defined(CONFIG_FIT)
+ 		if (sizeof(struct fdt_header) > h_size)
+ 			h_size = sizeof(struct fdt_header);
+ #endif
+ 
+ 		/* read in header */
+ 		debug ("   Reading image header from dataflash address "
+ 			"%08lx to RAM address %08lx\n", img_addr, ram_addr);
+ 
+ 		read_dataflash (img_addr, h_size, (char *)ram_addr);
+ 
+ 		/* get data size */
+ 		switch (genimg_get_format ((void *)ram_addr)) {
+ 		case IMAGE_FORMAT_LEGACY:
+ 			d_size = image_get_data_size ((image_header_t *)ram_addr);
+ 			debug ("   Legacy format image found at 0x%08lx, size 0x%08lx\n",
+ 					ram_addr, d_size);
+ 			break;
+ #if defined(CONFIG_FIT)
+ 		case IMAGE_FORMAT_FIT:
+ 			d_size = fit_get_size ((const void *)ram_addr) - h_size;
+ 			debug ("   FIT/FDT format image found at 0x%08lx, size 0x%08lx\n",
+ 					ram_addr, d_size);
+ 			break;
+ #endif
+ 		default:
+ 			printf ("   No valid image found at 0x%08lx\n", img_addr);
+ 			return ram_addr;
+ 		}
+ 
+ 		/* read in image data */
+ 		debug ("   Reading image remaining data from dataflash address "
+ 			"%08lx to RAM address %08lx\n", img_addr + h_size,
+ 			ram_addr + h_size);
+ 
+ 		read_dataflash (img_addr + h_size, d_size,
+ 				(char *)(ram_addr + h_size));
+ 
+ 	}
+ #endif /* CONFIG_HAS_DATAFLASH */
+ 
+ 	return ram_addr;
+ }
+ 
+ /**
+  * fit_has_config - check if there is a valid FIT configuration
+  * @images: pointer to the bootm command headers structure
+  *
+  * fit_has_config() checks if there is a FIT configuration in use
+  * (if FTI support is present).
+  *
+  * returns:
+  *     0, no FIT support or no configuration found
+  *     1, configuration found
+  */
+ int genimg_has_config (bootm_headers_t *images)
+ {
+ #if defined(CONFIG_FIT)
+ 	if (images->fit_uname_cfg)
+ 		return 1;
+ #endif
+ 	return 0;
+ }
+ 
+ /**
+  * boot_get_ramdisk - main ramdisk handling routine
+  * @argc: command argument count
+  * @argv: command argument list
+  * @images: pointer to the bootm images structure
+  * @arch: expected ramdisk architecture
+  * @rd_start: pointer to a ulong variable, will hold ramdisk start address
+  * @rd_end: pointer to a ulong variable, will hold ramdisk end
+  *
+  * boot_get_ramdisk() is responsible for finding a valid ramdisk image.
+  * Curently supported are the following ramdisk sources:
+  *      - multicomponent kernel/ramdisk image,
+  *      - commandline provided address of decicated ramdisk image.
+  *
+  * returns:
+  *     0, if ramdisk image was found and valid, or skiped
+  *     rd_start and rd_end are set to ramdisk start/end addresses if
+  *     ramdisk image is found and valid
+  *
+  *     1, if ramdisk image is found but corrupted
+  *     rd_start and rd_end are set to 0 if no ramdisk exists
+  */
+ int boot_get_ramdisk (int argc, char *argv[], bootm_headers_t *images,
+ 		uint8_t arch, ulong *rd_start, ulong *rd_end)
+ {
+ 	ulong rd_addr, rd_load;
+ 	ulong rd_data, rd_len;
+ 	image_header_t *rd_hdr;
+ #if defined(CONFIG_FIT)
+ 	void		*fit_hdr;
+ 	const char	*fit_uname_config = NULL;
+ 	const char	*fit_uname_ramdisk = NULL;
+ 	ulong		default_addr;
+ 	int		rd_noffset;
+ 	int		cfg_noffset;
+ 	const void	*data;
+ 	size_t		size;
+ #endif
+ 
+ 	*rd_start = 0;
+ 	*rd_end = 0;
+ 
+ 	/*
+ 	 * Look for a '-' which indicates to ignore the
+ 	 * ramdisk argument
+ 	 */
+ 	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
+ 		debug ("## Skipping init Ramdisk\n");
+ 		rd_len = rd_data = 0;
+ 	} else if (argc >= 3 || genimg_has_config (images)) {
+ #if defined(CONFIG_FIT)
+ 		if (argc >= 3) {
+ 			/*
+ 			 * If the init ramdisk comes from the FIT image and
+ 			 * the FIT image address is omitted in the command
+ 			 * line argument, try to use os FIT image address or
+ 			 * default load address.
+ 			 */
+ 			if (images->fit_uname_os)
+ 				default_addr = (ulong)images->fit_hdr_os;
+ 			else
+ 				default_addr = load_addr;
+ 
+ 			if (fit_parse_conf (argv[2], default_addr,
+ 						&rd_addr, &fit_uname_config)) {
+ 				debug ("*  ramdisk: config '%s' from image at 0x%08lx\n",
+ 						fit_uname_config, rd_addr);
+ 			} else if (fit_parse_subimage (argv[2], default_addr,
+ 						&rd_addr, &fit_uname_ramdisk)) {
+ 				debug ("*  ramdisk: subimage '%s' from image at 0x%08lx\n",
+ 						fit_uname_ramdisk, rd_addr);
+ 			} else
+ #endif
+ 			{
+ 				rd_addr = simple_strtoul(argv[2], NULL, 16);
+ 				debug ("*  ramdisk: cmdline image address = 0x%08lx\n",
+ 						rd_addr);
+ 			}
+ #if defined(CONFIG_FIT)
+ 		} else {
+ 			/* use FIT configuration provided in first bootm
+ 			 * command argument
+ 			 */
+ 			rd_addr = (ulong)images->fit_hdr_os;
+ 			fit_uname_config = images->fit_uname_cfg;
+ 			debug ("*  ramdisk: using config '%s' from image at 0x%08lx\n",
+ 					fit_uname_config, rd_addr);
+ 
+ 			/*
+ 			 * Check whether configuration has ramdisk defined,
+ 			 * if not, don't try to use it, quit silently.
+ 			 */
+ 			fit_hdr = (void *)rd_addr;
+ 			cfg_noffset = fit_conf_get_node (fit_hdr, fit_uname_config);
+ 			if (cfg_noffset < 0) {
+ 				debug ("*  ramdisk: no such config\n");
+ 				return 1;
+ 			}
+ 
+ 			rd_noffset = fit_conf_get_ramdisk_node (fit_hdr, cfg_noffset);
+ 			if (rd_noffset < 0) {
+ 				debug ("*  ramdisk: no ramdisk in config\n");
+ 				return 0;
+ 			}
+ 		}
+ #endif
+ 
+ 		/* copy from dataflash if needed */
+ 		rd_addr = genimg_get_image (rd_addr);
+ 
+ 		/*
+ 		 * Check if there is an initrd image at the
+ 		 * address provided in the second bootm argument
+ 		 * check image type, for FIT images get FIT node.
+ 		 */
+ 		switch (genimg_get_format ((void *)rd_addr)) {
+ 		case IMAGE_FORMAT_LEGACY:
+ 			printf ("## Loading init Ramdisk from Legacy "
+ 					"Image at %08lx ...\n", rd_addr);
+ 
+ 			show_boot_progress (9);
+ 			rd_hdr = image_get_ramdisk (rd_addr, arch,
+ 							images->verify);
+ 
+ 			if (rd_hdr == NULL)
+ 				return 1;
+ 
+ 			rd_data = image_get_data (rd_hdr);
+ 			rd_len = image_get_data_size (rd_hdr);
+ 			rd_load = image_get_load (rd_hdr);
+ 			break;
+ #if defined(CONFIG_FIT)
+ 		case IMAGE_FORMAT_FIT:
+ 			fit_hdr = (void *)rd_addr;
+ 			printf ("## Loading init Ramdisk from FIT "
+ 					"Image at %08lx ...\n", rd_addr);
+ 
+ 			show_boot_progress (120);
+ 			if (!fit_check_format (fit_hdr)) {
+ 				puts ("Bad FIT ramdisk image format!\n");
+ 				show_boot_progress (-120);
+ 				return 1;
+ 			}
+ 			show_boot_progress (121);
+ 
+ 			if (!fit_uname_ramdisk) {
+ 				/*
+ 				 * no ramdisk image node unit name, try to get config
+ 				 * node first. If config unit node name is NULL
+ 				 * fit_conf_get_node() will try to find default config node
+ 				 */
+ 				show_boot_progress (122);
+ 				cfg_noffset = fit_conf_get_node (fit_hdr, fit_uname_config);
+ 				if (cfg_noffset < 0) {
+ 					puts ("Could not find configuration node\n");
+ 					show_boot_progress (-122);
+ 					return 1;
+ 				}
+ 				fit_uname_config = fdt_get_name (fit_hdr, cfg_noffset, NULL);
+ 				printf ("   Using '%s' configuration\n", fit_uname_config);
+ 
+ 				rd_noffset = fit_conf_get_ramdisk_node (fit_hdr, cfg_noffset);
+ 				fit_uname_ramdisk = fit_get_name (fit_hdr, rd_noffset, NULL);
+ 			} else {
+ 				/* get ramdisk component image node offset */
+ 				show_boot_progress (123);
+ 				rd_noffset = fit_image_get_node (fit_hdr, fit_uname_ramdisk);
+ 			}
+ 			if (rd_noffset < 0) {
+ 				puts ("Could not find subimage node\n");
+ 				show_boot_progress (-124);
+ 				return 1;
+ 			}
+ 
+ 			printf ("   Trying '%s' ramdisk subimage\n", fit_uname_ramdisk);
+ 
+ 			show_boot_progress (125);
+ 			if (!fit_check_ramdisk (fit_hdr, rd_noffset, arch, images->verify))
+ 				return 1;
+ 
+ 			/* get ramdisk image data address and length */
+ 			if (fit_image_get_data (fit_hdr, rd_noffset, &data, &size)) {
+ 				puts ("Could not find ramdisk subimage data!\n");
+ 				show_boot_progress (-127);
+ 				return 1;
+ 			}
+ 			show_boot_progress (128);
+ 
+ 			rd_data = (ulong)data;
+ 			rd_len = size;
+ 
+ 			if (fit_image_get_load (fit_hdr, rd_noffset, &rd_load)) {
+ 				puts ("Can't get ramdisk subimage load address!\n");
+ 				show_boot_progress (-129);
+ 				return 1;
+ 			}
+ 			show_boot_progress (129);
+ 
+ 			images->fit_hdr_rd = fit_hdr;
+ 			images->fit_uname_rd = fit_uname_ramdisk;
+ 			images->fit_noffset_rd = rd_noffset;
+ 			break;
+ #endif
+ 		default:
+ 			puts ("Wrong Ramdisk Image Format\n");
+ 			rd_data = rd_len = rd_load = 0;
+ 		}
+ 
+ #if defined(CONFIG_B2) || defined(CONFIG_EVB4510) || defined(CONFIG_ARMADILLO)
+ 		/*
+ 		 * We need to copy the ramdisk to SRAM to let Linux boot
+ 		 */
+ 		if (rd_data) {
+ 			memmove ((void *)rd_load, (uchar *)rd_data, rd_len);
+ 			rd_data = rd_load;
+ 		}
+ #endif /* CONFIG_B2 || CONFIG_EVB4510 || CONFIG_ARMADILLO */
+ 
+ 	} else if (images->legacy_hdr_valid &&
+ 			image_check_type (&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
+ 		/*
+ 		 * Now check if we have a legacy mult-component image,
+ 		 * get second entry data start address and len.
+ 		 */
+ 		show_boot_progress (13);
+ 		printf ("## Loading init Ramdisk from multi component "
+ 				"Legacy Image at %08lx ...\n",
+ 				(ulong)images->legacy_hdr_os);
+ 
+ 		image_multi_getimg (images->legacy_hdr_os, 1, &rd_data, &rd_len);
+ 	} else {
+ 		/*
+ 		 * no initrd image
+ 		 */
+ 		show_boot_progress (14);
+ 		rd_len = rd_data = 0;
+ 	}
+ 
+ 	if (!rd_data) {
+ 		debug ("## No init Ramdisk\n");
+ 	} else {
+ 		*rd_start = rd_data;
+ 		*rd_end = rd_data + rd_len;
+ 	}
+ 	debug ("   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx\n",
+ 			*rd_start, *rd_end);
+ 
+ 	return 0;
+ }
+ 
+ #if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_SPARC)
+ /**
+  * boot_ramdisk_high - relocate init ramdisk
+  * @lmb: pointer to lmb handle, will be used for memory mgmt
+  * @rd_data: ramdisk data start address
+  * @rd_len: ramdisk data length
+  * @initrd_start: pointer to a ulong variable, will hold final init ramdisk
+  *      start address (after possible relocation)
+  * @initrd_end: pointer to a ulong variable, will hold final init ramdisk
+  *      end address (after possible relocation)
+  *
+  * boot_ramdisk_high() takes a relocation hint from "initrd_high" environement
+  * variable and if requested ramdisk data is moved to a specified location.
+  *
+  * Initrd_start and initrd_end are set to final (after relocation) ramdisk
+  * start/end addresses if ramdisk image start and len were provided,
+  * otherwise set initrd_start and initrd_end set to zeros.
+  *
+  * returns:
+  *      0 - success
+  *     -1 - failure
+  */
+ int boot_ramdisk_high (struct lmb *lmb, ulong rd_data, ulong rd_len,
+ 		  ulong *initrd_start, ulong *initrd_end)
+ {
+ 	char	*s;
+ 	ulong	initrd_high;
+ 	int	initrd_copy_to_ram = 1;
+ 
+ 	if ((s = getenv ("initrd_high")) != NULL) {
+ 		/* a value of "no" or a similar string will act like 0,
+ 		 * turning the "load high" feature off. This is intentional.
+ 		 */
+ 		initrd_high = simple_strtoul (s, NULL, 16);
+ 		if (initrd_high == ~0)
+ 			initrd_copy_to_ram = 0;
+ 	} else {
+ 		/* not set, no restrictions to load high */
+ 		initrd_high = ~0;
+ 	}
+ 
+ 
+ #ifdef CONFIG_LOGBUFFER
+ 	/* Prevent initrd from overwriting logbuffer */
+ 	lmb_reserve(lmb, logbuffer_base() - LOGBUFF_OVERHEAD, LOGBUFF_RESERVE);
+ #endif
+ 
+ 	debug ("## initrd_high = 0x%08lx, copy_to_ram = %d\n",
+ 			initrd_high, initrd_copy_to_ram);
+ 
+ 	if (rd_data) {
+ 		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
+ 			debug ("   in-place initrd\n");
+ 			*initrd_start = rd_data;
+ 			*initrd_end = rd_data + rd_len;
+ 			lmb_reserve(lmb, rd_data, rd_len);
+ 		} else {
+ 			if (initrd_high)
+ 				*initrd_start = (ulong)lmb_alloc_base (lmb, rd_len, 0x1000, initrd_high);
+ 			else
+ 				*initrd_start = (ulong)lmb_alloc (lmb, rd_len, 0x1000);
+ 
+ 			if (*initrd_start == 0) {
+ 				puts ("ramdisk - allocation error\n");
+ 				goto error;
+ 			}
+ 			show_boot_progress (12);
+ 
+ 			*initrd_end = *initrd_start + rd_len;
+ 			printf ("   Loading Ramdisk to %08lx, end %08lx ... ",
+ 					*initrd_start, *initrd_end);
+ 
+ 			memmove_wd ((void *)*initrd_start,
+ 					(void *)rd_data, rd_len, CHUNKSZ);
+ 
+ 			puts ("OK\n");
+ 		}
+ 	} else {
+ 		*initrd_start = 0;
+ 		*initrd_end = 0;
+ 	}
+ 	debug ("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
+ 			*initrd_start, *initrd_end);
+ 
+ 	return 0;
+ 
+ error:
+ 	return -1;
+ }
+ 
+ /**
+  * boot_get_cmdline - allocate and initialize kernel cmdline
+  * @lmb: pointer to lmb handle, will be used for memory mgmt
+  * @cmd_start: pointer to a ulong variable, will hold cmdline start
+  * @cmd_end: pointer to a ulong variable, will hold cmdline end
+  * @bootmap_base: ulong variable, holds offset in physical memory to
+  * base of bootmap
+  *
+  * boot_get_cmdline() allocates space for kernel command line below
+  * BOOTMAPSZ + bootmap_base address. If "bootargs" U-boot environemnt
+  * variable is present its contents is copied to allocated kernel
+  * command line.
+  *
+  * returns:
+  *      0 - success
+  *     -1 - failure
+  */
+ int boot_get_cmdline (struct lmb *lmb, ulong *cmd_start, ulong *cmd_end,
+ 			ulong bootmap_base)
+ {
+ 	char *cmdline;
+ 	char *s;
+ 
+ 	cmdline = (char *)(ulong)lmb_alloc_base(lmb, CFG_BARGSIZE, 0xf,
+ 					 CFG_BOOTMAPSZ + bootmap_base);
+ 
+ 	if (cmdline == NULL)
+ 		return -1;
+ 
+ 	if ((s = getenv("bootargs")) == NULL)
+ 		s = "";
+ 
+ 	strcpy(cmdline, s);
+ 
+ 	*cmd_start = (ulong) & cmdline[0];
+ 	*cmd_end = *cmd_start + strlen(cmdline);
+ 
+ 	debug ("## cmdline at 0x%08lx ... 0x%08lx\n", *cmd_start, *cmd_end);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * boot_get_kbd - allocate and initialize kernel copy of board info
+  * @lmb: pointer to lmb handle, will be used for memory mgmt
+  * @kbd: double pointer to board info data
+  * @bootmap_base: ulong variable, holds offset in physical memory to
+  * base of bootmap
+  *
+  * boot_get_kbd() allocates space for kernel copy of board info data below
+  * BOOTMAPSZ + bootmap_base address and kernel board info is initialized with
+  * the current u-boot board info data.
+  *
+  * returns:
+  *      0 - success
+  *     -1 - failure
+  */
+ int boot_get_kbd (struct lmb *lmb, bd_t **kbd, ulong bootmap_base)
+ {
+ 	*kbd = (bd_t *)(ulong)lmb_alloc_base(lmb, sizeof(bd_t), 0xf,
+ 				      CFG_BOOTMAPSZ + bootmap_base);
+ 	if (*kbd == NULL)
+ 		return -1;
+ 
+ 	**kbd = *(gd->bd);
+ 
+ 	debug ("## kernel board info at 0x%08lx\n", (ulong)*kbd);
+ 
+ #if defined(DEBUG) && defined(CONFIG_CMD_BDI)
+ 	do_bdinfo(NULL, 0, 0, NULL);
+ #endif
+ 
+ 	return 0;
+ }
+ #endif /* CONFIG_PPC || CONFIG_M68K */
+ #endif /* !USE_HOSTCC */
+ 
+ #if defined(CONFIG_FIT)
+ /*****************************************************************************/
+ /* New uImage format routines */
+ /*****************************************************************************/
+ #ifndef USE_HOSTCC
+ static int fit_parse_spec (const char *spec, char sepc, ulong addr_curr,
+ 		ulong *addr, const char **name)
+ {
+ 	const char *sep;
+ 
+ 	*addr = addr_curr;
+ 	*name = NULL;
+ 
+ 	sep = strchr (spec, sepc);
+ 	if (sep) {
+ 		if (sep - spec > 0)
+ 			*addr = simple_strtoul (spec, NULL, 16);
+ 
+ 		*name = sep + 1;
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * fit_parse_conf - parse FIT configuration spec
+  * @spec: input string, containing configuration spec
+  * @add_curr: current image address (to be used as a possible default)
+  * @addr: pointer to a ulong variable, will hold FIT image address of a given
+  * configuration
+  * @conf_name double pointer to a char, will hold pointer to a configuration
+  * unit name
+  *
+  * fit_parse_conf() expects configuration spec in the for of [<addr>]#<conf>,
+  * where <addr> is a FIT image address that contains configuration
+  * with a <conf> unit name.
+  *
+  * Address part is optional, and if omitted default add_curr will
+  * be used instead.
+  *
+  * returns:
+  *     1 if spec is a valid configuration string,
+  *     addr and conf_name are set accordingly
+  *     0 otherwise
+  */
+ inline int fit_parse_conf (const char *spec, ulong addr_curr,
+ 		ulong *addr, const char **conf_name)
+ {
+ 	return fit_parse_spec (spec, '#', addr_curr, addr, conf_name);
+ }
+ 
+ /**
+  * fit_parse_subimage - parse FIT subimage spec
+  * @spec: input string, containing subimage spec
+  * @add_curr: current image address (to be used as a possible default)
+  * @addr: pointer to a ulong variable, will hold FIT image address of a given
+  * subimage
+  * @image_name: double pointer to a char, will hold pointer to a subimage name
+  *
+  * fit_parse_subimage() expects subimage spec in the for of
+  * [<addr>]:<subimage>, where <addr> is a FIT image address that contains
+  * subimage with a <subimg> unit name.
+  *
+  * Address part is optional, and if omitted default add_curr will
+  * be used instead.
+  *
+  * returns:
+  *     1 if spec is a valid subimage string,
+  *     addr and image_name are set accordingly
+  *     0 otherwise
+  */
+ inline int fit_parse_subimage (const char *spec, ulong addr_curr,
+ 		ulong *addr, const char **image_name)
+ {
+ 	return fit_parse_spec (spec, ':', addr_curr, addr, image_name);
+ }
+ #endif /* !USE_HOSTCC */
+ 
+ static void fit_get_debug (const void *fit, int noffset,
+ 		char *prop_name, int err)
+ {
+ 	debug ("Can't get '%s' property from FIT 0x%08lx, "
+ 		"node: offset %d, name %s (%s)\n",
+ 		prop_name, (ulong)fit, noffset,
+ 		fit_get_name (fit, noffset, NULL),
+ 		fdt_strerror (err));
+ }
+ 
+ /**
+  * fit_print_contents - prints out the contents of the FIT format image
+  * @fit: pointer to the FIT format image header
+  * @p: pointer to prefix string
+  *
+  * fit_print_contents() formats a multi line FIT image contents description.
+  * The routine prints out FIT image properties (root node level) follwed by
+  * the details of each component image.
+  *
+  * returns:
+  *     no returned results
+  */
+ void fit_print_contents (const void *fit)
+ {
+ 	char *desc;
+ 	char *uname;
+ 	int images_noffset;
+ 	int confs_noffset;
+ 	int noffset;
+ 	int ndepth;
+ 	int count = 0;
+ 	int ret;
+ 	const char *p;
+ #if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
+ 	time_t timestamp;
+ #endif
+ 
+ #ifdef USE_HOSTCC
+ 	p = "";
+ #else
+ 	p = "   ";
+ #endif
+ 
+ 	/* Root node properties */
+ 	ret = fit_get_desc (fit, 0, &desc);
+ 	printf ("%sFIT description: ", p);
+ 	if (ret)
+ 		printf ("unavailable\n");
+ 	else
+ 		printf ("%s\n", desc);
+ 
+ #if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
+ 	ret = fit_get_timestamp (fit, 0, &timestamp);
+ 	printf ("%sCreated:         ", p);
+ 	if (ret)
+ 		printf ("unavailable\n");
+ 	else
+ 		genimg_print_time (timestamp);
+ #endif
+ 
+ 	/* Find images parent node offset */
+ 	images_noffset = fdt_path_offset (fit, FIT_IMAGES_PATH);
+ 	if (images_noffset < 0) {
+ 		printf ("Can't find images parent node '%s' (%s)\n",
+ 			FIT_IMAGES_PATH, fdt_strerror (images_noffset));
+ 		return;
+ 	}
+ 
+ 	/* Process its subnodes, print out component images details */
+ 	for (ndepth = 0, count = 0, noffset = fdt_next_node (fit, images_noffset, &ndepth);
+ 	     (noffset >= 0) && (ndepth > 0);
+ 	     noffset = fdt_next_node (fit, noffset, &ndepth)) {
+ 		if (ndepth == 1) {
+ 			/*
+ 			 * Direct child node of the images parent node,
+ 			 * i.e. component image node.
+ 			 */
+ 			printf ("%s Image %u (%s)\n", p, count++,
+ 					fit_get_name(fit, noffset, NULL));
+ 
+ 			fit_image_print (fit, noffset, p);
+ 		}
+ 	}
+ 
+ 	/* Find configurations parent node offset */
+ 	confs_noffset = fdt_path_offset (fit, FIT_CONFS_PATH);
+ 	if (confs_noffset < 0) {
+ 		debug ("Can't get configurations parent node '%s' (%s)\n",
+ 			FIT_CONFS_PATH, fdt_strerror (confs_noffset));
+ 		return;
+ 	}
+ 
+ 	/* get default configuration unit name from default property */
+ 	uname = (char *)fdt_getprop (fit, noffset, FIT_DEFAULT_PROP, NULL);
+ 	if (uname)
+ 		printf ("%s Default Configuration: '%s'\n", p, uname);
+ 
+ 	/* Process its subnodes, print out configurations details */
+ 	for (ndepth = 0, count = 0, noffset = fdt_next_node (fit, confs_noffset, &ndepth);
+ 	     (noffset >= 0) && (ndepth > 0);
+ 	     noffset = fdt_next_node (fit, noffset, &ndepth)) {
+ 		if (ndepth == 1) {
+ 			/*
+ 			 * Direct child node of the configurations parent node,
+ 			 * i.e. configuration node.
+ 			 */
+ 			printf ("%s Configuration %u (%s)\n", p, count++,
+ 					fit_get_name(fit, noffset, NULL));
+ 
+ 			fit_conf_print (fit, noffset, p);
+ 		}
+ 	}
+ }
+ 
+ /**
+  * fit_image_print - prints out the FIT component image details
+  * @fit: pointer to the FIT format image header
+  * @image_noffset: offset of the component image node
+  * @p: pointer to prefix string
+  *
+  * fit_image_print() lists all mandatory properies for the processed component
+  * image. If present, hash nodes are printed out as well.
+  *
+  * returns:
+  *     no returned results
+  */
+ void fit_image_print (const void *fit, int image_noffset, const char *p)
+ {
+ 	char *desc;
+ 	uint8_t type, arch, os, comp;
+ 	size_t size;
+ 	ulong load, entry;
+ 	const void *data;
+ 	int noffset;
+ 	int ndepth;
+ 	int ret;
+ 
+ 	/* Mandatory properties */
+ 	ret = fit_get_desc (fit, image_noffset, &desc);
+ 	printf ("%s  Description:  ", p);
+ 	if (ret)
+ 		printf ("unavailable\n");
+ 	else
+ 		printf ("%s\n", desc);
+ 
+ 	fit_image_get_type (fit, image_noffset, &type);
+ 	printf ("%s  Type:         %s\n", p, genimg_get_type_name (type));
+ 
+ 	fit_image_get_comp (fit, image_noffset, &comp);
+ 	printf ("%s  Compression:  %s\n", p, genimg_get_comp_name (comp));
+ 
+ 	ret = fit_image_get_data (fit, image_noffset, &data, &size);
+ 
+ #ifndef USE_HOSTCC
+ 	printf ("%s  Data Start:   ", p);
+ 	if (ret)
+ 		printf ("unavailable\n");
+ 	else
+ 		printf ("0x%08lx\n", (ulong)data);
+ #endif
+ 
+ 	printf ("%s  Data Size:    ", p);
+ 	if (ret)
+ 		printf ("unavailable\n");
+ 	else
+ 		genimg_print_size (size);
+ 
+ 	/* Remaining, type dependent properties */
+ 	if ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||
+ 	    (type == IH_TYPE_RAMDISK) || (type == IH_TYPE_FIRMWARE) ||
+ 	    (type == IH_TYPE_FLATDT)) {
+ 		fit_image_get_arch (fit, image_noffset, &arch);
+ 		printf ("%s  Architecture: %s\n", p, genimg_get_arch_name (arch));
+ 	}
+ 
+ 	if (type == IH_TYPE_KERNEL) {
+ 		fit_image_get_os (fit, image_noffset, &os);
+ 		printf ("%s  OS:           %s\n", p, genimg_get_os_name (os));
+ 	}
+ 
+ 	if ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE)) {
+ 		ret = fit_image_get_load (fit, image_noffset, &load);
+ 		printf ("%s  Load Address: ", p);
+ 		if (ret)
+ 			printf ("unavailable\n");
+ 		else
+ 			printf ("0x%08lx\n", load);
+ 
+ 		fit_image_get_entry (fit, image_noffset, &entry);
+ 		printf ("%s  Entry Point:  ", p);
+ 		if (ret)
+ 			printf ("unavailable\n");
+ 		else
+ 			printf ("0x%08lx\n", entry);
+ 	}
+ 
+ 	/* Process all hash subnodes of the component image node */
+ 	for (ndepth = 0, noffset = fdt_next_node (fit, image_noffset, &ndepth);
+ 	     (noffset >= 0) && (ndepth > 0);
+ 	     noffset = fdt_next_node (fit, noffset, &ndepth)) {
+ 		if (ndepth == 1) {
+ 			/* Direct child node of the component image node */
+ 			fit_image_print_hash (fit, noffset, p);
+ 		}
+ 	}
+ }
+ 
+ /**
+  * fit_image_print_hash - prints out the hash node details
+  * @fit: pointer to the FIT format image header
+  * @noffset: offset of the hash node
+  * @p: pointer to prefix string
+  *
+  * fit_image_print_hash() lists properies for the processed hash node
+  *
+  * returns:
+  *     no returned results
+  */
+ void fit_image_print_hash (const void *fit, int noffset, const char *p)
+ {
+ 	char *algo;
+ 	uint8_t *value;
+ 	int value_len;
+ 	int i, ret;
+ 
+ 	/*
+ 	 * Check subnode name, must be equal to "hash".
+ 	 * Multiple hash nodes require unique unit node
+ 	 * names, e.g. hash@1, hash@2, etc.
+ 	 */
+ 	if (strncmp (fit_get_name(fit, noffset, NULL),
+ 			FIT_HASH_NODENAME,
+ 			strlen(FIT_HASH_NODENAME)) != 0)
+ 		return;
+ 
+ 	debug ("%s  Hash node:    '%s'\n", p,
+ 			fit_get_name (fit, noffset, NULL));
+ 
+ 	printf ("%s  Hash algo:    ", p);
+ 	if (fit_image_hash_get_algo (fit, noffset, &algo)) {
+ 		printf ("invalid/unsupported\n");
+ 		return;
+ 	}
+ 	printf ("%s\n", algo);
+ 
+ 	ret = fit_image_hash_get_value (fit, noffset, &value,
+ 					&value_len);
+ 	printf ("%s  Hash value:   ", p);
+ 	if (ret) {
+ 		printf ("unavailable\n");
+ 	} else {
+ 		for (i = 0; i < value_len; i++)
+ 			printf ("%02x", value[i]);
+ 		printf ("\n");
+ 	}
+ 
+ 	debug  ("%s  Hash len:     %d\n", p, value_len);
+ }
+ 
+ /**
+  * fit_get_desc - get node description property
+  * @fit: pointer to the FIT format image header
+  * @noffset: node offset
+  * @desc: double pointer to the char, will hold pointer to the descrption
+  *
+  * fit_get_desc() reads description property from a given node, if
+  * description is found pointer to it is returened in third call argument.
+  *
+  * returns:
+  *     0, on success
+  *     -1, on failure
+  */
+ int fit_get_desc (const void *fit, int noffset, char **desc)
+ {
+ 	int len;
+ 
+ 	*desc = (char *)fdt_getprop (fit, noffset, FIT_DESC_PROP, &len);
+ 	if (*desc == NULL) {
+ 		fit_get_debug (fit, noffset, FIT_DESC_PROP, len);
+ 		return -1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * fit_get_timestamp - get node timestamp property
+  * @fit: pointer to the FIT format image header
+  * @noffset: node offset
+  * @timestamp: pointer to the time_t, will hold read timestamp
+  *
+  * fit_get_timestamp() reads timestamp poperty from given node, if timestamp
+  * is found and has a correct size its value is retured in third call
+  * argument.
+  *
+  * returns:
+  *     0, on success
+  *     -1, on property read failure
+  *     -2, on wrong timestamp size
+  */
+ int fit_get_timestamp (const void *fit, int noffset, time_t *timestamp)
+ {
+ 	int len;
+ 	const void *data;
+ 
+ 	data = fdt_getprop (fit, noffset, FIT_TIMESTAMP_PROP, &len);
+ 	if (data == NULL) {
+ 		fit_get_debug (fit, noffset, FIT_TIMESTAMP_PROP, len);
+ 		return -1;
+ 	}
+ 	if (len != sizeof (uint32_t)) {
+ 		debug ("FIT timestamp with incorrect size of (%u)\n", len);
+ 		return -2;
+ 	}
+ 
+ 	*timestamp = uimage_to_cpu (*((uint32_t *)data));
+ 	return 0;
+ }
+ 
+ /**
+  * fit_image_get_node - get node offset for component image of a given unit name
+  * @fit: pointer to the FIT format image header
+  * @image_uname: component image node unit name
+  *
+  * fit_image_get_node() finds a component image (withing the '/images'
+  * node) of a provided unit name. If image is found its node offset is
+  * returned to the caller.
+  *
+  * returns:
+  *     image node offset when found (>=0)
+  *     negative number on failure (FDT_ERR_* code)
+  */
+ int fit_image_get_node (const void *fit, const char *image_uname)
+ {
+ 	int noffset, images_noffset;
+ 
+ 	images_noffset = fdt_path_offset (fit, FIT_IMAGES_PATH);
+ 	if (images_noffset < 0) {
+ 		debug ("Can't find images parent node '%s' (%s)\n",
+ 			FIT_IMAGES_PATH, fdt_strerror (images_noffset));
+ 		return images_noffset;
+ 	}
+ 
+ 	noffset = fdt_subnode_offset (fit, images_noffset, image_uname);
+ 	if (noffset < 0) {
+ 		debug ("Can't get node offset for image unit name: '%s' (%s)\n",
+ 			image_uname, fdt_strerror (noffset));
+ 	}
+ 
+ 	return noffset;
+ }
+ 
+ /**
+  * fit_image_get_os - get os id for a given component image node
+  * @fit: pointer to the FIT format image header
+  * @noffset: component image node offset
+  * @os: pointer to the uint8_t, will hold os numeric id
+  *
+  * fit_image_get_os() finds os property in a given component image node.
+  * If the property is found, its (string) value is translated to the numeric
+  * id which is returned to the caller.
+  *
+  * returns:
+  *     0, on success
+  *     -1, on failure
+  */
+ int fit_image_get_os (const void *fit, int noffset, uint8_t *os)
+ {
+ 	int len;
+ 	const void *data;
+ 
+ 	/* Get OS name from property data */
+ 	data = fdt_getprop (fit, noffset, FIT_OS_PROP, &len);
+ 	if (data == NULL) {
+ 		fit_get_debug (fit, noffset, FIT_OS_PROP, len);
+ 		*os = -1;
+ 		return -1;
+ 	}
+ 
+ 	/* Translate OS name to id */
+ 	*os = genimg_get_os_id (data);
+ 	return 0;
+ }
+ 
+ /**
+  * fit_image_get_arch - get arch id for a given component image node
+  * @fit: pointer to the FIT format image header
+  * @noffset: component image node offset
+  * @arch: pointer to the uint8_t, will hold arch numeric id
+  *
+  * fit_image_get_arch() finds arch property in a given component image node.
+  * If the property is found, its (string) value is translated to the numeric
+  * id which is returned to the caller.
+  *
+  * returns:
+  *     0, on success
+  *     -1, on failure
+  */
+ int fit_image_get_arch (const void *fit, int noffset, uint8_t *arch)
+ {
+ 	int len;
+ 	const void *data;
+ 
+ 	/* Get architecture name from property data */
+ 	data = fdt_getprop (fit, noffset, FIT_ARCH_PROP, &len);
+ 	if (data == NULL) {
+ 		fit_get_debug (fit, noffset, FIT_ARCH_PROP, len);
+ 		*arch = -1;
+ 		return -1;
+ 	}
+ 
+ 	/* Translate architecture name to id */
+ 	*arch = genimg_get_arch_id (data);
+ 	return 0;
+ }
+ 
+ /**
+  * fit_image_get_type - get type id for a given component image node
+  * @fit: pointer to the FIT format image header
+  * @noffset: component image node offset
+  * @type: pointer to the uint8_t, will hold type numeric id
+  *
+  * fit_image_get_type() finds type property in a given component image node.
+  * If the property is found, its (string) value is translated to the numeric
+  * id which is returned to the caller.
+  *
+  * returns:
+  *     0, on success
+  *     -1, on failure
+  */
+ int fit_image_get_type (const void *fit, int noffset, uint8_t *type)
+ {
+ 	int len;
+ 	const void *data;
+ 
+ 	/* Get image type name from property data */
+ 	data = fdt_getprop (fit, noffset, FIT_TYPE_PROP, &len);
+ 	if (data == NULL) {
+ 		fit_get_debug (fit, noffset, FIT_TYPE_PROP, len);
+ 		*type = -1;
+ 		return -1;
+ 	}
+ 
+ 	/* Translate image type name to id */
+ 	*type = genimg_get_type_id (data);
+ 	return 0;
+ }
+ 
+ /**
+  * fit_image_get_comp - get comp id for a given component image node
+  * @fit: pointer to the FIT format image header
+  * @noffset: component image node offset
+  * @comp: pointer to the uint8_t, will hold comp numeric id
+  *
+  * fit_image_get_comp() finds comp property in a given component image node.
+  * If the property is found, its (string) value is translated to the numeric
+  * id which is returned to the caller.
+  *
+  * returns:
+  *     0, on success
+  *     -1, on failure
+  */
+ int fit_image_get_comp (const void *fit, int noffset, uint8_t *comp)
+ {
+ 	int len;
+ 	const void *data;
+ 
+ 	/* Get compression name from property data */
+ 	data = fdt_getprop (fit, noffset, FIT_COMP_PROP, &len);
+ 	if (data == NULL) {
+ 		fit_get_debug (fit, noffset, FIT_COMP_PROP, len);
+ 		*comp = -1;
+ 		return -1;
+ 	}
+ 
+ 	/* Translate compression name to id */
+ 	*comp = genimg_get_comp_id (data);
+ 	return 0;
+ }
+ 
+ /**
+  * fit_image_get_load - get load address property for a given component image node
+  * @fit: pointer to the FIT format image header
+  * @noffset: component image node offset
+  * @load: pointer to the uint32_t, will hold load address
+  *
+  * fit_image_get_load() finds load address property in a given component image node.
+  * If the property is found, its value is returned to the caller.
+  *
+  * returns:
+  *     0, on success
+  *     -1, on failure
+  */
+ int fit_image_get_load (const void *fit, int noffset, ulong *load)
+ {
+ 	int len;
+ 	const uint32_t *data;
+ 
+ 	data = fdt_getprop (fit, noffset, FIT_LOAD_PROP, &len);
+ 	if (data == NULL) {
+ 		fit_get_debug (fit, noffset, FIT_LOAD_PROP, len);
+ 		return -1;
+ 	}
+ 
+ 	*load = uimage_to_cpu (*data);
+ 	return 0;
+ }
+ 
+ /**
+  * fit_image_get_entry - get entry point address property for a given component image node
+  * @fit: pointer to the FIT format image header
+  * @noffset: component image node offset
+  * @entry: pointer to the uint32_t, will hold entry point address
+  *
+  * fit_image_get_entry() finds entry point address property in a given component image node.
+  * If the property is found, its value is returned to the caller.
+  *
+  * returns:
+  *     0, on success
+  *     -1, on failure
+  */
+ int fit_image_get_entry (const void *fit, int noffset, ulong *entry)
+ {
+ 	int len;
+ 	const uint32_t *data;
+ 
+ 	data = fdt_getprop (fit, noffset, FIT_ENTRY_PROP, &len);
+ 	if (data == NULL) {
+ 		fit_get_debug (fit, noffset, FIT_ENTRY_PROP, len);
+ 		return -1;
+ 	}
+ 
+ 	*entry = uimage_to_cpu (*data);
+ 	return 0;
+ }
+ 
+ /**
+  * fit_image_get_data - get data property and its size for a given component image node
+  * @fit: pointer to the FIT format image header
+  * @noffset: component image node offset
+  * @data: double pointer to void, will hold data property's data address
+  * @size: pointer to size_t, will hold data property's data size
+  *
+  * fit_image_get_data() finds data property in a given component image node.
+  * If the property is found its data start address and size are returned to
+  * the caller.
+  *
+  * returns:
+  *     0, on success
+  *     -1, on failure
+  */
+ int fit_image_get_data (const void *fit, int noffset,
+ 		const void **data, size_t *size)
+ {
+ 	int len;
+ 
+ 	*data = fdt_getprop (fit, noffset, FIT_DATA_PROP, &len);
+ 	if (*data == NULL) {
+ 		fit_get_debug (fit, noffset, FIT_DATA_PROP, len);
+ 		*size = 0;
+ 		return -1;
+ 	}
+ 
+ 	*size = len;
+ 	return 0;
+ }
+ 
+ /**
+  * fit_image_hash_get_algo - get hash algorithm name
+  * @fit: pointer to the FIT format image header
+  * @noffset: hash node offset
+  * @algo: double pointer to char, will hold pointer to the algorithm name
+  *
+  * fit_image_hash_get_algo() finds hash algorithm property in a given hash node.
+  * If the property is found its data start address is returned to the caller.
+  *
+  * returns:
+  *     0, on success
+  *     -1, on failure
+  */
+ int fit_image_hash_get_algo (const void *fit, int noffset, char **algo)
+ {
+ 	int len;
+ 
+ 	*algo = (char *)fdt_getprop (fit, noffset, FIT_ALGO_PROP, &len);
+ 	if (*algo == NULL) {
+ 		fit_get_debug (fit, noffset, FIT_ALGO_PROP, len);
+ 		return -1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * fit_image_hash_get_value - get hash value and length
+  * @fit: pointer to the FIT format image header
+  * @noffset: hash node offset
+  * @value: double pointer to uint8_t, will hold address of a hash value data
+  * @value_len: pointer to an int, will hold hash data length
+  *
+  * fit_image_hash_get_value() finds hash value property in a given hash node.
+  * If the property is found its data start address and size are returned to
+  * the caller.
+  *
+  * returns:
+  *     0, on success
+  *     -1, on failure
+  */
+ int fit_image_hash_get_value (const void *fit, int noffset, uint8_t **value,
+ 				int *value_len)
+ {
+ 	int len;
+ 
+ 	*value = (uint8_t *)fdt_getprop (fit, noffset, FIT_VALUE_PROP, &len);
+ 	if (*value == NULL) {
+ 		fit_get_debug (fit, noffset, FIT_VALUE_PROP, len);
+ 		*value_len = 0;
+ 		return -1;
+ 	}
+ 
+ 	*value_len = len;
+ 	return 0;
+ }
+ 
+ /**
+  * fit_set_timestamp - set node timestamp property
+  * @fit: pointer to the FIT format image header
+  * @noffset: node offset
+  * @timestamp: timestamp value to be set
+  *
+  * fit_set_timestamp() attempts to set timestamp property in the requested
+  * node and returns operation status to the caller.
+  *
+  * returns:
+  *     0, on success
+  *     -1, on property read failure
+  */
+ int fit_set_timestamp (void *fit, int noffset, time_t timestamp)
+ {
+ 	uint32_t t;
+ 	int ret;
+ 
+ 	t = cpu_to_uimage (timestamp);
+ 	ret = fdt_setprop (fit, noffset, FIT_TIMESTAMP_PROP, &t,
+ 				sizeof (uint32_t));
+ 	if (ret) {
+ 		printf ("Can't set '%s' property for '%s' node (%s)\n",
+ 			FIT_TIMESTAMP_PROP, fit_get_name (fit, noffset, NULL),
+ 			fdt_strerror (ret));
+ 		return -1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * calculate_hash - calculate and return hash for provided input data
+  * @data: pointer to the input data
+  * @data_len: data length
+  * @algo: requested hash algorithm
+  * @value: pointer to the char, will hold hash value data (caller must
+  * allocate enough free space)
+  * value_len: length of the calculated hash
+  *
+  * calculate_hash() computes input data hash according to the requested algorithm.
+  * Resulting hash value is placed in caller provided 'value' buffer, length
+  * of the calculated hash is returned via value_len pointer argument.
+  *
+  * returns:
+  *     0, on success
+  *    -1, when algo is unsupported
+  */
+ static int calculate_hash (const void *data, int data_len, const char *algo,
+ 			uint8_t *value, int *value_len)
+ {
+ 	if (strcmp (algo, "crc32") == 0 ) {
+ 		*((uint32_t *)value) = crc32_wd (0, data, data_len,
+ 							CHUNKSZ_CRC32);
+ 		*((uint32_t *)value) = cpu_to_uimage (*((uint32_t *)value));
+ 		*value_len = 4;
+ 	} else if (strcmp (algo, "sha1") == 0 ) {
+ 		sha1_csum_wd ((unsigned char *) data, data_len,
+ 				(unsigned char *) value, CHUNKSZ_SHA1);
+ 		*value_len = 20;
+ 	} else if (strcmp (algo, "md5") == 0 ) {
+ 		md5_wd ((unsigned char *)data, data_len, value, CHUNKSZ_MD5);
+ 		*value_len = 16;
+ 	} else {
+ 		debug ("Unsupported hash alogrithm\n");
+ 		return -1;
+ 	}
+ 	return 0;
+ }
+ 
+ #ifdef USE_HOSTCC
+ /**
+  * fit_set_hashes - process FIT component image nodes and calculate hashes
+  * @fit: pointer to the FIT format image header
+  *
+  * fit_set_hashes() adds hash values for all component images in the FIT blob.
+  * Hashes are calculated for all component images which have hash subnodes
+  * with algorithm property set to one of the supported hash algorithms.
+  *
+  * returns
+  *     0, on success
+  *     libfdt error code, on failure
+  */
+ int fit_set_hashes (void *fit)
+ {
+ 	int images_noffset;
+ 	int noffset;
+ 	int ndepth;
+ 	int ret;
+ 
+ 	/* Find images parent node offset */
+ 	images_noffset = fdt_path_offset (fit, FIT_IMAGES_PATH);
+ 	if (images_noffset < 0) {
+ 		printf ("Can't find images parent node '%s' (%s)\n",
+ 			FIT_IMAGES_PATH, fdt_strerror (images_noffset));
+ 		return images_noffset;
+ 	}
+ 
+ 	/* Process its subnodes, print out component images details */
+ 	for (ndepth = 0, noffset = fdt_next_node (fit, images_noffset, &ndepth);
+ 	     (noffset >= 0) && (ndepth > 0);
+ 	     noffset = fdt_next_node (fit, noffset, &ndepth)) {
+ 		if (ndepth == 1) {
+ 			/*
+ 			 * Direct child node of the images parent node,
+ 			 * i.e. component image node.
+ 			 */
+ 			ret = fit_image_set_hashes (fit, noffset);
+ 			if (ret)
+ 				return ret;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * fit_image_set_hashes - calculate/set hashes for given component image node
+  * @fit: pointer to the FIT format image header
+  * @image_noffset: requested component image node
+  *
+  * fit_image_set_hashes() adds hash values for an component image node. All
+  * existing hash subnodes are checked, if algorithm property is set to one of
+  * the supported hash algorithms, hash value is computed and corresponding
+  * hash node property is set, for example:
+  *
+  * Input component image node structure:
+  *
+  * o image@1 (at image_noffset)
+  *   | - data = [binary data]
+  *   o hash@1
+  *     |- algo = "sha1"
+  *
+  * Output component image node structure:
+  *
+  * o image@1 (at image_noffset)
+  *   | - data = [binary data]
+  *   o hash@1
+  *     |- algo = "sha1"
+  *     |- value = sha1(data)
+  *
+  * returns:
+  *     0 on sucess
+  *    <0 on failure
+  */
+ int fit_image_set_hashes (void *fit, int image_noffset)
+ {
+ 	const void *data;
+ 	size_t size;
+ 	char *algo;
+ 	uint8_t value[FIT_MAX_HASH_LEN];
+ 	int value_len;
+ 	int noffset;
+ 	int ndepth;
+ 
+ 	/* Get image data and data length */
+ 	if (fit_image_get_data (fit, image_noffset, &data, &size)) {
+ 		printf ("Can't get image data/size\n");
+ 		return -1;
+ 	}
+ 
+ 	/* Process all hash subnodes of the component image node */
+ 	for (ndepth = 0, noffset = fdt_next_node (fit, image_noffset, &ndepth);
+ 	     (noffset >= 0) && (ndepth > 0);
+ 	     noffset = fdt_next_node (fit, noffset, &ndepth)) {
+ 		if (ndepth == 1) {
+ 			/* Direct child node of the component image node */
+ 
+ 			/*
+ 			 * Check subnode name, must be equal to "hash".
+ 			 * Multiple hash nodes require unique unit node
+ 			 * names, e.g. hash@1, hash@2, etc.
+ 			 */
+ 			if (strncmp (fit_get_name(fit, noffset, NULL),
+ 						FIT_HASH_NODENAME,
+ 						strlen(FIT_HASH_NODENAME)) != 0) {
+ 				/* Not a hash subnode, skip it */
+ 				continue;
+ 			}
+ 
+ 			if (fit_image_hash_get_algo (fit, noffset, &algo)) {
+ 				printf ("Can't get hash algo property for "
+ 					"'%s' hash node in '%s' image node\n",
+ 					fit_get_name (fit, noffset, NULL),
+ 					fit_get_name (fit, image_noffset, NULL));
+ 				return -1;
+ 			}
+ 
+ 			if (calculate_hash (data, size, algo, value, &value_len)) {
+ 				printf ("Unsupported hash algorithm (%s) for "
+ 					"'%s' hash node in '%s' image node\n",
+ 					algo, fit_get_name (fit, noffset, NULL),
+ 					fit_get_name (fit, image_noffset, NULL));
+ 				return -1;
+ 			}
+ 
+ 			if (fit_image_hash_set_value (fit, noffset, value,
+ 							value_len)) {
+ 				printf ("Can't set hash value for "
+ 					"'%s' hash node in '%s' image node\n",
+ 					fit_get_name (fit, noffset, NULL),
+ 					fit_get_name (fit, image_noffset, NULL));
+ 				return -1;
+ 			}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * fit_image_hash_set_value - set hash value in requested has node
+  * @fit: pointer to the FIT format image header
+  * @noffset: hash node offset
+  * @value: hash value to be set
+  * @value_len: hash value length
+  *
+  * fit_image_hash_set_value() attempts to set hash value in a node at offset
+  * given and returns operation status to the caller.
+  *
+  * returns
+  *     0, on success
+  *     -1, on failure
+  */
+ int fit_image_hash_set_value (void *fit, int noffset, uint8_t *value,
+ 				int value_len)
+ {
+ 	int ret;
+ 
+ 	ret = fdt_setprop (fit, noffset, FIT_VALUE_PROP, value, value_len);
+ 	if (ret) {
+ 		printf ("Can't set hash '%s' property for '%s' node (%s)\n",
+ 			FIT_VALUE_PROP, fit_get_name (fit, noffset, NULL),
+ 			fdt_strerror (ret));
+ 		return -1;
+ 	}
+ 
+ 	return 0;
+ }
+ #endif /* USE_HOSTCC */
+ 
+ /**
+  * fit_image_check_hashes - verify data intergity
+  * @fit: pointer to the FIT format image header
+  * @image_noffset: component image node offset
+  *
+  * fit_image_check_hashes() goes over component image hash nodes,
+  * re-calculates each data hash and compares with the value stored in hash
+  * node.
+  *
+  * returns:
+  *     1, if all hashes are valid
+  *     0, otherwise (or on error)
+  */
+ int fit_image_check_hashes (const void *fit, int image_noffset)
+ {
+ 	const void	*data;
+ 	size_t		size;
+ 	char		*algo;
+ 	uint8_t		*fit_value;
+ 	int		fit_value_len;
+ 	uint8_t		value[FIT_MAX_HASH_LEN];
+ 	int		value_len;
+ 	int		noffset;
+ 	int		ndepth;
+ 	char		*err_msg = "";
+ 
+ 	/* Get image data and data length */
+ 	if (fit_image_get_data (fit, image_noffset, &data, &size)) {
+ 		printf ("Can't get image data/size\n");
+ 		return 0;
+ 	}
+ 
+ 	/* Process all hash subnodes of the component image node */
+ 	for (ndepth = 0, noffset = fdt_next_node (fit, image_noffset, &ndepth);
+ 	     (noffset >= 0) && (ndepth > 0);
+ 	     noffset = fdt_next_node (fit, noffset, &ndepth)) {
+ 		if (ndepth == 1) {
+ 			/* Direct child node of the component image node */
+ 
+ 			/*
+ 			 * Check subnode name, must be equal to "hash".
+ 			 * Multiple hash nodes require unique unit node
+ 			 * names, e.g. hash@1, hash@2, etc.
+ 			 */
+ 			if (strncmp (fit_get_name(fit, noffset, NULL),
+ 					FIT_HASH_NODENAME,
+ 					strlen(FIT_HASH_NODENAME)) != 0)
+ 				continue;
+ 
+ 			if (fit_image_hash_get_algo (fit, noffset, &algo)) {
+ 				err_msg = "Can't get hash algo property";
+ 				goto error;
+ 			}
+ 			printf ("%s", algo);
+ 
+ 			if (fit_image_hash_get_value (fit, noffset, &fit_value,
+ 							&fit_value_len)) {
+ 				err_msg = "Can't get hash value property";
+ 				goto error;
+ 			}
+ 
+ 			if (calculate_hash (data, size, algo, value, &value_len)) {
+ 				err_msg = "Unsupported hash algorithm";
+ 				goto error;
+ 			}
+ 
+ 			if (value_len != fit_value_len) {
+ 				err_msg = "Bad hash value len";
+ 				goto error;
+ 			} else if (memcmp (value, fit_value, value_len) != 0) {
+ 				err_msg = "Bad hash value";
+ 				goto error;
+ 			}
+ 			printf ("+ ");
+ 		}
+ 	}
+ 
+ 	return 1;
+ 
+ error:
+ 	printf ("%s for '%s' hash node in '%s' image node\n",
+ 			err_msg, fit_get_name (fit, noffset, NULL),
+ 			fit_get_name (fit, image_noffset, NULL));
+ 	return 0;
+ }
+ 
+ /**
+  * fit_image_check_os - check whether image node is of a given os type
+  * @fit: pointer to the FIT format image header
+  * @noffset: component image node offset
+  * @os: requested image os
+  *
+  * fit_image_check_os() reads image os property and compares its numeric
+  * id with the requested os. Comparison result is returned to the caller.
+  *
+  * returns:
+  *     1 if image is of given os type
+  *     0 otherwise (or on error)
+  */
+ int fit_image_check_os (const void *fit, int noffset, uint8_t os)
+ {
+ 	uint8_t image_os;
+ 
+ 	if (fit_image_get_os (fit, noffset, &image_os))
+ 		return 0;
+ 	return (os == image_os);
+ }
+ 
+ /**
+  * fit_image_check_arch - check whether image node is of a given arch
+  * @fit: pointer to the FIT format image header
+  * @noffset: component image node offset
+  * @arch: requested imagearch
+  *
+  * fit_image_check_arch() reads image arch property and compares its numeric
+  * id with the requested arch. Comparison result is returned to the caller.
+  *
+  * returns:
+  *     1 if image is of given arch
+  *     0 otherwise (or on error)
+  */
+ int fit_image_check_arch (const void *fit, int noffset, uint8_t arch)
+ {
+ 	uint8_t image_arch;
+ 
+ 	if (fit_image_get_arch (fit, noffset, &image_arch))
+ 		return 0;
+ 	return (arch == image_arch);
+ }
+ 
+ /**
+  * fit_image_check_type - check whether image node is of a given type
+  * @fit: pointer to the FIT format image header
+  * @noffset: component image node offset
+  * @type: requested image type
+  *
+  * fit_image_check_type() reads image type property and compares its numeric
+  * id with the requested type. Comparison result is returned to the caller.
+  *
+  * returns:
+  *     1 if image is of given type
+  *     0 otherwise (or on error)
+  */
+ int fit_image_check_type (const void *fit, int noffset, uint8_t type)
+ {
+ 	uint8_t image_type;
+ 
+ 	if (fit_image_get_type (fit, noffset, &image_type))
+ 		return 0;
+ 	return (type == image_type);
+ }
+ 
+ /**
+  * fit_image_check_comp - check whether image node uses given compression
+  * @fit: pointer to the FIT format image header
+  * @noffset: component image node offset
+  * @comp: requested image compression type
+  *
+  * fit_image_check_comp() reads image compression property and compares its
+  * numeric id with the requested compression type. Comparison result is
+  * returned to the caller.
+  *
+  * returns:
+  *     1 if image uses requested compression
+  *     0 otherwise (or on error)
+  */
+ int fit_image_check_comp (const void *fit, int noffset, uint8_t comp)
+ {
+ 	uint8_t image_comp;
+ 
+ 	if (fit_image_get_comp (fit, noffset, &image_comp))
+ 		return 0;
+ 	return (comp == image_comp);
+ }
+ 
+ /**
+  * fit_check_format - sanity check FIT image format
+  * @fit: pointer to the FIT format image header
+  *
+  * fit_check_format() runs a basic sanity FIT image verification.
+  * Routine checks for mandatory properties, nodes, etc.
+  *
+  * returns:
+  *     1, on success
+  *     0, on failure
+  */
+ int fit_check_format (const void *fit)
+ {
+ 	/* mandatory / node 'description' property */
+ 	if (fdt_getprop (fit, 0, FIT_DESC_PROP, NULL) == NULL) {
+ 		debug ("Wrong FIT format: no description\n");
+ 		return 0;
+ 	}
+ 
+ #if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
+ 	/* mandatory / node 'timestamp' property */
+ 	if (fdt_getprop (fit, 0, FIT_TIMESTAMP_PROP, NULL) == NULL) {
+ 		debug ("Wrong FIT format: no description\n");
+ 		return 0;
+ 	}
+ #endif
+ 
+ 	/* mandatory subimages parent '/images' node */
+ 	if (fdt_path_offset (fit, FIT_IMAGES_PATH) < 0) {
+ 		debug ("Wrong FIT format: no images parent node\n");
+ 		return 0;
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ /**
+  * fit_conf_get_node - get node offset for configuration of a given unit name
+  * @fit: pointer to the FIT format image header
+  * @conf_uname: configuration node unit name
+  *
+  * fit_conf_get_node() finds a configuration (withing the '/configurations'
+  * parant node) of a provided unit name. If configuration is found its node offset
+  * is returned to the caller.
+  *
+  * When NULL is provided in second argument fit_conf_get_node() will search
+  * for a default configuration node instead. Default configuration node unit name
+  * is retrived from FIT_DEFAULT_PROP property of the '/configurations' node.
+  *
+  * returns:
+  *     configuration node offset when found (>=0)
+  *     negative number on failure (FDT_ERR_* code)
+  */
+ int fit_conf_get_node (const void *fit, const char *conf_uname)
+ {
+ 	int noffset, confs_noffset;
+ 	int len;
+ 
+ 	confs_noffset = fdt_path_offset (fit, FIT_CONFS_PATH);
+ 	if (confs_noffset < 0) {
+ 		debug ("Can't find configurations parent node '%s' (%s)\n",
+ 			FIT_CONFS_PATH, fdt_strerror (confs_noffset));
+ 		return confs_noffset;
+ 	}
+ 
+ 	if (conf_uname == NULL) {
+ 		/* get configuration unit name from the default property */
+ 		debug ("No configuration specified, trying default...\n");
+ 		conf_uname = (char *)fdt_getprop (fit, confs_noffset, FIT_DEFAULT_PROP, &len);
+ 		if (conf_uname == NULL) {
+ 			fit_get_debug (fit, confs_noffset, FIT_DEFAULT_PROP, len);
+ 			return len;
+ 		}
+ 		debug ("Found default configuration: '%s'\n", conf_uname);
+ 	}
+ 
+ 	noffset = fdt_subnode_offset (fit, confs_noffset, conf_uname);
+ 	if (noffset < 0) {
+ 		debug ("Can't get node offset for configuration unit name: '%s' (%s)\n",
+ 			conf_uname, fdt_strerror (noffset));
+ 	}
+ 
+ 	return noffset;
+ }
+ 
+ static int __fit_conf_get_prop_node (const void *fit, int noffset,
+ 		const char *prop_name)
+ {
+ 	char *uname;
+ 	int len;
+ 
+ 	/* get kernel image unit name from configuration kernel property */
+ 	uname = (char *)fdt_getprop (fit, noffset, prop_name, &len);
+ 	if (uname == NULL)
+ 		return len;
+ 
+ 	return fit_image_get_node (fit, uname);
+ }
+ 
+ /**
+  * fit_conf_get_kernel_node - get kernel image node offset that corresponds to
+  * a given configuration
+  * @fit: pointer to the FIT format image header
+  * @noffset: configuration node offset
+  *
+  * fit_conf_get_kernel_node() retrives kernel image node unit name from
+  * configuration FIT_KERNEL_PROP property and translates it to the node
+  * offset.
+  *
+  * returns:
+  *     image node offset when found (>=0)
+  *     negative number on failure (FDT_ERR_* code)
+  */
+ int fit_conf_get_kernel_node (const void *fit, int noffset)
+ {
+ 	return __fit_conf_get_prop_node (fit, noffset, FIT_KERNEL_PROP);
+ }
+ 
+ /**
+  * fit_conf_get_ramdisk_node - get ramdisk image node offset that corresponds to
+  * a given configuration
+  * @fit: pointer to the FIT format image header
+  * @noffset: configuration node offset
+  *
+  * fit_conf_get_ramdisk_node() retrives ramdisk image node unit name from
+  * configuration FIT_KERNEL_PROP property and translates it to the node
+  * offset.
+  *
+  * returns:
+  *     image node offset when found (>=0)
+  *     negative number on failure (FDT_ERR_* code)
+  */
+ int fit_conf_get_ramdisk_node (const void *fit, int noffset)
+ {
+ 	return __fit_conf_get_prop_node (fit, noffset, FIT_RAMDISK_PROP);
+ }
+ 
+ /**
+  * fit_conf_get_fdt_node - get fdt image node offset that corresponds to
+  * a given configuration
+  * @fit: pointer to the FIT format image header
+  * @noffset: configuration node offset
+  *
+  * fit_conf_get_fdt_node() retrives fdt image node unit name from
+  * configuration FIT_KERNEL_PROP property and translates it to the node
+  * offset.
+  *
+  * returns:
+  *     image node offset when found (>=0)
+  *     negative number on failure (FDT_ERR_* code)
+  */
+ int fit_conf_get_fdt_node (const void *fit, int noffset)
+ {
+ 	return __fit_conf_get_prop_node (fit, noffset, FIT_FDT_PROP);
+ }
+ 
+ /**
+  * fit_conf_print - prints out the FIT configuration details
+  * @fit: pointer to the FIT format image header
+  * @noffset: offset of the configuration node
+  * @p: pointer to prefix string
+  *
+  * fit_conf_print() lists all mandatory properies for the processed
+  * configuration node.
+  *
+  * returns:
+  *     no returned results
+  */
+ void fit_conf_print (const void *fit, int noffset, const char *p)
+ {
+ 	char *desc;
+ 	char *uname;
+ 	int ret;
+ 
+ 	/* Mandatory properties */
+ 	ret = fit_get_desc (fit, noffset, &desc);
+ 	printf ("%s  Description:  ", p);
+ 	if (ret)
+ 		printf ("unavailable\n");
+ 	else
+ 		printf ("%s\n", desc);
+ 
+ 	uname = (char *)fdt_getprop (fit, noffset, FIT_KERNEL_PROP, NULL);
+ 	printf ("%s  Kernel:       ", p);
+ 	if (uname == NULL)
+ 		printf ("unavailable\n");
+ 	else
+ 		printf ("%s\n", uname);
+ 
+ 	/* Optional properties */
+ 	uname = (char *)fdt_getprop (fit, noffset, FIT_RAMDISK_PROP, NULL);
+ 	if (uname)
+ 		printf ("%s  Init Ramdisk: %s\n", p, uname);
+ 
+ 	uname = (char *)fdt_getprop (fit, noffset, FIT_FDT_PROP, NULL);
+ 	if (uname)
+ 		printf ("%s  FDT:          %s\n", p, uname);
+ }
+ 
+ /**
+  * fit_check_ramdisk - verify FIT format ramdisk subimage
+  * @fit_hdr: pointer to the FIT ramdisk header
+  * @rd_noffset: ramdisk subimage node offset within FIT image
+  * @arch: requested ramdisk image architecture type
+  * @verify: data CRC verification flag
+  *
+  * fit_check_ramdisk() verifies integrity of the ramdisk subimage and from
+  * specified FIT image.
+  *
+  * returns:
+  *     1, on success
+  *     0, on failure
+  */
+ #ifndef USE_HOSTCC
+ static int fit_check_ramdisk (const void *fit, int rd_noffset, uint8_t arch, int verify)
+ {
+ 	fit_image_print (fit, rd_noffset, "   ");
+ 
+ 	if (verify) {
+ 		puts ("   Verifying Hash Integrity ... ");
+ 		if (!fit_image_check_hashes (fit, rd_noffset)) {
+ 			puts ("Bad Data Hash\n");
+ 			show_boot_progress (-125);
+ 			return 0;
+ 		}
+ 		puts ("OK\n");
+ 	}
+ 
+ 	show_boot_progress (126);
+ 	if (!fit_image_check_os (fit, rd_noffset, IH_OS_LINUX) ||
+ 	    !fit_image_check_arch (fit, rd_noffset, arch) ||
+ 	    !fit_image_check_type (fit, rd_noffset, IH_TYPE_RAMDISK)) {
+ 		printf ("No Linux %s Ramdisk Image\n",
+ 				genimg_get_arch_name(arch));
+ 		show_boot_progress (-126);
+ 		return 0;
+ 	}
+ 
+ 	show_boot_progress (127);
+ 	return 1;
+ }
+ #endif /* USE_HOSTCC */
+ #endif /* CONFIG_FIT */
diff -crBN u-boot-1.3.4.clean/tools/libfdt_internal.h u-boot-1.3.4/tools/libfdt_internal.h
*** u-boot-1.3.4.clean/tools/libfdt_internal.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/tools/libfdt_internal.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,97 ----
+ #ifndef _LIBFDT_INTERNAL_H
+ #define _LIBFDT_INTERNAL_H
+ /*
+  * libfdt - Flat Device Tree manipulation
+  * Copyright (C) 2006 David Gibson, IBM Corporation.
+  *
+  * libfdt is dual licensed: you can use it either under the terms of
+  * the GPL, or the BSD license, at your option.
+  *
+  *  a) This library is free software; you can redistribute it and/or
+  *     modify it under the terms of the GNU General Public License as
+  *     published by the Free Software Foundation; either version 2 of the
+  *     License, or (at your option) any later version.
+  *
+  *     This library is distributed in the hope that it will be useful,
+  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *     GNU General Public License for more details.
+  *
+  *     You should have received a copy of the GNU General Public
+  *     License along with this library; if not, write to the Free
+  *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+  *     MA 02110-1301 USA
+  *
+  * Alternatively,
+  *
+  *  b) Redistribution and use in source and binary forms, with or
+  *     without modification, are permitted provided that the following
+  *     conditions are met:
+  *
+  *     1. Redistributions of source code must retain the above
+  *        copyright notice, this list of conditions and the following
+  *        disclaimer.
+  *     2. Redistributions in binary form must reproduce the above
+  *        copyright notice, this list of conditions and the following
+  *        disclaimer in the documentation and/or other materials
+  *        provided with the distribution.
+  *
+  *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+  *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+  *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+  *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+  *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+  *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+  *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+  *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ #include <fdt.h>
+ 
+ #define ALIGN(x, a)	(((x) + (a) - 1) & ~((a) - 1))
+ #define PALIGN(p, a)	((void *)ALIGN((unsigned long)(p), (a)))
+ 
+ #define memeq(p, q, n)	(memcmp((p), (q), (n)) == 0)
+ #define streq(p, q)	(strcmp((p), (q)) == 0)
+ 
+ #define CHECK_HEADER(fdt) \
+ 	{ \
+ 		int err; \
+ 		if ((err = fdt_check_header(fdt)) != 0) \
+ 			return err; \
+ 	}
+ 
+ uint32_t _fdt_next_tag(const void *fdt, int startoffset, int *nextoffset);
+ int _fdt_check_node_offset(const void *fdt, int offset);
+ const char *_fdt_find_string(const char *strtab, int tabsize, const char *s);
+ int _fdt_node_end_offset(void *fdt, int nodeoffset);
+ 
+ static inline const void *_fdt_offset_ptr(const void *fdt, int offset)
+ {
+ 	return fdt + fdt_off_dt_struct(fdt) + offset;
+ }
+ 
+ static inline void *_fdt_offset_ptr_w(void *fdt, int offset)
+ {
+ 	return (void *)_fdt_offset_ptr(fdt, offset);
+ }
+ 
+ static inline const struct fdt_reserve_entry *_fdt_mem_rsv(const void *fdt, int n)
+ {
+ 	const struct fdt_reserve_entry *rsv_table =
+ 		fdt + fdt_off_mem_rsvmap(fdt);
+ 
+ 	return rsv_table + n;
+ }
+ static inline struct fdt_reserve_entry *_fdt_mem_rsv_w(void *fdt, int n)
+ {
+ 	return (void *)_fdt_mem_rsv(fdt, n);
+ }
+ 
+ #define SW_MAGIC		(~FDT_MAGIC)
+ 
+ #endif /* _LIBFDT_INTERNAL_H */
diff -crBN u-boot-1.3.4.clean/tools/md5.c u-boot-1.3.4/tools/md5.c
*** u-boot-1.3.4.clean/tools/md5.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/tools/md5.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,316 ----
+ /*
+  * This file was transplanted with slight modifications from Linux sources
+  * (fs/cifs/md5.c) into U-Boot by Bartlomiej Sieka <tur@semihalf.com>.
+  */
+ 
+ /*
+  * This code implements the MD5 message-digest algorithm.
+  * The algorithm is due to Ron Rivest.  This code was
+  * written by Colin Plumb in 1993, no copyright is claimed.
+  * This code is in the public domain; do with it what you wish.
+  *
+  * Equivalent code is available from RSA Data Security, Inc.
+  * This code has been tested against that, and is equivalent,
+  * except that you don't need to include two pages of legalese
+  * with every copy.
+  *
+  * To compute the message digest of a chunk of bytes, declare an
+  * MD5Context structure, pass it to MD5Init, call MD5Update as
+  * needed on buffers full of bytes, and then call MD5Final, which
+  * will fill a supplied 16-byte array with the digest.
+  */
+ 
+ /* This code slightly modified to fit into Samba by
+    abartlet@samba.org Jun 2001
+    and to fit the cifs vfs by
+    Steve French sfrench@us.ibm.com */
+ 
+ #ifndef USE_HOSTCC
+ #include <common.h>
+ #include <linux/string.h>
+ #else
+ #include <string.h>
+ #endif /* USE_HOSTCC */
+ #include <watchdog.h>
+ #include <linux/types.h>
+ #include <u-boot/md5.h>
+ 
+ static void
+ MD5Transform(__u32 buf[4], __u32 const in[16]);
+ 
+ /*
+  * Note: this code is harmless on little-endian machines.
+  */
+ static void
+ byteReverse(unsigned char *buf, unsigned longs)
+ {
+ 	__u32 t;
+ 	do {
+ 		t = (__u32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
+ 		    ((unsigned) buf[1] << 8 | buf[0]);
+ 		*(__u32 *) buf = t;
+ 		buf += 4;
+ 	} while (--longs);
+ }
+ 
+ /*
+  * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
+  * initialization constants.
+  */
+ static void
+ MD5Init(struct MD5Context *ctx)
+ {
+ 	ctx->buf[0] = 0x67452301;
+ 	ctx->buf[1] = 0xefcdab89;
+ 	ctx->buf[2] = 0x98badcfe;
+ 	ctx->buf[3] = 0x10325476;
+ 
+ 	ctx->bits[0] = 0;
+ 	ctx->bits[1] = 0;
+ }
+ 
+ /*
+  * Update context to reflect the concatenation of another buffer full
+  * of bytes.
+  */
+ static void
+ MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
+ {
+ 	register __u32 t;
+ 
+ 	/* Update bitcount */
+ 
+ 	t = ctx->bits[0];
+ 	if ((ctx->bits[0] = t + ((__u32) len << 3)) < t)
+ 		ctx->bits[1]++;	/* Carry from low to high */
+ 	ctx->bits[1] += len >> 29;
+ 
+ 	t = (t >> 3) & 0x3f;	/* Bytes already in shsInfo->data */
+ 
+ 	/* Handle any leading odd-sized chunks */
+ 
+ 	if (t) {
+ 		unsigned char *p = (unsigned char *) ctx->in + t;
+ 
+ 		t = 64 - t;
+ 		if (len < t) {
+ 			memmove(p, buf, len);
+ 			return;
+ 		}
+ 		memmove(p, buf, t);
+ 		byteReverse(ctx->in, 16);
+ 		MD5Transform(ctx->buf, (__u32 *) ctx->in);
+ 		buf += t;
+ 		len -= t;
+ 	}
+ 	/* Process data in 64-byte chunks */
+ 
+ 	while (len >= 64) {
+ 		memmove(ctx->in, buf, 64);
+ 		byteReverse(ctx->in, 16);
+ 		MD5Transform(ctx->buf, (__u32 *) ctx->in);
+ 		buf += 64;
+ 		len -= 64;
+ 	}
+ 
+ 	/* Handle any remaining bytes of data. */
+ 
+ 	memmove(ctx->in, buf, len);
+ }
+ 
+ /*
+  * Final wrapup - pad to 64-byte boundary with the bit pattern
+  * 1 0* (64-bit count of bits processed, MSB-first)
+  */
+ static void
+ MD5Final(unsigned char digest[16], struct MD5Context *ctx)
+ {
+ 	unsigned int count;
+ 	unsigned char *p;
+ 
+ 	/* Compute number of bytes mod 64 */
+ 	count = (ctx->bits[0] >> 3) & 0x3F;
+ 
+ 	/* Set the first char of padding to 0x80.  This is safe since there is
+ 	   always at least one byte free */
+ 	p = ctx->in + count;
+ 	*p++ = 0x80;
+ 
+ 	/* Bytes of padding needed to make 64 bytes */
+ 	count = 64 - 1 - count;
+ 
+ 	/* Pad out to 56 mod 64 */
+ 	if (count < 8) {
+ 		/* Two lots of padding:  Pad the first block to 64 bytes */
+ 		memset(p, 0, count);
+ 		byteReverse(ctx->in, 16);
+ 		MD5Transform(ctx->buf, (__u32 *) ctx->in);
+ 
+ 		/* Now fill the next block with 56 bytes */
+ 		memset(ctx->in, 0, 56);
+ 	} else {
+ 		/* Pad block to 56 bytes */
+ 		memset(p, 0, count - 8);
+ 	}
+ 	byteReverse(ctx->in, 14);
+ 
+ 	/* Append length in bits and transform */
+ 	((__u32 *) ctx->in)[14] = ctx->bits[0];
+ 	((__u32 *) ctx->in)[15] = ctx->bits[1];
+ 
+ 	MD5Transform(ctx->buf, (__u32 *) ctx->in);
+ 	byteReverse((unsigned char *) ctx->buf, 4);
+ 	memmove(digest, ctx->buf, 16);
+ 	memset(ctx, 0, sizeof(*ctx));	/* In case it's sensitive */
+ }
+ 
+ /* The four core functions - F1 is optimized somewhat */
+ 
+ /* #define F1(x, y, z) (x & y | ~x & z) */
+ #define F1(x, y, z) (z ^ (x & (y ^ z)))
+ #define F2(x, y, z) F1(z, x, y)
+ #define F3(x, y, z) (x ^ y ^ z)
+ #define F4(x, y, z) (y ^ (x | ~z))
+ 
+ /* This is the central step in the MD5 algorithm. */
+ #define MD5STEP(f, w, x, y, z, data, s) \
+ 	( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
+ 
+ /*
+  * The core of the MD5 algorithm, this alters an existing MD5 hash to
+  * reflect the addition of 16 longwords of new data.  MD5Update blocks
+  * the data and converts bytes into longwords for this routine.
+  */
+ static void
+ MD5Transform(__u32 buf[4], __u32 const in[16])
+ {
+ 	register __u32 a, b, c, d;
+ 
+ 	a = buf[0];
+ 	b = buf[1];
+ 	c = buf[2];
+ 	d = buf[3];
+ 
+ 	MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
+ 	MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
+ 	MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
+ 	MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
+ 	MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
+ 	MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
+ 	MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
+ 	MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
+ 	MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
+ 	MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
+ 	MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
+ 	MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
+ 	MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
+ 	MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
+ 	MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
+ 	MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
+ 
+ 	MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
+ 	MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
+ 	MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
+ 	MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
+ 	MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
+ 	MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
+ 	MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
+ 	MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
+ 	MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
+ 	MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
+ 	MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
+ 	MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
+ 	MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
+ 	MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
+ 	MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
+ 	MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
+ 
+ 	MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
+ 	MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
+ 	MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
+ 	MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
+ 	MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
+ 	MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
+ 	MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
+ 	MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
+ 	MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
+ 	MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
+ 	MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
+ 	MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
+ 	MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
+ 	MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
+ 	MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
+ 	MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
+ 
+ 	MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
+ 	MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
+ 	MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
+ 	MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
+ 	MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
+ 	MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
+ 	MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
+ 	MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
+ 	MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
+ 	MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
+ 	MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
+ 	MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
+ 	MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
+ 	MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
+ 	MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
+ 	MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
+ 
+ 	buf[0] += a;
+ 	buf[1] += b;
+ 	buf[2] += c;
+ 	buf[3] += d;
+ }
+ 
+ /*
+  * Calculate and store in 'output' the MD5 digest of 'len' bytes at
+  * 'input'. 'output' must have enough space to hold 16 bytes.
+  */
+ void
+ md5 (unsigned char *input, int len, unsigned char output[16])
+ {
+ 	struct MD5Context context;
+ 
+ 	MD5Init(&context);
+ 	MD5Update(&context, input, len);
+ 	MD5Final(output, &context);
+ }
+ 
+ 
+ /*
+  * Calculate and store in 'output' the MD5 digest of 'len' bytes at 'input'.
+  * 'output' must have enough space to hold 16 bytes. If 'chunk' Trigger the
+  * watchdog every 'chunk_sz' bytes of input processed.
+  */
+ void
+ md5_wd (unsigned char *input, int len, unsigned char output[16],
+ 	unsigned int chunk_sz)
+ {
+ 	struct MD5Context context;
+ #if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+ 	unsigned char *end, *curr;
+ 	int chunk;
+ #endif
+ 
+ 	MD5Init(&context);
+ 
+ #if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+ 	curr = input;
+ 	end = input + len;
+ 	while (curr < end) {
+ 		chunk = end - curr;
+ 		if (chunk > chunk_sz)
+ 			chunk = chunk_sz;
+ 		MD5Update(&context, curr, chunk);
+ 		curr += chunk;
+ 		WATCHDOG_RESET ();
+ 	}
+ #else
+ 	MD5Update(&context, input, len);
+ #endif
+ 
+ 	MD5Final(output, &context);
+ }
diff -crBN u-boot-1.3.4.clean/tools/sha1.c u-boot-1.3.4/tools/sha1.c
*** u-boot-1.3.4.clean/tools/sha1.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/tools/sha1.c	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,452 ----
+ /*
+  *  Heiko Schocher, DENX Software Engineering, hs@denx.de.
+  *  based on:
+  *  FIPS-180-1 compliant SHA-1 implementation
+  *
+  *  Copyright (C) 2003-2006  Christophe Devine
+  *
+  *  This library is free software; you can redistribute it and/or
+  *  modify it under the terms of the GNU Lesser General Public
+  *  License, version 2.1 as published by the Free Software Foundation.
+  *
+  *  This library is distributed in the hope that it will be useful,
+  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  *  Lesser General Public License for more details.
+  *
+  *  You should have received a copy of the GNU Lesser General Public
+  *  License along with this library; if not, write to the Free Software
+  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+  *  MA  02110-1301  USA
+  */
+ /*
+  *  The SHA-1 standard was published by NIST in 1993.
+  *
+  *  http://www.itl.nist.gov/fipspubs/fip180-1.htm
+  */
+ 
+ #ifndef _CRT_SECURE_NO_DEPRECATE
+ #define _CRT_SECURE_NO_DEPRECATE 1
+ #endif
+ 
+ #ifndef USE_HOSTCC
+ #include <common.h>
+ #include <linux/string.h>
+ #else
+ #include <string.h>
+ #endif /* USE_HOSTCC */
+ #include <watchdog.h>
+ #include "sha1.h"
+ 
+ /*
+  * 32-bit integer manipulation macros (big endian)
+  */
+ #ifndef GET_UINT32_BE
+ #define GET_UINT32_BE(n,b,i) {				\
+ 	(n) = ( (unsigned long) (b)[(i)    ] << 24 )	\
+ 	    | ( (unsigned long) (b)[(i) + 1] << 16 )	\
+ 	    | ( (unsigned long) (b)[(i) + 2] <<  8 )	\
+ 	    | ( (unsigned long) (b)[(i) + 3]       );	\
+ }
+ #endif
+ #ifndef PUT_UINT32_BE
+ #define PUT_UINT32_BE(n,b,i) {				\
+ 	(b)[(i)    ] = (unsigned char) ( (n) >> 24 );	\
+ 	(b)[(i) + 1] = (unsigned char) ( (n) >> 16 );	\
+ 	(b)[(i) + 2] = (unsigned char) ( (n) >>  8 );	\
+ 	(b)[(i) + 3] = (unsigned char) ( (n)       );	\
+ }
+ #endif
+ 
+ /*
+  * SHA-1 context setup
+  */
+ void sha1_starts (sha1_context * ctx)
+ {
+ 	ctx->total[0] = 0;
+ 	ctx->total[1] = 0;
+ 
+ 	ctx->state[0] = 0x67452301;
+ 	ctx->state[1] = 0xEFCDAB89;
+ 	ctx->state[2] = 0x98BADCFE;
+ 	ctx->state[3] = 0x10325476;
+ 	ctx->state[4] = 0xC3D2E1F0;
+ }
+ 
+ static void sha1_process (sha1_context * ctx, unsigned char data[64])
+ {
+ 	unsigned long temp, W[16], A, B, C, D, E;
+ 
+ 	GET_UINT32_BE (W[0], data, 0);
+ 	GET_UINT32_BE (W[1], data, 4);
+ 	GET_UINT32_BE (W[2], data, 8);
+ 	GET_UINT32_BE (W[3], data, 12);
+ 	GET_UINT32_BE (W[4], data, 16);
+ 	GET_UINT32_BE (W[5], data, 20);
+ 	GET_UINT32_BE (W[6], data, 24);
+ 	GET_UINT32_BE (W[7], data, 28);
+ 	GET_UINT32_BE (W[8], data, 32);
+ 	GET_UINT32_BE (W[9], data, 36);
+ 	GET_UINT32_BE (W[10], data, 40);
+ 	GET_UINT32_BE (W[11], data, 44);
+ 	GET_UINT32_BE (W[12], data, 48);
+ 	GET_UINT32_BE (W[13], data, 52);
+ 	GET_UINT32_BE (W[14], data, 56);
+ 	GET_UINT32_BE (W[15], data, 60);
+ 
+ #define S(x,n)	((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))
+ 
+ #define R(t) (						\
+ 	temp = W[(t -  3) & 0x0F] ^ W[(t - 8) & 0x0F] ^	\
+ 	       W[(t - 14) & 0x0F] ^ W[ t      & 0x0F],	\
+ 	( W[t & 0x0F] = S(temp,1) )			\
+ )
+ 
+ #define P(a,b,c,d,e,x)	{				\
+ 	e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);	\
+ }
+ 
+ 	A = ctx->state[0];
+ 	B = ctx->state[1];
+ 	C = ctx->state[2];
+ 	D = ctx->state[3];
+ 	E = ctx->state[4];
+ 
+ #define F(x,y,z) (z ^ (x & (y ^ z)))
+ #define K 0x5A827999
+ 
+ 	P (A, B, C, D, E, W[0]);
+ 	P (E, A, B, C, D, W[1]);
+ 	P (D, E, A, B, C, W[2]);
+ 	P (C, D, E, A, B, W[3]);
+ 	P (B, C, D, E, A, W[4]);
+ 	P (A, B, C, D, E, W[5]);
+ 	P (E, A, B, C, D, W[6]);
+ 	P (D, E, A, B, C, W[7]);
+ 	P (C, D, E, A, B, W[8]);
+ 	P (B, C, D, E, A, W[9]);
+ 	P (A, B, C, D, E, W[10]);
+ 	P (E, A, B, C, D, W[11]);
+ 	P (D, E, A, B, C, W[12]);
+ 	P (C, D, E, A, B, W[13]);
+ 	P (B, C, D, E, A, W[14]);
+ 	P (A, B, C, D, E, W[15]);
+ 	P (E, A, B, C, D, R (16));
+ 	P (D, E, A, B, C, R (17));
+ 	P (C, D, E, A, B, R (18));
+ 	P (B, C, D, E, A, R (19));
+ 
+ #undef K
+ #undef F
+ 
+ #define F(x,y,z) (x ^ y ^ z)
+ #define K 0x6ED9EBA1
+ 
+ 	P (A, B, C, D, E, R (20));
+ 	P (E, A, B, C, D, R (21));
+ 	P (D, E, A, B, C, R (22));
+ 	P (C, D, E, A, B, R (23));
+ 	P (B, C, D, E, A, R (24));
+ 	P (A, B, C, D, E, R (25));
+ 	P (E, A, B, C, D, R (26));
+ 	P (D, E, A, B, C, R (27));
+ 	P (C, D, E, A, B, R (28));
+ 	P (B, C, D, E, A, R (29));
+ 	P (A, B, C, D, E, R (30));
+ 	P (E, A, B, C, D, R (31));
+ 	P (D, E, A, B, C, R (32));
+ 	P (C, D, E, A, B, R (33));
+ 	P (B, C, D, E, A, R (34));
+ 	P (A, B, C, D, E, R (35));
+ 	P (E, A, B, C, D, R (36));
+ 	P (D, E, A, B, C, R (37));
+ 	P (C, D, E, A, B, R (38));
+ 	P (B, C, D, E, A, R (39));
+ 
+ #undef K
+ #undef F
+ 
+ #define F(x,y,z) ((x & y) | (z & (x | y)))
+ #define K 0x8F1BBCDC
+ 
+ 	P (A, B, C, D, E, R (40));
+ 	P (E, A, B, C, D, R (41));
+ 	P (D, E, A, B, C, R (42));
+ 	P (C, D, E, A, B, R (43));
+ 	P (B, C, D, E, A, R (44));
+ 	P (A, B, C, D, E, R (45));
+ 	P (E, A, B, C, D, R (46));
+ 	P (D, E, A, B, C, R (47));
+ 	P (C, D, E, A, B, R (48));
+ 	P (B, C, D, E, A, R (49));
+ 	P (A, B, C, D, E, R (50));
+ 	P (E, A, B, C, D, R (51));
+ 	P (D, E, A, B, C, R (52));
+ 	P (C, D, E, A, B, R (53));
+ 	P (B, C, D, E, A, R (54));
+ 	P (A, B, C, D, E, R (55));
+ 	P (E, A, B, C, D, R (56));
+ 	P (D, E, A, B, C, R (57));
+ 	P (C, D, E, A, B, R (58));
+ 	P (B, C, D, E, A, R (59));
+ 
+ #undef K
+ #undef F
+ 
+ #define F(x,y,z) (x ^ y ^ z)
+ #define K 0xCA62C1D6
+ 
+ 	P (A, B, C, D, E, R (60));
+ 	P (E, A, B, C, D, R (61));
+ 	P (D, E, A, B, C, R (62));
+ 	P (C, D, E, A, B, R (63));
+ 	P (B, C, D, E, A, R (64));
+ 	P (A, B, C, D, E, R (65));
+ 	P (E, A, B, C, D, R (66));
+ 	P (D, E, A, B, C, R (67));
+ 	P (C, D, E, A, B, R (68));
+ 	P (B, C, D, E, A, R (69));
+ 	P (A, B, C, D, E, R (70));
+ 	P (E, A, B, C, D, R (71));
+ 	P (D, E, A, B, C, R (72));
+ 	P (C, D, E, A, B, R (73));
+ 	P (B, C, D, E, A, R (74));
+ 	P (A, B, C, D, E, R (75));
+ 	P (E, A, B, C, D, R (76));
+ 	P (D, E, A, B, C, R (77));
+ 	P (C, D, E, A, B, R (78));
+ 	P (B, C, D, E, A, R (79));
+ 
+ #undef K
+ #undef F
+ 
+ 	ctx->state[0] += A;
+ 	ctx->state[1] += B;
+ 	ctx->state[2] += C;
+ 	ctx->state[3] += D;
+ 	ctx->state[4] += E;
+ }
+ 
+ /*
+  * SHA-1 process buffer
+  */
+ void sha1_update (sha1_context * ctx, unsigned char *input, int ilen)
+ {
+ 	int fill;
+ 	unsigned long left;
+ 
+ 	if (ilen <= 0)
+ 		return;
+ 
+ 	left = ctx->total[0] & 0x3F;
+ 	fill = 64 - left;
+ 
+ 	ctx->total[0] += ilen;
+ 	ctx->total[0] &= 0xFFFFFFFF;
+ 
+ 	if (ctx->total[0] < (unsigned long) ilen)
+ 		ctx->total[1]++;
+ 
+ 	if (left && ilen >= fill) {
+ 		memcpy ((void *) (ctx->buffer + left), (void *) input, fill);
+ 		sha1_process (ctx, ctx->buffer);
+ 		input += fill;
+ 		ilen -= fill;
+ 		left = 0;
+ 	}
+ 
+ 	while (ilen >= 64) {
+ 		sha1_process (ctx, input);
+ 		input += 64;
+ 		ilen -= 64;
+ 	}
+ 
+ 	if (ilen > 0) {
+ 		memcpy ((void *) (ctx->buffer + left), (void *) input, ilen);
+ 	}
+ }
+ 
+ static const unsigned char sha1_padding[64] = {
+ 	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 	   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 	   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 	   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+ };
+ 
+ /*
+  * SHA-1 final digest
+  */
+ void sha1_finish (sha1_context * ctx, unsigned char output[20])
+ {
+ 	unsigned long last, padn;
+ 	unsigned long high, low;
+ 	unsigned char msglen[8];
+ 
+ 	high = (ctx->total[0] >> 29)
+ 		| (ctx->total[1] << 3);
+ 	low = (ctx->total[0] << 3);
+ 
+ 	PUT_UINT32_BE (high, msglen, 0);
+ 	PUT_UINT32_BE (low, msglen, 4);
+ 
+ 	last = ctx->total[0] & 0x3F;
+ 	padn = (last < 56) ? (56 - last) : (120 - last);
+ 
+ 	sha1_update (ctx, (unsigned char *) sha1_padding, padn);
+ 	sha1_update (ctx, msglen, 8);
+ 
+ 	PUT_UINT32_BE (ctx->state[0], output, 0);
+ 	PUT_UINT32_BE (ctx->state[1], output, 4);
+ 	PUT_UINT32_BE (ctx->state[2], output, 8);
+ 	PUT_UINT32_BE (ctx->state[3], output, 12);
+ 	PUT_UINT32_BE (ctx->state[4], output, 16);
+ }
+ 
+ /*
+  * Output = SHA-1( input buffer )
+  */
+ void sha1_csum (unsigned char *input, int ilen, unsigned char output[20])
+ {
+ 	sha1_context ctx;
+ 
+ 	sha1_starts (&ctx);
+ 	sha1_update (&ctx, input, ilen);
+ 	sha1_finish (&ctx, output);
+ }
+ 
+ /*
+  * Output = SHA-1( input buffer ). Trigger the watchdog every 'chunk_sz'
+  * bytes of input processed.
+  */
+ void sha1_csum_wd (unsigned char *input, int ilen, unsigned char output[20],
+ 			unsigned int chunk_sz)
+ {
+ 	sha1_context ctx;
+ #if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+ 	unsigned char *end, *curr;
+ 	int chunk;
+ #endif
+ 
+ 	sha1_starts (&ctx);
+ 
+ #if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+ 	curr = input;
+ 	end = input + ilen;
+ 	while (curr < end) {
+ 		chunk = end - curr;
+ 		if (chunk > chunk_sz)
+ 			chunk = chunk_sz;
+ 		sha1_update (&ctx, curr, chunk);
+ 		curr += chunk;
+ 		WATCHDOG_RESET ();
+ 	}
+ #else
+ 	sha1_update (&ctx, input, ilen);
+ #endif
+ 
+ 	sha1_finish (&ctx, output);
+ }
+ 
+ /*
+  * Output = HMAC-SHA-1( input buffer, hmac key )
+  */
+ void sha1_hmac (unsigned char *key, int keylen,
+ 		unsigned char *input, int ilen, unsigned char output[20])
+ {
+ 	int i;
+ 	sha1_context ctx;
+ 	unsigned char k_ipad[64];
+ 	unsigned char k_opad[64];
+ 	unsigned char tmpbuf[20];
+ 
+ 	memset (k_ipad, 0x36, 64);
+ 	memset (k_opad, 0x5C, 64);
+ 
+ 	for (i = 0; i < keylen; i++) {
+ 		if (i >= 64)
+ 			break;
+ 
+ 		k_ipad[i] ^= key[i];
+ 		k_opad[i] ^= key[i];
+ 	}
+ 
+ 	sha1_starts (&ctx);
+ 	sha1_update (&ctx, k_ipad, 64);
+ 	sha1_update (&ctx, input, ilen);
+ 	sha1_finish (&ctx, tmpbuf);
+ 
+ 	sha1_starts (&ctx);
+ 	sha1_update (&ctx, k_opad, 64);
+ 	sha1_update (&ctx, tmpbuf, 20);
+ 	sha1_finish (&ctx, output);
+ 
+ 	memset (k_ipad, 0, 64);
+ 	memset (k_opad, 0, 64);
+ 	memset (tmpbuf, 0, 20);
+ 	memset (&ctx, 0, sizeof (sha1_context));
+ }
+ 
+ static const char _sha1_src[] = "_sha1_src";
+ 
+ #ifdef SELF_TEST
+ /*
+  * FIPS-180-1 test vectors
+  */
+ static const char sha1_test_str[3][57] = {
+ 	{"abc"},
+ 	{"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"},
+ 	{""}
+ };
+ 
+ static const unsigned char sha1_test_sum[3][20] = {
+ 	{0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E,
+ 	 0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D},
+ 	{0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE,
+ 	 0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1},
+ 	{0x34, 0xAA, 0x97, 0x3C, 0xD4, 0xC4, 0xDA, 0xA4, 0xF6, 0x1E,
+ 	 0xEB, 0x2B, 0xDB, 0xAD, 0x27, 0x31, 0x65, 0x34, 0x01, 0x6F}
+ };
+ 
+ /*
+  * Checkup routine
+  */
+ int sha1_self_test (void)
+ {
+ 	int i, j;
+ 	unsigned char buf[1000];
+ 	unsigned char sha1sum[20];
+ 	sha1_context ctx;
+ 
+ 	for (i = 0; i < 3; i++) {
+ 		printf ("  SHA-1 test #%d: ", i + 1);
+ 
+ 		sha1_starts (&ctx);
+ 
+ 		if (i < 2)
+ 			sha1_update (&ctx, (unsigned char *) sha1_test_str[i],
+ 				     strlen (sha1_test_str[i]));
+ 		else {
+ 			memset (buf, 'a', 1000);
+ 			for (j = 0; j < 1000; j++)
+ 				sha1_update (&ctx, buf, 1000);
+ 		}
+ 
+ 		sha1_finish (&ctx, sha1sum);
+ 
+ 		if (memcmp (sha1sum, sha1_test_sum[i], 20) != 0) {
+ 			printf ("failed\n");
+ 			return (1);
+ 		}
+ 
+ 		printf ("passed\n");
+ 	}
+ 
+ 	printf ("\n");
+ 	return (0);
+ }
+ #else
+ int sha1_self_test (void)
+ {
+ 	return (0);
+ }
+ #endif
diff -crBN u-boot-1.3.4.clean/tools/zlib.h u-boot-1.3.4/tools/zlib.h
*** u-boot-1.3.4.clean/tools/zlib.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-1.3.4/tools/zlib.h	2009-05-15 19:12:59.000000000 +0200
***************
*** 0 ****
--- 1,434 ----
+ /*
+  * This file is derived from zlib.h and zconf.h from the zlib-0.95
+  * distribution by Jean-loup Gailly and Mark Adler, with some additions
+  * by Paul Mackerras to aid in implementing Deflate compression and
+  * decompression for PPP packets.
+  */
+ 
+ /*
+  *  ==FILEVERSION 960122==
+  *
+  * This marker is used by the Linux installation script to determine
+  * whether an up-to-date version of this file is already installed.
+  */
+ 
+ /* zlib.h -- interface of the 'zlib' general purpose compression library
+   version 0.95, Aug 16th, 1995.
+ 
+   Copyright (C) 1995 Jean-loup Gailly and Mark Adler
+ 
+   This software is provided 'as-is', without any express or implied
+   warranty.  In no event will the authors be held liable for any damages
+   arising from the use of this software.
+ 
+   Permission is granted to anyone to use this software for any purpose,
+   including commercial applications, and to alter it and redistribute it
+   freely, subject to the following restrictions:
+ 
+   1. The origin of this software must not be misrepresented; you must not
+      claim that you wrote the original software. If you use this software
+      in a product, an acknowledgment in the product documentation would be
+      appreciated but is not required.
+   2. Altered source versions must be plainly marked as such, and must not be
+      misrepresented as being the original software.
+   3. This notice may not be removed or altered from any source distribution.
+ 
+   Jean-loup Gailly        Mark Adler
+   gzip@prep.ai.mit.edu    madler@alumni.caltech.edu
+  */
+ 
+ #ifndef _ZLIB_H
+ #define _ZLIB_H
+ 
+ /* #include "zconf.h" */	/* included directly here */
+ 
+ /* zconf.h -- configuration of the zlib compression library
+  * Copyright (C) 1995 Jean-loup Gailly.
+  * For conditions of distribution and use, see copyright notice in zlib.h
+  */
+ 
+ /* From: zconf.h,v 1.12 1995/05/03 17:27:12 jloup Exp */
+ 
+ /*
+      The library does not install any signal handler. It is recommended to
+   add at least a handler for SIGSEGV when decompressing; the library checks
+   the consistency of the input data whenever possible but may go nuts
+   for some forms of corrupted input.
+  */
+ 
+ /*
+  * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+  * than 64k bytes at a time (needed on systems with 16-bit int).
+  * Compile with -DUNALIGNED_OK if it is OK to access shorts or ints
+  * at addresses which are not a multiple of their size.
+  * Under DOS, -DFAR=far or -DFAR=__far may be needed.
+  */
+ 
+ #ifndef STDC
+ #  if defined(MSDOS) || defined(__STDC__) || defined(__cplusplus)
+ #    define STDC
+ #  endif
+ #endif
+ 
+ #ifdef	__MWERKS__ /* Metrowerks CodeWarrior declares fileno() in unix.h */
+ #  include <unix.h>
+ #endif
+ 
+ /* Maximum value for memLevel in deflateInit2 */
+ #ifndef MAX_MEM_LEVEL
+ #  ifdef MAXSEG_64K
+ #    define MAX_MEM_LEVEL 8
+ #  else
+ #    define MAX_MEM_LEVEL 9
+ #  endif
+ #endif
+ 
+ #ifndef FAR
+ #  define FAR
+ #endif
+ 
+ /* Maximum value for windowBits in deflateInit2 and inflateInit2 */
+ #ifndef MAX_WBITS
+ #  define MAX_WBITS   15 /* 32K LZ77 window */
+ #endif
+ 
+ /* The memory requirements for deflate are (in bytes):
+ 	    1 << (windowBits+2)   +  1 << (memLevel+9)
+  that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+  plus a few kilobytes for small objects. For example, if you want to reduce
+  the default memory requirements from 256K to 128K, compile with
+      make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+  Of course this will generally degrade compression (there's no free lunch).
+ 
+    The memory requirements for inflate are (in bytes) 1 << windowBits
+  that is, 32K for windowBits=15 (default value) plus a few kilobytes
+  for small objects.
+ */
+ 
+ 			/* Type declarations */
+ 
+ #ifndef OF /* function prototypes */
+ #  ifdef STDC
+ #    define OF(args)  args
+ #  else
+ #    define OF(args)  ()
+ #  endif
+ #endif
+ 
+ typedef unsigned char  Byte;  /* 8 bits */
+ typedef unsigned int   uInt;  /* 16 bits or more */
+ typedef unsigned long  uLong; /* 32 bits or more */
+ 
+ typedef Byte FAR Bytef;
+ typedef char FAR charf;
+ typedef int FAR intf;
+ typedef uInt FAR uIntf;
+ typedef uLong FAR uLongf;
+ 
+ #ifdef STDC
+    typedef void FAR *voidpf;
+    typedef void     *voidp;
+ #else
+    typedef Byte FAR *voidpf;
+    typedef Byte     *voidp;
+ #endif
+ 
+ /* end of original zconf.h */
+ 
+ #define ZLIB_VERSION "0.95P"
+ 
+ /*
+      The 'zlib' compression library provides in-memory compression and
+   decompression functions, including integrity checks of the uncompressed
+   data.  This version of the library supports only one compression method
+   (deflation) but other algorithms may be added later and will have the same
+   stream interface.
+ 
+      For compression the application must provide the output buffer and
+   may optionally provide the input buffer for optimization. For decompression,
+   the application must provide the input buffer and may optionally provide
+   the output buffer for optimization.
+ 
+      Compression can be done in a single step if the buffers are large
+   enough (for example if an input file is mmap'ed), or can be done by
+   repeated calls of the compression function.  In the latter case, the
+   application must provide more input and/or consume the output
+   (providing more output space) before each call.
+ */
+ 
+ typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+ typedef void   (*free_func)  OF((voidpf opaque, voidpf address, uInt nbytes));
+ 
+ typedef void   (*cb_func)    OF((Bytef *buf, uInt len));
+ 
+ struct internal_state;
+ 
+ typedef struct z_stream_s {
+     Bytef    *next_in;  /* next input byte */
+     uInt     avail_in;  /* number of bytes available at next_in */
+     uLong    total_in;  /* total nb of input bytes read so far */
+ 
+     Bytef    *next_out; /* next output byte should be put there */
+     uInt     avail_out; /* remaining free space at next_out */
+     uLong    total_out; /* total nb of bytes output so far */
+ 
+     char     *msg;      /* last error message, NULL if no error */
+     struct internal_state FAR *state; /* not visible by applications */
+ 
+     alloc_func zalloc;  /* used to allocate the internal state */
+     free_func  zfree;   /* used to free the internal state */
+     voidp      opaque;  /* private data object passed to zalloc and zfree */
+ 
+     Byte     data_type; /* best guess about the data type: ascii or binary */
+ 
+     cb_func  outcb;	/* called regularly just before blocks of output */
+ 
+ } z_stream;
+ 
+ /*
+    The application must update next_in and avail_in when avail_in has
+    dropped to zero. It must update next_out and avail_out when avail_out
+    has dropped to zero. The application must initialize zalloc, zfree and
+    opaque before calling the init function. All other fields are set by the
+    compression library and must not be updated by the application.
+ 
+    The opaque value provided by the application will be passed as the first
+    parameter for calls of zalloc and zfree. This can be useful for custom
+    memory management. The compression library attaches no meaning to the
+    opaque value.
+ 
+    zalloc must return Z_NULL if there is not enough memory for the object.
+    On 16-bit systems, the functions zalloc and zfree must be able to allocate
+    exactly 65536 bytes, but will not be required to allocate more than this
+    if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+    pointers returned by zalloc for objects of exactly 65536 bytes *must*
+    have their offset normalized to zero. The default allocation function
+    provided by this library ensures this (see zutil.c). To reduce memory
+    requirements and avoid any allocation of 64K objects, at the expense of
+    compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+ 
+    The fields total_in and total_out can be used for statistics or
+    progress reports. After compression, total_in holds the total size of
+    the uncompressed data and may be saved for use in the decompressor
+    (particularly if the decompressor wants to decompress everything in
+    a single step).
+ */
+ 
+ 			/* constants */
+ 
+ #define Z_NO_FLUSH      0
+ #define Z_PARTIAL_FLUSH 1
+ #define Z_FULL_FLUSH    2
+ #define Z_SYNC_FLUSH    3 /* experimental: partial_flush + byte align */
+ #define Z_FINISH        4
+ #define Z_PACKET_FLUSH	5
+ /* See deflate() below for the usage of these constants */
+ 
+ #define Z_OK            0
+ #define Z_STREAM_END    1
+ #define Z_ERRNO        (-1)
+ #define Z_STREAM_ERROR (-2)
+ #define Z_DATA_ERROR   (-3)
+ #define Z_MEM_ERROR    (-4)
+ #define Z_BUF_ERROR    (-5)
+ /* error codes for the compression/decompression functions */
+ 
+ #define Z_BEST_SPEED             1
+ #define Z_BEST_COMPRESSION       9
+ #define Z_DEFAULT_COMPRESSION  (-1)
+ /* compression levels */
+ 
+ #define Z_FILTERED            1
+ #define Z_HUFFMAN_ONLY        2
+ #define Z_DEFAULT_STRATEGY    0
+ 
+ #define Z_BINARY   0
+ #define Z_ASCII    1
+ #define Z_UNKNOWN  2
+ /* Used to set the data_type field */
+ 
+ #define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+ 
+ extern char *zlib_version;
+ /* The application can compare zlib_version and ZLIB_VERSION for consistency.
+    If the first character differs, the library code actually used is
+    not compatible with the zlib.h header file used by the application.
+  */
+ 
+ 			/* basic functions */
+ 
+ extern int inflateInit OF((z_stream *strm));
+ /*
+      Initializes the internal stream state for decompression. The fields
+    zalloc and zfree must be initialized before by the caller.  If zalloc and
+    zfree are set to Z_NULL, inflateInit updates them to use default allocation
+    functions.
+ 
+      inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+    enough memory.  msg is set to null if there is no error message.
+    inflateInit does not perform any decompression: this will be done by
+    inflate().
+ */
+ 
+ 
+ extern int inflate OF((z_stream *strm, int flush));
+ /*
+   Performs one or both of the following actions:
+ 
+   - Decompress more input starting at next_in and update next_in and avail_in
+     accordingly. If not all input can be processed (because there is not
+     enough room in the output buffer), next_in is updated and processing
+     will resume at this point for the next call of inflate().
+ 
+   - Provide more output starting at next_out and update next_out and avail_out
+     accordingly.  inflate() always provides as much output as possible
+     (until there is no more input data or no more space in the output buffer).
+ 
+   Before the call of inflate(), the application should ensure that at least
+   one of the actions is possible, by providing more input and/or consuming
+   more output, and updating the next_* and avail_* values accordingly.
+   The application can consume the uncompressed output when it wants, for
+   example when the output buffer is full (avail_out == 0), or after each
+   call of inflate().
+ 
+     If the parameter flush is set to Z_PARTIAL_FLUSH or Z_PACKET_FLUSH,
+   inflate flushes as much output as possible to the output buffer. The
+   flushing behavior of inflate is not specified for values of the flush
+   parameter other than Z_PARTIAL_FLUSH, Z_PACKET_FLUSH or Z_FINISH, but the
+   current implementation actually flushes as much output as possible
+   anyway.  For Z_PACKET_FLUSH, inflate checks that once all the input data
+   has been consumed, it is expecting to see the length field of a stored
+   block; if not, it returns Z_DATA_ERROR.
+ 
+     inflate() should normally be called until it returns Z_STREAM_END or an
+   error. However if all decompression is to be performed in a single step
+   (a single call of inflate), the parameter flush should be set to
+   Z_FINISH. In this case all pending input is processed and all pending
+   output is flushed; avail_out must be large enough to hold all the
+   uncompressed data. (The size of the uncompressed data may have been saved
+   by the compressor for this purpose.) The next operation on this stream must
+   be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+   is never required, but can be used to inform inflate that a faster routine
+   may be used for the single inflate() call.
+ 
+     inflate() returns Z_OK if some progress has been made (more input
+   processed or more output produced), Z_STREAM_END if the end of the
+   compressed data has been reached and all uncompressed output has been
+   produced, Z_DATA_ERROR if the input data was corrupted, Z_STREAM_ERROR if
+   the stream structure was inconsistent (for example if next_in or next_out
+   was NULL), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR if no
+   progress is possible or if there was not enough room in the output buffer
+   when Z_FINISH is used. In the Z_DATA_ERROR case, the application may then
+   call inflateSync to look for a good compression block.  */
+ 
+ 
+ extern int inflateEnd OF((z_stream *strm));
+ /*
+      All dynamically allocated data structures for this stream are freed.
+    This function discards any unprocessed input and does not flush any
+    pending output.
+ 
+      inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+    was inconsistent. In the error case, msg may be set but then points to a
+    static string (which must not be deallocated).
+ */
+ 
+ 			/* advanced functions */
+ 
+ extern int inflateInit2 OF((z_stream *strm,
+ 			    int  windowBits));
+ /*
+      This is another version of inflateInit with more compression options. The
+    fields next_out, zalloc and zfree must be initialized before by the caller.
+ 
+      The windowBits parameter is the base two logarithm of the maximum window
+    size (the size of the history buffer).  It should be in the range 8..15 for
+    this version of the library (the value 16 will be allowed soon). The
+    default value is 15 if inflateInit is used instead. If a compressed stream
+    with a larger window size is given as input, inflate() will return with
+    the error code Z_DATA_ERROR instead of trying to allocate a larger window.
+ 
+      If next_out is not null, the library will use this buffer for the history
+    buffer; the buffer must either be large enough to hold the entire output
+    data, or have at least 1<<windowBits bytes.  If next_out is null, the
+    library will allocate its own buffer (and leave next_out null). next_in
+    need not be provided here but must be provided by the application for the
+    next call of inflate().
+ 
+      If the history buffer is provided by the application, next_out must
+    never be changed by the application since the decompressor maintains
+    history information inside this buffer from call to call; the application
+    can only reset next_out to the beginning of the history buffer when
+    avail_out is zero and all output has been consumed.
+ 
+       inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
+    not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
+    windowBits < 8). msg is set to null if there is no error message.
+    inflateInit2 does not perform any decompression: this will be done by
+    inflate().
+ */
+ 
+ extern int inflateSync OF((z_stream *strm));
+ /*
+     Skips invalid compressed data until the special marker (see deflate()
+   above) can be found, or until all available input is skipped. No output
+   is provided.
+ 
+     inflateSync returns Z_OK if the special marker has been found, Z_BUF_ERROR
+   if no more input was provided, Z_DATA_ERROR if no marker has been found,
+   or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+   case, the application may save the current current value of total_in which
+   indicates where valid compressed data was found. In the error case, the
+   application may repeatedly call inflateSync, providing more input each time,
+   until success or end of the input data.
+ */
+ 
+ extern int inflateReset OF((z_stream *strm));
+ /*
+      This function is equivalent to inflateEnd followed by inflateInit,
+    but does not free and reallocate all the internal decompression state.
+    The stream will keep attributes that may have been set by inflateInit2.
+ 
+       inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+    stream state was inconsistent (such as zalloc or state being NULL).
+ */
+ 
+ extern int inflateIncomp OF((z_stream *strm));
+ /*
+      This function adds the data at next_in (avail_in bytes) to the output
+    history without performing any output.  There must be no pending output,
+    and the decompressor must be expecting to see the start of a block.
+    Calling this function is equivalent to decompressing a stored block
+    containing the data at next_in (except that the data is not output).
+ */
+ 
+ 			/* checksum functions */
+ 
+ /*
+      This function is not related to compression but is exported
+    anyway because it might be useful in applications using the
+    compression library.
+ */
+ 
+ extern uLong adler32 OF((uLong adler, Bytef *buf, uInt len));
+ 
+ /*
+      Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+    return the updated checksum. If buf is NULL, this function returns
+    the required initial value for the checksum.
+    An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+    much faster. Usage example:
+ 
+      uLong adler = adler32(0L, Z_NULL, 0);
+ 
+      while (read_buffer(buffer, length) != EOF) {
+        adler = adler32(adler, buffer, length);
+      }
+      if (adler != original_adler) error();
+ */
+ 
+ #ifndef _Z_UTIL_H
+     struct internal_state {int dummy;}; /* hack for buggy compilers */
+ #endif
+ 
+ #endif /* _ZLIB_H */
